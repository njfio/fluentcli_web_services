==== START OF FILE: src//error.rs ====
// src/error.rs

use actix_web;
use actix_web::http::StatusCode;
use actix_web::ResponseError;
use diesel::r2d2;
use std::error::Error as StdError;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Database error: {0}")]
    DatabaseError(#[from] diesel::result::Error),

    #[error("Environment variable not found: {0}")]
    EnvVarError(#[from] std::env::VarError),

    #[error("Not found")]
    NotFound,

    #[error("Bad request: {0}")]
    BadRequest(String),

    #[error("R2D2 error: {0}")]
    R2D2Error(#[from] r2d2::PoolError),

    #[error("Unauthorized")]
    Unauthorized,

    #[error("Internal server error")]
    InternalServerError,

    #[error("Generic error: {0}")]
    GenericError(Box<dyn StdError + Send + Sync>),

    #[error("Migration error: {0}")]
    MigrationError(#[from] diesel_migrations::MigrationError),

    #[error("Authentication error")]
    AuthenticationError,

    #[error("Fluent CLI error: {0}")]
    FluentCLIError(String),

    #[error("External service error: {0}")]
    ExternalServiceError(String),
}

impl From<Box<dyn StdError + Send + Sync>> for AppError {
    fn from(error: Box<dyn StdError + Send + Sync>) -> Self {
        AppError::GenericError(error)
    }
}

impl ResponseError for AppError {
    fn status_code(&self) -> StatusCode {
        match self {
            AppError::NotFound => StatusCode::NOT_FOUND,
            AppError::BadRequest(_) => StatusCode::BAD_REQUEST,
            AppError::Unauthorized => StatusCode::UNAUTHORIZED,
            AppError::AuthenticationError => StatusCode::UNAUTHORIZED,
            AppError::ExternalServiceError(_) => StatusCode::BAD_GATEWAY,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    fn error_response(&self) -> actix_web::HttpResponse {
        actix_web::HttpResponse::build(self.status_code())
            .json(serde_json::json!({ "error": self.to_string() }))
    }
}
==== END OF FILE: src//error.rs ====

==== START OF FILE: src//config.rs ====
==== END OF FILE: src//config.rs ====

==== START OF FILE: src//lib.rs ====
pub mod error;
mod db;
mod models;
pub mod schema;
pub mod handlers;
pub mod routes;
pub mod services;
pub mod utils;
==== END OF FILE: src//lib.rs ====

==== START OF FILE: src//utils/error.rs ====
==== END OF FILE: src//utils/error.rs ====

==== START OF FILE: src//utils/encryption.rs ====
use aes::Aes256;
use block_modes::{BlockMode, Cbc};
use block_modes::block_padding::Pkcs7;
use hex;
use rand::Rng;
use std::env;
use std::str;
use crate::error::AppError;
use bcrypt::{hash, verify, DEFAULT_COST};


type Aes256Cbc = Cbc<Aes256, Pkcs7>;

fn get_key() -> Vec<u8> {
    let key = env::var("ENCRYPTION_KEY").expect("ENCRYPTION_KEY must be set");
    hex::decode(key).expect("Invalid ENCRYPTION_KEY")
}

pub fn encrypt_data(data: &str) -> String {
    let key = get_key();
    let iv = rand::thread_rng().gen::<[u8; 16]>();
    let cipher = Aes256Cbc::new_from_slices(&key, &iv).unwrap();
    let ciphertext = cipher.encrypt_vec(data.as_bytes());
    format!("{}:{}", hex::encode(iv), hex::encode(ciphertext))
}

pub fn decrypt_data(encrypted_data: &str) -> String {
    let key = get_key();
    let parts: Vec<&str> = encrypted_data.split(':').collect();
    let iv = hex::decode(parts[0]).unwrap();
    let ciphertext = hex::decode(parts[1]).unwrap();
    let cipher = Aes256Cbc::new_from_slices(&key, &iv).unwrap();
    let decrypted_data = cipher.decrypt_vec(&ciphertext).unwrap();
    str::from_utf8(&decrypted_data).unwrap().to_string()
}

pub fn hash_secure_key(secure_key: &str) -> Result<String, AppError> {
    hash(secure_key, DEFAULT_COST).map_err(|_| AppError::InternalServerError)
}

pub fn verify_secure_key(secure_key: &str, hash: &str) -> Result<bool, AppError> {
    verify(secure_key, hash).map_err(|_| AppError::InternalServerError)
}==== END OF FILE: src//utils/encryption.rs ====

==== START OF FILE: src//utils/auth.rs ====
use crate::error::AppError;
use crate::utils::jwt::validate_token;
use actix_web::dev::{Service, Transform};
use actix_web::{dev::ServiceRequest, Error, HttpMessage};
use bcrypt::{hash, verify, DEFAULT_COST};
use futures::future::{ok, Ready};
use futures::Future;
use std::pin::Pin;

pub fn hash_password(password: &str) -> Result<String, AppError> {
    hash(password, DEFAULT_COST).map_err(|_| AppError::InternalServerError)
}

pub fn verify_password(password: &str, hash: &str) -> Result<bool, AppError> {
    verify(password, hash).map_err(|_| AppError::InternalServerError)
}

pub struct Auth;

impl<S, B> Transform<S, ServiceRequest> for Auth
where
    S: Service<ServiceRequest, Response = actix_web::dev::ServiceResponse<B>, Error = Error>
        + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Transform = AuthMiddleware<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ok(AuthMiddleware { service })
    }
}

pub struct AuthMiddleware<S> {
    service: S,
}

impl<S, B> Service<ServiceRequest> for AuthMiddleware<S>
where
    S: Service<ServiceRequest, Response = actix_web::dev::ServiceResponse<B>, Error = Error>
        + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>>>>;

    fn poll_ready(
        &self,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Result<(), Self::Error>> {
        self.service.poll_ready(cx)
    }

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let auth_header = req
            .headers()
            .get("Authorization")
            .and_then(|h| h.to_str().ok());

        if let Some(auth_header) = auth_header {
            if auth_header.starts_with("Bearer ") {
                let token = &auth_header[7..];
                match validate_token(token) {
                    Ok((user_id, _)) => {
                        req.extensions_mut().insert(user_id);
                        let fut = self.service.call(req);
                        return Box::pin(async move {
                            let res = fut.await?;
                            Ok(res)
                        });
                    }
                    Err(e) => {
                        log::error!("Token validation failed: {:?}", e);
                        return Box::pin(async {
                            Err(actix_web::error::ErrorUnauthorized("Invalid token"))
                        });
                    }
                }
            } else {
                log::warn!("Malformed Authorization header: {}", auth_header);
            }
        } else {
            log::warn!("Missing Authorization header");
        }

        Box::pin(async {
            Err(actix_web::error::ErrorUnauthorized(
                "Authorization header missing or malformed",
            ))
        })
    }
}
==== END OF FILE: src//utils/auth.rs ====

==== START OF FILE: src//utils/mod.rs ====
pub mod auth;
pub mod jwt;
pub mod encryption;==== END OF FILE: src//utils/mod.rs ====

==== START OF FILE: src//utils/jwt.rs ====
use crate::error::AppError;
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::env;
use std::sync::RwLock;
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: Uuid,
    exp: usize,
    jti: String,
    version: u64,
}

pub fn generate_token(user_id: Uuid) -> Result<String, AppError> {
    let expiration = chrono::Utc::now()
        .checked_add_signed(chrono::Duration::hours(24))
        .expect("valid timestamp")
        .timestamp();

    let version = increment_token_version(&user_id);

    let claims = Claims {
        sub: user_id,
        exp: expiration as usize,
        jti: Uuid::new_v4().to_string(),
        version,
    };

    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(secret.as_bytes()),
    )
    .map_err(|_| AppError::InternalServerError)
}

lazy_static! {
    static ref TOKEN_VERSIONS: RwLock<HashMap<Uuid, u64>> = RwLock::new(HashMap::new());
}

pub fn get_token_version(user_id: &Uuid) -> u64 {
    TOKEN_VERSIONS
        .read()
        .unwrap()
        .get(user_id)
        .cloned()
        .unwrap_or(0)
}

pub fn increment_token_version(user_id: &Uuid) -> u64 {
    let mut versions = TOKEN_VERSIONS.write().unwrap();
    let version = versions.entry(*user_id).or_insert(0);
    *version += 1;
    *version
}

pub fn validate_token(token: &str) -> Result<(Uuid, u64), AppError> {
    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret.as_bytes()),
        &Validation::default(),
    )
    .map_err(|_| AppError::AuthenticationError)?;

    let current_time = chrono::Utc::now().timestamp() as usize;
    if token_data.claims.exp <= current_time {
        return Err(AppError::AuthenticationError);
    }

    let current_version = get_token_version(&token_data.claims.sub);
    if token_data.claims.version != current_version {
        return Err(AppError::AuthenticationError);
    }

    Ok((token_data.claims.sub, token_data.claims.version))
}
==== END OF FILE: src//utils/jwt.rs ====

==== START OF FILE: src//models/docker_file.rs ====
use crate::schema::docker_files;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = docker_files)]
pub struct DockerFile {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub content: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "docker_files"]
pub struct NewDockerFile {
    pub user_id: Uuid,
    pub name: String,
    pub content: String,
}

#[derive(Deserialize, Debug)]
pub struct NewDockerFilePayload {
    pub name: String,
    pub content: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "docker_files"]
pub struct UpdateDockerFile {
    pub name: Option<String>,
    pub content: Option<String>,
}==== END OF FILE: src//models/docker_file.rs ====

==== START OF FILE: src//models/job.rs ====
use crate::schema::jobs;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = jobs)]
pub struct Job {
    pub id: Uuid,
    pub user_id: Uuid,
    pub uri: Uuid,
    pub config: Uuid,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<Value>,
    pub data_path: Option<String>,
    pub worker_type: Uuid,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
    pub results: Option<Value>,
    pub pipeline_id: Uuid,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
}

#[derive(Insertable, Debug)]
#[table_name = "jobs"]
pub struct NewJob {
    pub user_id: Uuid,
    pub uri: Uuid,
    pub config: Uuid,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<Value>,
    pub data_path: Option<String>,
    pub worker_type: Uuid,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
    pub pipeline_id: Uuid,
    pub results: Option<Value>,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "jobs"]
pub struct UpdateJob {
    pub config: Option<Uuid>,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<Value>,
    pub data_path: Option<String>,
    pub worker_type: Option<Uuid>,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: Option<String>,
    pub results: Option<Value>,
    pub pipeline_id: Option<Uuid>,
}

#[derive(Deserialize, Debug)]
pub struct NewJobPayload {
    pub uri: Option<String>,
    pub config: Uuid,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
    pub pipeline_id: Uuid,
    pub results: Option<Value>,
}
==== END OF FILE: src//models/job.rs ====

==== START OF FILE: src//models/configuration.rs ====
use crate::schema::configurations;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = configurations)]
pub struct Configuration {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}


#[derive(Insertable, Debug)]
#[table_name = "configurations"]
pub struct NewConfiguration {
    pub user_id: Uuid,
    pub name: String,
    pub data: serde_json::Value,
}

#[derive(Deserialize, Debug)]
pub struct NewConfigurationPayload {
    pub name: String,
    pub data: serde_json::Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "configurations"]
pub struct UpdateConfiguration {
    pub name: Option<String>,
    pub data: Option<serde_json::Value>,
}==== END OF FILE: src//models/configuration.rs ====

==== START OF FILE: src//models/worker.rs ====
use crate::schema::workers;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = workers)]
pub struct Worker {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub worker_type: Uuid, // Reference to docker_file ID
    pub active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "workers"]
pub struct NewWorker {
    pub user_id: Uuid,
    pub name: String,
    pub worker_type: Uuid,
    pub active: bool,
}

#[derive(Deserialize, Debug)]
pub struct NewWorkerPayload {
    pub name: String,
    pub worker_type: Uuid,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "workers"]
pub struct UpdateWorker {
    pub name: Option<String>,
    pub worker_type: Option<Uuid>,
    pub active: Option<bool>,
}==== END OF FILE: src//models/worker.rs ====

==== START OF FILE: src//models/user.rs ====
use crate::schema::users;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Serialize, Deserialize)]
#[diesel(table_name = users)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Deserialize)]
pub struct NewUser {
    pub username: String,
    pub email: String,
    pub password: String, // This field is not in the database, but used for user creation
}

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUserDB {
    pub username: String,
    pub email: String,
    pub password_hash: String,
}

#[derive(AsChangeset, Deserialize)]
#[diesel(table_name = users)]
pub struct UpdateUser {
    pub username: Option<String>,
    pub email: Option<String>,
}
==== END OF FILE: src//models/user.rs ====

==== START OF FILE: src//models/active_worker.rs ====
use crate::schema::active_workers;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = active_workers)]
pub struct ActiveWorker {
    pub id: Uuid,
    pub user_id: Uuid,
    pub worker_type: String,
    pub is_active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}==== END OF FILE: src//models/active_worker.rs ====

==== START OF FILE: src//models/amber_store.rs ====
use crate::schema::amber_store;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = amber_store)]
pub struct AmberStore {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: String,
    #[serde(skip_serializing)]
    pub secure_key_hash: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "amber_store"]
pub struct NewAmberStore {
    pub user_id: Uuid,
    pub name: String,
    pub data: String,
    pub secure_key_hash: String,
}

#[derive(Deserialize, Debug)]
pub struct NewAmberStorePayload {
    pub name: String,
    pub data: serde_yaml::Value,
    pub secure_key_hash: String,
}

#[derive(AsChangeset, Deserialize, Debug)]
#[table_name = "amber_store"]
pub struct UpdateAmberStore {
    pub name: Option<String>,
    pub data: Option<String>,
    pub secure_key_hash: Option<String>,
}==== END OF FILE: src//models/amber_store.rs ====

==== START OF FILE: src//models/mod.rs ====
pub mod active_worker;
pub mod amber_store;
pub mod api_key;
pub mod configuration;
pub mod docker_file;
pub mod fluentcli;
pub mod job;
pub mod pipeline;
pub mod secure_vault;
pub mod user;
pub mod worker;
==== END OF FILE: src//models/mod.rs ====

==== START OF FILE: src//models/fluentcli.rs ====
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct CommandRequest {
    pub command: String,
    pub args: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct CommandResult {
    pub output: String,
    pub error: Option<String>,
    pub exit_code: i32,
}
==== END OF FILE: src//models/fluentcli.rs ====

==== START OF FILE: src//models/pipeline.rs ====
use crate::schema::pipelines;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = pipelines)]
pub struct Pipeline {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "pipelines"]
pub struct NewPipeline {
    pub user_id: Uuid,
    pub name: String,
    pub data: String,
}

#[derive(Deserialize, Debug)]
pub struct NewPipelinePayload {
    pub name: String,
    pub data: serde_yaml::Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "pipelines"]
pub struct UpdatePipeline {
    pub name: Option<String>,
    pub data: Option<String>,
}
==== END OF FILE: src//models/pipeline.rs ====

==== START OF FILE: src//models/secure_vault.rs ====
use crate::schema::secure_vaults;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = secure_vaults)]
pub struct SecureVault {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub encrypted_data: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "secure_vaults"]
pub struct NewSecureVault {
    pub user_id: Uuid,
    pub name: String,
    pub encrypted_data: String,
}

#[derive(Deserialize, Debug)]
pub struct NewSecureVaultPayload {
    pub name: String,
    pub data: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "secure_vaults"]
pub struct UpdateSecureVault {
    pub name: Option<String>,
    pub encrypted_data: Option<String>,
}==== END OF FILE: src//models/secure_vault.rs ====

==== START OF FILE: src//models/api_key.rs ====
use crate::schema::api_keys;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = api_keys)]
pub struct ApiKey {
    pub id: Uuid,
    pub user_id: Uuid,
    pub key_value: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
}
==== END OF FILE: src//models/api_key.rs ====

==== START OF FILE: src//routes.rs ====
use crate::handlers::{
    amber_store, api_key, configuration, docker_file, fluentcli, job, pipeline, secure_vault, user,
    worker,
};
use crate::utils::auth::Auth;
use actix_web::{web, HttpResponse, Scope};

pub fn configure_routes() -> Scope {
    web::scope("")
        // User routes
        .service(
            web::scope("/users")
                .route("/validate-token", web::get().to(user::validate_token))
                .route("/refresh", web::post().to(user::refresh_token))
                .route("", web::post().to(user::create_user))
                .route("", web::get().to(user::list_users))
                .route("/{id}", web::get().to(user::get_user))
                .route("/{id}", web::put().to(user::update_user))
                .route("/{id}", web::delete().to(user::delete_user))
                .route("/login", web::post().to(user::login)),
        )
        // API Key routes
        .service(
            web::scope("/api_keys")
                .route("", web::post().to(api_key::create_api_key))
                .route("", web::get().to(api_key::list_api_keys))
                .route("/{id}", web::delete().to(api_key::delete_api_key)),
        )
        // Job routes
        .service(
            web::scope("/jobs")
                .wrap(Auth)
                .route("", web::post().to(job::create_job))
                .route("", web::get().to(job::list_jobs))
                .route("/{id}", web::get().to(job::get_job))
                .route("/{id}", web::put().to(job::update_job))
                .route("/{id}", web::delete().to(job::delete_job))
                .route("/{id}/start", web::post().to(job::start_job))
                .route("/{id}/stop", web::post().to(job::stop_job))
                .route("/{id}/status", web::get().to(job::get_job_status))
                .route("/{id}/output", web::get().to(job::get_job_output))
                .route("/{id}/logs", web::get().to(job::get_job_logs)),
        )
        // Amber Store routes
        .service(
            web::scope("/amber_store")
                .wrap(Auth)
                .route("", web::post().to(amber_store::create_amber_store))
                .route("", web::get().to(amber_store::list_amber_stores))
                .route("/{id}", web::get().to(amber_store::get_amber_store))
                .route("/{id}", web::put().to(amber_store::update_amber_store))
                .route("/{id}", web::delete().to(amber_store::delete_amber_store)),
        )
        // Vault Store routes
        .service(
            web::scope("/secure_vaults")
                .wrap(Auth)
                .route("", web::post().to(secure_vault::create_secure_vault))
                .route("", web::get().to(secure_vault::list_secure_vaults))
                .route("/{id}", web::get().to(secure_vault::get_secure_vault))
                .route("/{id}", web::put().to(secure_vault::update_secure_vault))
                .route("/{id}", web::delete().to(secure_vault::delete_secure_vault)),
        )
        // Configuration routes
        .service(
            web::scope("/configurations")
                .wrap(Auth)
                .route("", web::post().to(configuration::create_configuration))
                .route("", web::get().to(configuration::list_configurations))
                .route("/{id}", web::get().to(configuration::get_configuration))
                .route("/{id}", web::put().to(configuration::update_configuration))
                .route(
                    "/{id}",
                    web::delete().to(configuration::delete_configuration),
                ),
        )
        // Pipeline routes
        .service(
            web::scope("/pipelines")
                .wrap(Auth)
                .route("", web::post().to(pipeline::create_pipeline))
                .route("", web::get().to(pipeline::list_pipelines))
                .route("/{id}", web::get().to(pipeline::get_pipeline))
                .route("/{id}", web::put().to(pipeline::update_pipeline))
                .route("/{id}", web::delete().to(pipeline::delete_pipeline)),
        )
        // Docker File routes
        .service(
            web::scope("/docker_files")
                .wrap(Auth)
                .route("", web::post().to(docker_file::create_docker_file))
                .route("", web::get().to(docker_file::list_docker_files))
                .route("/{id}", web::get().to(docker_file::get_docker_file))
                .route("/{id}", web::put().to(docker_file::update_docker_file))
                .route("/{id}", web::delete().to(docker_file::delete_docker_file)),
        )
        // Worker routes
        .service(
            web::scope("/workers")
                .wrap(Auth)
                .route("", web::post().to(worker::create_worker))
                .route("", web::get().to(worker::list_workers))
                .route("/{id}", web::get().to(worker::get_worker))
                .route("/{id}", web::put().to(worker::update_worker))
                .route("/{id}", web::delete().to(worker::delete_worker))
                .route("/{id}/activate", web::post().to(worker::activate_worker))
                .route(
                    "/{id}/deactivate",
                    web::post().to(worker::deactivate_worker),
                ),
        )
        .service(
            web::scope("/fluentcli")
                .wrap(Auth)
                .route("/execute", web::post().to(fluentcli::execute_command)),
        )
}
==== END OF FILE: src//routes.rs ====

==== START OF FILE: src//schema.rs ====
// @generated automatically by Diesel CLI.

diesel::table! {
    active_workers (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        worker_type -> Varchar,
        is_active -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    amber_store (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Text,
        #[max_length = 255]
        secure_key_hash -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    api_keys (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        key_value -> Varchar,
        description -> Nullable<Text>,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        expires_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    configurations (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    docker_files (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        content -> Text,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    jobs (id) {
        id -> Uuid,
        user_id -> Uuid,
        uri -> Uuid,
        config -> Uuid,
        amber_id -> Nullable<Uuid>,
        state_file_content -> Nullable<Jsonb>,
        data_path -> Nullable<Text>,
        worker_type -> Uuid,
        triggers -> Nullable<Jsonb>,
        timers -> Nullable<Jsonb>,
        #[max_length = 255]
        status -> Varchar,
        results -> Nullable<Jsonb>,
        pipeline_id -> Uuid,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        started_at -> Nullable<Timestamptz>,
        completed_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    pipelines (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Text,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    secure_vault (id) {
        id -> Uuid,
        user_id -> Uuid,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    secure_vaults (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        encrypted_data -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    users (id) {
        id -> Uuid,
        #[max_length = 255]
        username -> Varchar,
        #[max_length = 255]
        email -> Varchar,
        #[max_length = 255]
        password_hash -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    workers (id) {
        id -> Uuid,
        user_id -> Uuid,
        name -> Varchar,
        worker_type -> Uuid,
        active -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::joinable!(active_workers -> users (user_id));
diesel::joinable!(amber_store -> users (user_id));
diesel::joinable!(api_keys -> users (user_id));
diesel::joinable!(configurations -> users (user_id));
diesel::joinable!(docker_files -> users (user_id));
diesel::joinable!(jobs -> amber_store (amber_id));
diesel::joinable!(jobs -> configurations (config));
diesel::joinable!(jobs -> docker_files (worker_type));
diesel::joinable!(jobs -> pipelines (pipeline_id));
diesel::joinable!(jobs -> users (user_id));
diesel::joinable!(pipelines -> users (user_id));
diesel::joinable!(secure_vault -> users (user_id));
diesel::joinable!(secure_vaults -> users (user_id));
diesel::joinable!(workers -> docker_files (worker_type));

diesel::allow_tables_to_appear_in_same_query!(
    active_workers,
    amber_store,
    api_keys,
    configurations,
    docker_files,
    jobs,
    pipelines,
    secure_vault,
    secure_vaults,
    users,
    workers,
);
==== END OF FILE: src//schema.rs ====

==== START OF FILE: src//db/db.rs ====
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool, PoolError};
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use dotenv::dotenv;
use std::env;
use crate::error::AppError;

pub type DbPool = Pool<ConnectionManager<PgConnection>>;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations");

pub fn create_db_pool() -> Result<DbPool, PoolError> {
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    Pool::builder().build(manager)
}

pub fn setup_database(pool: &DbPool) -> Result<(), AppError> {
    let mut conn = pool.get()?;
    conn.run_pending_migrations(MIGRATIONS)?;
    Ok(())
}==== END OF FILE: src//db/db.rs ====

==== START OF FILE: src//db/mod.rs ====
pub mod db;

pub use db::{create_db_pool, setup_database, DbPool};==== END OF FILE: src//db/mod.rs ====

==== START OF FILE: src//main.rs ====
mod db;
mod error;
mod models;
mod schema;
mod routes;
mod handlers;
mod services;
mod utils;
use dotenv::dotenv;

use actix_web::{App, HttpServer, http, middleware, web};
use actix_cors::Cors;

use db::{create_db_pool, setup_database};
use routes::configure_routes;


#[actix_web::main]
async fn main() -> std::io::Result<()> {
    std::env::set_var("RUST_LOG", "debug"); //remove at release
    dotenv().ok();
    env_logger::init();

    // Set up the database
    let pool = create_db_pool().expect("Failed to create database pool");
    setup_database(&pool).expect("Failed to set up database");
    println!("Database setup complete");


    HttpServer::new(move || {
        let cors = Cors::default()
            .allow_any_origin() // Be cautious with this in production environments
            .allowed_methods(vec!["GET", "POST", "PUT", "DELETE", "OPTIONS"])
            .allowed_headers(vec![http::header::AUTHORIZATION, http::header::ACCEPT])
            .allowed_headers(vec![
                http::header::AUTHORIZATION,
                http::header::ACCEPT,
                http::header::CONTENT_TYPE,
            ])
            .supports_credentials()
            .max_age(3600);

        App::new()
            .wrap(cors)
            .wrap(middleware::Logger::default())
            .app_data(web::Data::new(pool.clone()))
            .service(configure_routes())
    })



    .bind("0.0.0.0:8000")?
    .run()
    .await
}==== END OF FILE: src//main.rs ====

==== START OF FILE: src//handlers/docker_file.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::docker_file_service::DockerFileService;
use crate::models::docker_file::{NewDockerFile, UpdateDockerFile, NewDockerFilePayload};

pub async fn create_docker_file(
    pool: web::Data<DbPool>,
    new_docker_file_payload: web::Json<NewDockerFilePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating docker file for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_docker_file_payload);

    let new_docker_file = NewDockerFile {
        user_id,
        name: new_docker_file_payload.name.clone(),
        content: new_docker_file_payload.content.clone(),
    };
    match DockerFileService::create_docker_file(&pool, new_docker_file) {
        Ok(docker_file) => {
            log::info!("Docker file created successfully: {:?}", docker_file);
            HttpResponse::Created().json(docker_file)
        },
        Err(e) => {
            log::error!("Error creating docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create docker file")
        }
    }
}

pub async fn list_docker_files(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::list_docker_files(&pool, user_id) {
        Ok(docker_files) => HttpResponse::Ok().json(docker_files),
        Err(e) => {
            log::error!("Error listing docker files: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list docker files")
        }
    }
}

pub async fn get_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::get_docker_file(&pool, docker_file_id.into_inner(), user_id) {
        Ok(docker_file) => HttpResponse::Ok().json(docker_file),
        Err(e) => {
            log::error!("Error getting docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get docker file")
        }
    }
}

pub async fn update_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    update_data: web::Json<UpdateDockerFile>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::update_docker_file(&pool, docker_file_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(docker_file) => HttpResponse::Ok().json(docker_file),
        Err(e) => {
            log::error!("Error updating docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update docker file")
        }
    }
}

pub async fn delete_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::delete_docker_file(&pool, docker_file_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete docker file")
        }
    }
}==== END OF FILE: src//handlers/docker_file.rs ====

==== START OF FILE: src//handlers/job.rs ====
use crate::db::DbPool;
use crate::models::job::{NewJob, NewJobPayload, UpdateJob};
use crate::services::job_service::JobService;
use actix_web::{web, HttpMessage, HttpRequest, HttpResponse, Responder};
use uuid::Uuid;

pub async fn create_job(
    pool: web::Data<DbPool>,
    new_job_payload: web::Json<NewJobPayload>,
    req: HttpRequest,
) -> Result<HttpResponse, actix_web::Error> {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();

    // Convert worker_type from String to Uuid
    let worker_type = Uuid::parse_str(&new_job_payload.worker_type)
        .map_err(|_| actix_web::error::ErrorBadRequest("Invalid worker_type UUID"))?;

    // Convert state_file_content from Option<String> to Option<Value>
    let state_file_content = new_job_payload
        .state_file_content
        .as_ref()
        .map(|content| {
            serde_json::from_str(content)
                .map_err(|_| actix_web::error::ErrorBadRequest("Invalid state_file_content JSON"))
        })
        .transpose()?;

    let new_job = NewJob {
        user_id,
        uri: Uuid::new_v4(), // Generate a new UUID for uri
        config: new_job_payload.config,
        amber_id: new_job_payload.amber_id,
        state_file_content,
        data_path: new_job_payload.data_path.clone(),
        worker_type,
        triggers: new_job_payload.triggers.clone(),
        timers: new_job_payload.timers.clone(),
        status: new_job_payload.status.clone(),
        pipeline_id: new_job_payload.pipeline_id,
        results: new_job_payload.results.clone(),
    };

    match JobService::create_job(&pool, new_job) {
        Ok(job) => Ok(HttpResponse::Created().json(job)),
        Err(e) => {
            log::error!("Error creating job: {:?}", e);
            Ok(HttpResponse::InternalServerError().body("Failed to create job"))
        }
    }
}

pub async fn list_jobs(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::list_jobs(&pool, user_id) {
        Ok(jobs) => HttpResponse::Ok().json(jobs),
        Err(e) => {
            log::error!("Error listing jobs: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list jobs")
        }
    }
}

pub async fn get_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error getting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job")
        }
    }
}

pub async fn update_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    update_data: web::Json<UpdateJob>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::update_job(
        &pool,
        job_id.into_inner(),
        update_data.into_inner(),
        user_id,
    ) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error updating job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update job")
        }
    }
}

pub async fn delete_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::delete_job(&pool, job_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete job")
        }
    }
}

pub async fn start_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::start_job(&pool, job_id.into_inner(), user_id).await {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error starting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to start job")
        }
    }
}

pub async fn stop_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::stop_job(&pool, job_id.into_inner(), user_id).await {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error stopping job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to stop job")
        }
    }
}

pub async fn get_job_status(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_status(&pool, job_id.into_inner(), user_id).await {
        Ok(status) => HttpResponse::Ok().json(status),
        Err(e) => {
            log::error!("Error getting job status: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job status")
        }
    }
}

pub async fn get_job_output(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_output(&pool, job_id.into_inner(), user_id).await {
        Ok(output) => HttpResponse::Ok().json(output),
        Err(e) => {
            log::error!("Error getting job output: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job output")
        }
    }
}

pub async fn get_job_logs(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_logs(&pool, job_id.into_inner(), user_id).await {
        Ok(logs) => HttpResponse::Ok().json(logs),
        Err(e) => {
            log::error!("Error getting job logs: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job logs")
        }
    }
}
==== END OF FILE: src//handlers/job.rs ====

==== START OF FILE: src//handlers/configuration.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::configuration_service::ConfigurationService;
use crate::models::configuration::{NewConfiguration, UpdateConfiguration, NewConfigurationPayload};

pub async fn create_configuration(
    pool: web::Data<DbPool>,
    new_configuration_payload: web::Json<NewConfigurationPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating configuration for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_configuration_payload);

    let new_configuration = NewConfiguration {
        user_id,
        name: new_configuration_payload.name.clone(),
        data: new_configuration_payload.data.clone(),
    };
    match ConfigurationService::create_configuration(&pool, new_configuration) {
        Ok(configuration) => {
            log::info!("Configuration created successfully: {:?}", configuration);
            HttpResponse::Created().json(configuration)
        },
        Err(e) => {
            log::error!("Error creating configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create configuration")
        }
    }
}

pub async fn list_configurations(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::list_configurations(&pool, user_id) {
        Ok(configurations) => HttpResponse::Ok().json(configurations),
        Err(e) => {
            log::error!("Error listing configurations: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list configurations")
        }
    }
}

pub async fn get_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::get_configuration(&pool, configuration_id.into_inner(), user_id) {
        Ok(configuration) => HttpResponse::Ok().json(configuration),
        Err(e) => {
            log::error!("Error getting configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get configuration")
        }
    }
}

pub async fn update_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    update_data: web::Json<UpdateConfiguration>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::update_configuration(&pool, configuration_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(configuration) => HttpResponse::Ok().json(configuration),
        Err(e) => {
            log::error!("Error updating configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update configuration")
        }
    }
}

pub async fn delete_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::delete_configuration(&pool, configuration_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete configuration")
        }
    }
}==== END OF FILE: src//handlers/configuration.rs ====

==== START OF FILE: src//handlers/worker.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::worker_service::WorkerService;
use crate::models::worker::{NewWorker, UpdateWorker, NewWorkerPayload};


pub async fn create_worker(
    pool: web::Data<DbPool>,
    new_worker_payload: web::Json<NewWorkerPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating worker for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_worker_payload);

    let new_worker = NewWorker {
        user_id,
        name: new_worker_payload.name.clone(),
        worker_type: new_worker_payload.worker_type,
        active: false,
    };
    log::info!("New worker data: {:?}", new_worker);

    match WorkerService::create_worker(&pool, new_worker) {
        Ok(worker) => {
            log::info!("Worker created successfully: {:?}", worker);
            HttpResponse::Created().json(worker)
        },
        Err(e) => {
            log::error!("Error creating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create worker")
        }
    }
}

pub async fn list_workers(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::list_workers(&pool, user_id) {
        Ok(workers) => HttpResponse::Ok().json(workers),
        Err(e) => {
            log::error!("Error listing workers: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list workers")
        }
    }
}

pub async fn get_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::get_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error getting worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get worker")
        }
    }
}

pub async fn update_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    update_data: web::Json<UpdateWorker>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::update_worker(&pool, worker_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error updating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update worker")
        }
    }
}

pub async fn delete_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::delete_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete worker")
        }
    }
}

pub async fn activate_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::activate_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error activating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to activate worker")
        }
    }
}

pub async fn deactivate_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::deactivate_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error deactivating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to deactivate worker")
        }
    }
}==== END OF FILE: src//handlers/worker.rs ====

==== START OF FILE: src//handlers/user.rs ====
use crate::error::AppError;
use crate::models::user::{NewUser, UpdateUser};

use crate::db::DbPool;
use actix_web::{web, Error, HttpResponse, Responder};
use serde_json::json;
use uuid::Uuid;

use crate::services::user_service::UserService;
use crate::utils::jwt::{generate_token, validate_token as jwt_validate_token};
use serde::Deserialize;

#[derive(Deserialize)]
pub struct LoginRequest {
    username: String,
    password: String,
}

pub async fn create_user(
    pool: web::Data<DbPool>,
    new_user: web::Json<NewUser>,
) -> Result<HttpResponse, AppError> {
    if UserService::email_exists(&pool, &new_user.email)? {
        return Err(AppError::BadRequest("Email already in use".into()));
    }

    let user = UserService::create_user(&pool, new_user.into_inner())?;
    Ok(HttpResponse::Created().json(user))
}

pub async fn login(
    pool: web::Data<DbPool>,
    login_req: web::Json<LoginRequest>,
) -> Result<HttpResponse, Error> {
    match UserService::login(&pool, &login_req.username, &login_req.password) {
        Ok(user) => match generate_token(user.id) {
            Ok(token) => Ok(HttpResponse::Ok().json(json!({ "token": token, "user": user }))),
            Err(e) => {
                log::error!("Token generation error: {:?}", e);
                Err(actix_web::error::ErrorInternalServerError(
                    "Failed to generate token",
                ))
            }
        },
        Err(e) => {
            log::error!("Login error: {:?}", e);
            match e {
                AppError::AuthenticationError => {
                    Err(actix_web::error::ErrorUnauthorized("Invalid credentials"))
                }
                _ => Err(actix_web::error::ErrorInternalServerError("Login failed")),
            }
        }
    }
}

pub async fn list_users(pool: web::Data<DbPool>) -> Result<HttpResponse, Error> {
    match UserService::list_users(&pool) {
        Ok(users) => Ok(HttpResponse::Ok().json(users)),
        Err(e) => {
            log::error!("Error listing users: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError(
                "Failed to list users",
            ))
        }
    }
}

use actix_web::HttpRequest;

pub async fn get_user(
    req: HttpRequest,
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
) -> Result<HttpResponse, Error> {
    log::info!(
        "Received GET user request. User ID: {:?}, Headers: {:?}",
        user_id,
        req.headers()
    );
    match UserService::get_user(&pool, user_id.into_inner()) {
        Ok(user) => Ok(HttpResponse::Ok().json(user)),
        Err(e) => {
            log::error!("Error getting user: {:?}", e);
            match e {
                AppError::NotFound => Err(actix_web::error::ErrorNotFound("User not found")),
                _ => Err(actix_web::error::ErrorInternalServerError(
                    "Failed to get user",
                )),
            }
        }
    }
}

pub async fn update_user(
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
    user_data: web::Json<UpdateUser>,
) -> Result<HttpResponse, Error> {
    match UserService::update_user(&pool, user_id.into_inner(), user_data.into_inner()) {
        Ok(user) => Ok(HttpResponse::Ok().json(user)),
        Err(e) => {
            log::error!("Error updating user: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError(
                "Failed to update user",
            ))
        }
    }
}

pub async fn delete_user(
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
) -> Result<HttpResponse, Error> {
    match UserService::delete_user(&pool, user_id.into_inner()) {
        Ok(_) => Ok(HttpResponse::NoContent().finish()),
        Err(e) => {
            log::error!("Error deleting user: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError(
                "Failed to delete user",
            ))
        }
    }
}

pub async fn refresh_token(
    pool: web::Data<DbPool>,
    req: HttpRequest,
) -> Result<HttpResponse, Error> {
    if let Some(auth_header) = req.headers().get("Authorization") {
        if let Ok(auth_str) = auth_header.to_str() {
            if auth_str.starts_with("Bearer ") {
                let token = &auth_str[7..];
                match UserService::refresh_token(&pool, token) {
                    Ok(new_token) => {
                        return Ok(HttpResponse::Ok().json(json!({ "token": new_token })));
                    }
                    Err(e) => {
                        log::error!("Failed to refresh token: {:?}", e);
                        return Err(actix_web::error::ErrorUnauthorized("Invalid token"));
                    }
                }
            }
        }
    }
    log::warn!("Missing or invalid Authorization header");
    Err(actix_web::error::ErrorUnauthorized("Invalid token"))
}

pub async fn validate_token(
    req: HttpRequest,
    pool: web::Data<DbPool>,
) -> Result<HttpResponse, Error> {
    log::info!("Validate token function called");
    if let Some(auth_header) = req.headers().get("Authorization") {
        log::info!("Authorization header found: {:?}", auth_header);
        if let Ok(auth_str) = auth_header.to_str() {
            log::info!("Authorization string: {}", auth_str);
            if auth_str.starts_with("Bearer ") {
                let token = &auth_str[7..];
                log::info!("Token extracted: {}", token);
                match jwt_validate_token(token) {
                    Ok((user_id, token_version)) => {
                        log::info!("Token validated successfully. User ID: {}, Version: {}", user_id, token_version);
                        // Check if the user exists in the database
                        match UserService::get_user(&pool, user_id) {
                            Ok(_) => {
                                return Ok(HttpResponse::Ok().json(json!({ "user_id": user_id, "token_version": token_version })))
                            }
                            Err(e) => {
                                log::error!("User not found: {:?}", e);
                                return Ok(HttpResponse::NotFound()
                                    .json(json!({ "error": "User not found" })));
                            }
                        }
                    }
                    Err(e) => {
                        log::error!("Token validation failed: {:?}", e);
                        return Ok(
                            HttpResponse::Unauthorized().json(json!({ "error": "Invalid token" }))
                        );
                    }
                }
            }
        }
    }
    log::warn!("Missing or invalid Authorization header");
    Ok(HttpResponse::Unauthorized()
        .json(json!({ "error": "Missing or invalid Authorization header" })))
}
==== END OF FILE: src//handlers/user.rs ====

==== START OF FILE: src//handlers/amber_store.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::amber_store_service::AmberStoreService;
use crate::models::amber_store::{NewAmberStore, UpdateAmberStore, NewAmberStorePayload};
use crate::utils::encryption::hash_secure_key;
use crate::error::AppError;


pub async fn create_amber_store(
    pool: web::Data<DbPool>,
    new_amber_store_payload: web::Json<NewAmberStorePayload>,
    req: HttpRequest,
) -> Result<HttpResponse, actix_web::Error> {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    
    let secure_key_hash = hash_secure_key(&new_amber_store_payload.secure_key_hash)
        .map_err(|_| actix_web::error::ErrorInternalServerError("Failed to hash secure key"))?;

    let new_amber_store = NewAmberStore {
        user_id,
        name: new_amber_store_payload.name.clone(),
        data: serde_yaml::to_string(&new_amber_store_payload.data).unwrap(),
        secure_key_hash,
    };

    match AmberStoreService::create_amber_store(&pool, new_amber_store) {
        Ok(amber_store) => Ok(HttpResponse::Created().json(amber_store)),
        Err(e) => {
            log::error!("Error creating amber store: {:?}", e);
            Ok(HttpResponse::InternalServerError().body("Failed to create amber store"))
        }
    }
}

pub async fn list_amber_stores(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::list_amber_stores(&pool, user_id) {
        Ok(amber_stores) => HttpResponse::Ok().json(amber_stores),
        Err(e) => {
            log::error!("Error listing amber stores: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list amber stores")
        }
    }
}

pub async fn get_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::get_amber_store(&pool, amber_store_id.into_inner(), user_id) {
        Ok(amber_store) => HttpResponse::Ok().json(amber_store),
        Err(e) => {
            log::error!("Error getting amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get amber store")
        }
    }
}

pub async fn update_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    update_data: web::Json<UpdateAmberStore>,
    req: HttpRequest,
) -> Result<HttpResponse, actix_web::Error> {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    
    let mut update_data = update_data.into_inner();
    if let Some(secure_key) = update_data.secure_key_hash.take() {
        let secure_key_hash = hash_secure_key(&secure_key)
            .map_err(|_| actix_web::error::ErrorInternalServerError("Failed to hash secure key"))?;
        update_data.secure_key_hash = Some(secure_key_hash);
    }

    match AmberStoreService::update_amber_store(&pool, amber_store_id.into_inner(), update_data, user_id) {
        Ok(amber_store) => Ok(HttpResponse::Ok().json(amber_store)),
        Err(e) => {
            log::error!("Error updating amber store: {:?}", e);
            Ok(HttpResponse::InternalServerError().body("Failed to update amber store"))
        }
    }
}

pub async fn delete_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::delete_amber_store(&pool, amber_store_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete amber store")
        }
    }
}==== END OF FILE: src//handlers/amber_store.rs ====

==== START OF FILE: src//handlers/mod.rs ====
pub mod user;
pub mod job;
pub mod api_key;
pub mod amber_store;
pub mod secure_vault;
pub mod configuration;
pub mod pipeline;
pub mod docker_file;
pub mod worker;
pub mod fluentcli;==== END OF FILE: src//handlers/mod.rs ====

==== START OF FILE: src//handlers/fluentcli.rs ====
use crate::models::fluentcli::CommandRequest;
use crate::services::fluentcli_service::FluentCLIService;
use actix_web::{web, HttpMessage, HttpRequest, HttpResponse, Responder};
use log::{debug, error, info};
use uuid::Uuid;

pub async fn execute_command(
    command_request: web::Json<CommandRequest>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    info!("Received execute_command request for user_id: {}", user_id);
    debug!("Command request: {:?}", command_request);

    match FluentCLIService::execute_command(user_id, command_request.into_inner()).await {
        Ok(result) => {
            info!("Command executed successfully");
            debug!("Command result: {:?}", result);
            HttpResponse::Ok().json(result)
        }
        Err(e) => {
            error!("Error executing FluentCLI command: {:?}", e);
            HttpResponse::InternalServerError()
                .body(format!("Failed to execute FluentCLI command: {:?}", e))
        }
    }
}
==== END OF FILE: src//handlers/fluentcli.rs ====

==== START OF FILE: src//handlers/pipeline.rs ====
use crate::db::DbPool;
use crate::models::pipeline::{NewPipeline, NewPipelinePayload, UpdatePipeline};
use crate::services::pipeline_service::PipelineService;
use actix_web::{web, HttpMessage, HttpRequest, HttpResponse, Responder};
use serde_yaml;
use uuid::Uuid;

pub async fn create_pipeline(
    pool: web::Data<DbPool>,
    new_pipeline_payload: web::Json<NewPipelinePayload>,
    req: HttpRequest,
) -> Result<HttpResponse, actix_web::Error> {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();

    let yaml_data = serde_yaml::to_string(&new_pipeline_payload.data)
        .map_err(|_| actix_web::error::ErrorBadRequest("Invalid YAML data"))?;

    let new_pipeline = NewPipeline {
        user_id,
        name: new_pipeline_payload.name.clone(),
        data: yaml_data,
    };

    match PipelineService::create_pipeline(&pool, new_pipeline) {
        Ok(pipeline) => Ok(HttpResponse::Created().json(pipeline)),
        Err(e) => {
            log::error!("Error creating pipeline: {:?}", e);
            Ok(HttpResponse::InternalServerError().body("Failed to create pipeline"))
        }
    }
}

pub async fn list_pipelines(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::list_pipelines(&pool, user_id) {
        Ok(pipelines) => HttpResponse::Ok().json(pipelines),
        Err(e) => {
            log::error!("Error listing pipelines: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list pipelines")
        }
    }
}

pub async fn get_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::get_pipeline(&pool, pipeline_id.into_inner(), user_id) {
        Ok(pipeline) => HttpResponse::Ok().json(pipeline),
        Err(e) => {
            log::error!("Error getting pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get pipeline")
        }
    }
}

pub async fn update_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    update_data: web::Json<UpdatePipeline>,
    req: HttpRequest,
) -> Result<HttpResponse, actix_web::Error> {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();

    let yaml_data = if let Some(data) = &update_data.data {
        Some(
            serde_yaml::to_string(data)
                .map_err(|_| actix_web::error::ErrorBadRequest("Invalid YAML data"))?,
        )
    } else {
        None
    };

    let update_pipeline = UpdatePipeline {
        name: update_data.name.clone(),
        data: yaml_data,
    };

    match PipelineService::update_pipeline(
        &pool,
        pipeline_id.into_inner(),
        update_pipeline,
        user_id,
    ) {
        Ok(pipeline) => Ok(HttpResponse::Ok().json(pipeline)),
        Err(e) => {
            log::error!("Error updating pipeline: {:?}", e);
            Ok(HttpResponse::InternalServerError().body("Failed to update pipeline"))
        }
    }
}

pub async fn delete_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::delete_pipeline(&pool, pipeline_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete pipeline")
        }
    }
}
==== END OF FILE: src//handlers/pipeline.rs ====

==== START OF FILE: src//handlers/secure_vault.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::secure_vault_service::SecureVaultService;
use crate::models::secure_vault::{NewSecureVault, UpdateSecureVault, NewSecureVaultPayload};
use crate::utils::encryption::encrypt_data;

pub async fn create_secure_vault(
    pool: web::Data<DbPool>,
    new_secure_vault_payload: web::Json<NewSecureVaultPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating secure vault for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_secure_vault_payload);

    let encrypted_data = encrypt_data(&new_secure_vault_payload.data);
    let new_secure_vault = NewSecureVault {
        user_id,
        name: new_secure_vault_payload.name.clone(),
        encrypted_data,
    };
    log::info!("New secure vault data: {:?}", new_secure_vault);

    match SecureVaultService::create_secure_vault(&pool, new_secure_vault) {
        Ok(secure_vault) => {
            log::info!("Secure vault created successfully: {:?}", secure_vault);
            HttpResponse::Created().json(secure_vault)
        },
        Err(e) => {
            log::error!("Error creating secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create secure vault")
        }
    }
}

pub async fn list_secure_vaults(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::list_secure_vaults(&pool, user_id) {
        Ok(secure_vaults) => HttpResponse::Ok().json(secure_vaults),
        Err(e) => {
            log::error!("Error listing secure vaults: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list secure vaults")
        }
    }
}

pub async fn get_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::get_secure_vault(&pool, secure_vault_id.into_inner(), user_id) {
        Ok(secure_vault) => HttpResponse::Ok().json(secure_vault),
        Err(e) => {
            log::error!("Error getting secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get secure vault")
        }
    }
}

pub async fn update_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    update_data: web::Json<UpdateSecureVault>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::update_secure_vault(&pool, secure_vault_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(secure_vault) => HttpResponse::Ok().json(secure_vault),
        Err(e) => {
            log::error!("Error updating secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update secure vault")
        }
    }
}

pub async fn delete_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::delete_secure_vault(&pool, secure_vault_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete secure vault")
        }
    }
}==== END OF FILE: src//handlers/secure_vault.rs ====

==== START OF FILE: src//handlers/api_key.rs ====
use actix_web::{web, HttpResponse, Responder};

pub async fn create_api_key() -> impl Responder {
    HttpResponse::Ok().body("Create API key")
}

pub async fn list_api_keys() -> impl Responder {
    HttpResponse::Ok().body("List API keys")
}

pub async fn delete_api_key() -> impl Responder {
    HttpResponse::Ok().body("Delete API key")
}
==== END OF FILE: src//handlers/api_key.rs ====

==== START OF FILE: src//services/fluentcli_service.rs ====
use crate::error::AppError;
use crate::models::fluentcli::{CommandRequest, CommandResult};
use log::{debug, info};
use reqwest;
use uuid::Uuid;

const WORKER_ADDRESS: &str = "http://worker:8080"; // Adjust this to match your Docker setup

pub struct FluentCLIService;

impl FluentCLIService {
    pub async fn execute_command(
        user_id: Uuid,
        command: CommandRequest,
    ) -> Result<CommandResult, AppError> {
        info!("Executing command for user_id: {}", user_id);
        debug!("Command request: {:?}", command);

        let client = reqwest::Client::new();
        let response = client
            .post(&format!("{}/execute", WORKER_ADDRESS))
            .json(&command)
            .send()
            .await
            .map_err(|e| AppError::ExternalServiceError(e.to_string()))?;

        let result: CommandResult = response
            .json()
            .await
            .map_err(|e| AppError::ExternalServiceError(e.to_string()))?;

        Ok(result)
    }
}
==== END OF FILE: src//services/fluentcli_service.rs ====

==== START OF FILE: src//services/worker_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::worker::{Worker, NewWorker, UpdateWorker};
use diesel::prelude::*;
use uuid::Uuid;

pub struct WorkerService;

impl WorkerService {
    pub fn create_worker(pool: &DbPool, new_worker: NewWorker) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new worker into database: {:?}", new_worker);
        match diesel::insert_into(workers)
            .values(&new_worker)
            .get_result(conn) {
            Ok(worker) => {
                log::info!("Worker inserted into database: {:?}", worker);
                Ok(worker)
            },
            Err(e) => {
                log::error!("Error inserting worker into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_workers(pool: &DbPool, user_id: Uuid) -> Result<Vec<Worker>, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        workers.filter(user_id.eq(user_id)).load::<Worker>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        workers.filter(id.eq(worker_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_worker(pool: &DbPool, worker_id: Uuid, update_data: UpdateWorker, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }

    pub fn activate_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(active.eq(true))
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn deactivate_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(active.eq(false))
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
}==== END OF FILE: src//services/worker_service.rs ====

==== START OF FILE: src//services/configuration_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::configuration::{Configuration, NewConfiguration, UpdateConfiguration};
use diesel::prelude::*;
use uuid::Uuid;

pub struct ConfigurationService;

impl ConfigurationService {
    pub fn create_configuration(pool: &DbPool, new_configuration: NewConfiguration) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new configuration into database: {:?}", new_configuration);
        diesel::insert_into(configurations)
            .values(&new_configuration)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_configurations(pool: &DbPool, user_id: Uuid) -> Result<Vec<Configuration>, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        configurations.filter(user_id.eq(user_id)).load::<Configuration>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_configuration(pool: &DbPool, configuration_id: Uuid, user_id: Uuid) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_configuration(pool: &DbPool, configuration_id: Uuid, update_data: UpdateConfiguration, user_id: Uuid) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_configuration(pool: &DbPool, configuration_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/configuration_service.rs ====

==== START OF FILE: src//services/docker_file_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::docker_file::{DockerFile, NewDockerFile, UpdateDockerFile};
use diesel::prelude::*;
use uuid::Uuid;

pub struct DockerFileService;

impl DockerFileService {
    pub fn create_docker_file(pool: &DbPool, new_docker_file: NewDockerFile) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new docker file into database: {:?}", new_docker_file);
        diesel::insert_into(docker_files)
            .values(&new_docker_file)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_docker_files(pool: &DbPool, user_id: Uuid) -> Result<Vec<DockerFile>, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        docker_files.filter(user_id.eq(user_id)).load::<DockerFile>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_docker_file(pool: &DbPool, docker_file_id: Uuid, user_id: Uuid) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_docker_file(pool: &DbPool, docker_file_id: Uuid, update_data: UpdateDockerFile, user_id: Uuid) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_docker_file(pool: &DbPool, docker_file_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/docker_file_service.rs ====

==== START OF FILE: src//services/pipeline_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::pipeline::{NewPipeline, Pipeline, UpdatePipeline};
use diesel::prelude::*;
use serde_yaml;
use uuid::Uuid;

pub struct PipelineService;

impl PipelineService {
    pub fn create_pipeline(pool: &DbPool, new_pipeline: NewPipeline) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::insert_into(pipelines)
            .values(&new_pipeline)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_pipelines(pool: &DbPool, user_id: Uuid) -> Result<Vec<Pipeline>, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        pipelines
            .filter(user_id.eq(user_id))
            .load::<Pipeline>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_pipeline(
        pool: &DbPool,
        pipeline_id: Uuid,
        user_id: Uuid,
    ) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        pipelines
            .filter(id.eq(pipeline_id).and(user_id.eq(user_id)))
            .first(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_pipeline(
        pool: &DbPool,
        pipeline_id: Uuid,
        update_data: UpdatePipeline,
        user_id: Uuid,
    ) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_pipeline(
        pool: &DbPool,
        pipeline_id: Uuid,
        user_id: Uuid,
    ) -> Result<(), AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}
==== END OF FILE: src//services/pipeline_service.rs ====

==== START OF FILE: src//services/mod.rs ====
pub mod amber_store_service;
pub mod configuration_service;
pub mod docker_file_service;
pub mod fluentcli_service;
pub mod job_service;
pub mod pipeline_service;
pub mod secure_vault_service;
pub mod user_service;
pub mod worker_service;
==== END OF FILE: src//services/mod.rs ====

==== START OF FILE: src//services/secure_vault_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::secure_vault::{SecureVault, NewSecureVault, UpdateSecureVault};
use diesel::prelude::*;
use uuid::Uuid;

pub struct SecureVaultService;

impl SecureVaultService {
    pub fn create_secure_vault(pool: &DbPool, new_secure_vault: NewSecureVault) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new secure vault into database: {:?}", new_secure_vault);
        match diesel::insert_into(secure_vaults)
            .values(&new_secure_vault)
            .get_result(conn) {
            Ok(secure_vault) => {
                log::info!("Secure vault inserted into database: {:?}", secure_vault);
                Ok(secure_vault)
            },
            Err(e) => {
                log::error!("Error inserting secure vault into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_secure_vaults(pool: &DbPool, user_id: Uuid) -> Result<Vec<SecureVault>, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Listing secure vaults for user_id: {:?}", user_id);
        secure_vaults.filter(user_id.eq(user_id))
            .load::<SecureVault>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_secure_vault(pool: &DbPool, secure_vault_id: Uuid, user_id: Uuid) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Getting secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id)))
            .first::<SecureVault>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_secure_vault(pool: &DbPool, secure_vault_id: Uuid, update_data: UpdateSecureVault, user_id: Uuid) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Updating secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        diesel::update(secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_secure_vault(pool: &DbPool, secure_vault_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Deleting secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        diesel::delete(secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map(|_| ())
            .map_err(AppError::DatabaseError)
    }
}==== END OF FILE: src//services/secure_vault_service.rs ====

==== START OF FILE: src//services/amber_store_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::amber_store::{AmberStore, NewAmberStore, UpdateAmberStore};
use diesel::{prelude::*, update};
use uuid::Uuid;

pub struct AmberStoreService;

impl AmberStoreService {
    pub fn create_amber_store(pool: &DbPool, new_amber_store: NewAmberStore) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::insert_into(amber_store)
            .values(&new_amber_store)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_amber_stores(pool: &DbPool, user_id: Uuid) -> Result<Vec<AmberStore>, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        amber_store.filter(user_id.eq(user_id)).load::<AmberStore>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_amber_store(pool: &DbPool, amber_store_id: Uuid, user_id: Uuid) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_amber_store(pool: &DbPool, amber_store_id: Uuid, update_data: UpdateAmberStore, user_id: Uuid) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_amber_store(pool: &DbPool, amber_store_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/amber_store_service.rs ====

==== START OF FILE: src//services/user_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::user::{NewUser, NewUserDB, UpdateUser, User};
use crate::utils::auth::{hash_password, verify_password};
use crate::utils::jwt;
use actix_web::HttpMessage;
use chrono::Utc;
use diesel::prelude::*;
use std::fmt::Debug;
use uuid::Uuid;

pub struct UserService;

impl UserService {
    pub fn create_user(pool: &DbPool, new_user: NewUser) -> Result<User, AppError> {
        use crate::schema::users;
        let conn = &mut pool.get()?;

        let hashed_password = hash_password(&new_user.password)?;
        let new_user_db = NewUserDB {
            username: new_user.username,
            email: new_user.email,
            password_hash: hashed_password, // Use password_hash field
        };

        diesel::insert_into(users::table)
            .values(&new_user_db) // Use new_user_db for insertion
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn login(pool: &DbPool, username: &str, password: &str) -> Result<User, AppError> {
        let user = Self::get_user_by_username(pool, username.to_string())?;
        match verify_password(password, &user.password_hash) {
            Ok(is_valid) => {
                if is_valid {
                    Ok(user)
                } else {
                    Err(AppError::AuthenticationError)
                }
            }
            Err(e) => {
                log::error!("Password verification error: {:?}", e);
                Err(AppError::InternalServerError)
            }
        }
    }

    pub fn get_user_by_username(pool: &DbPool, username_: String) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;

        let conn = &mut pool.get()?;

        users
            .filter(username.eq(username_))
            .first(conn)
            .map_err(|error| {
                if error == diesel::result::Error::NotFound {
                    AppError::NotFound
                } else {
                    AppError::DatabaseError(error)
                }
            })
    }

    pub fn get_user(pool: &DbPool, user_id: Uuid) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Received GET user request. User ID: {:?},", user_id);
        users
            .find(user_id)
            .first(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_user(
        pool: &DbPool,
        user_id: Uuid,
        update_data: UpdateUser,
    ) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(users.find(user_id))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_user(pool: &DbPool, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(users.find(user_id))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }

    pub fn email_exists(pool: &DbPool, email: &str) -> Result<bool, AppError> {
        use crate::schema::users::dsl::*;

        let conn = &mut pool.get()?;
        let count = users
            .filter(email.eq(email))
            .count()
            .get_result::<i64>(conn)?;

        Ok(count > 0)
    }

    pub fn list_users(pool: &DbPool) -> Result<Vec<User>, AppError> {
        use crate::schema::users::dsl::*; // Add this line to import users
        let conn = &mut pool.get()?;
        users.load::<User>(conn).map_err(AppError::DatabaseError)
    }

    pub fn refresh_token(pool: &DbPool, old_token: &str) -> Result<String, AppError> {
        let (user_id, _) = jwt::validate_token(old_token)?;
        jwt::generate_token(user_id)
    }
}
==== END OF FILE: src//services/user_service.rs ====

==== START OF FILE: src//services/job_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::handlers::user;
use crate::models::fluentcli::CommandRequest;
use crate::models::job::{Job, NewJob, UpdateJob};
use crate::services::fluentcli_service::FluentCLIService;
use diesel::prelude::*;
use serde_json;
use tokio;
use uuid::Uuid;

pub struct JobService;

impl JobService {
    pub fn create_job(pool: &DbPool, new_job: NewJob) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new job into database: {:?}", new_job);
        match diesel::insert_into(jobs).values(&new_job).get_result(conn) {
            Ok(job) => {
                log::info!("Job inserted into database: {:?}", job);
                Ok(job)
            }
            Err(e) => {
                log::error!("Error inserting job into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_jobs(pool: &DbPool, user_id: Uuid) -> Result<Vec<Job>, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Listing jobs for user_id: {:?}", user_id);
        jobs.filter(user_id.eq(user_id))
            .load::<Job>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!(
            "Getting job with id: {:?} for user_id: {:?}",
            job_id,
            user_id
        );
        jobs.filter(id.eq(job_id).and(user_id.eq(user_id)))
            .first::<Job>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_job(
        pool: &DbPool,
        job_id: Uuid,
        update_data: UpdateJob,
        user_id: Uuid,
    ) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!(
            "Updating job with id: {:?} for user_id: {:?}",
            job_id,
            user_id
        );
        diesel::update(jobs.filter(id.eq(job_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!(
            "Deleting job with id: {:?} for user_id: {:?}",
            job_id,
            user_id
        );
        diesel::delete(jobs.filter(id.eq(job_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map(|_| ())
            .map_err(AppError::DatabaseError)
    }

    pub fn pipeline_exists(
        pool: &DbPool,
        pipeline_id: Uuid,
        user_id: Uuid,
    ) -> Result<bool, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        let exists = diesel::select(diesel::dsl::exists(
            pipelines
                .filter(id.eq(pipeline_id))
                .filter(user_id.eq(user_id)),
        ))
        .get_result(conn)?;
        Ok(exists)
    }

    pub async fn start_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        let user_id_clone = user_id.clone();

        // Fetch the job
        let job = jobs
            .filter(id.eq(job_id).and(user_id.eq(user_id)))
            .first::<Job>(conn)?;

        // Check if the job is already running
        if job.status == "running" {
            return Err(AppError::BadRequest("Job is already running".to_string()));
        }

        // Update job status to "running"
        let updated_job = diesel::update(jobs.find(job_id))
            .set((status.eq("running"), started_at.eq(diesel::dsl::now)))
            .get_result::<Job>(conn)?;

        // Execute the job using FluentCLIService
        let command_request = CommandRequest {
            command: "openai".to_string(),
            args: vec![
                "pipeline".to_string(),
                "--file".to_string(),
                job.config.to_string(),
                "--input".to_string(),
                job.data_path.unwrap_or_default(),
                "--run-id".to_string(),
                job.id.to_string(),
                "--json-output".to_string(),
            ],
        };

        // Execute the command asynchronously
        tokio::spawn(async move {
            match FluentCLIService::execute_command(user_id_clone, command_request).await {
                Ok(result) => {
                    // Update job with results
                    let _ =
                        diesel::update(jobs.find(job_id))
                            .set((
                                status.eq("completed"),
                                completed_at.eq(diesel::dsl::now),
                                results
                                    .eq(serde_json::to_value(result)
                                        .unwrap_or(serde_json::Value::Null)),
                            ))
                            .execute(conn);
                }
                Err(e) => {
                    // Update job with error status
                    let _ = diesel::update(jobs.find(job_id))
                        .set((
                            status.eq("failed"),
                            completed_at.eq(diesel::dsl::now),
                            results.eq(serde_json::to_value(e.to_string())
                                .unwrap_or(serde_json::Value::Null)),
                        ))
                        .execute(conn);
                }
            }
        });

        Ok(updated_job)
    }

    pub async fn stop_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;

        // Fetch the job
        let job = jobs
            .filter(id.eq(job_id).and(user_id.eq(user_id)))
            .first::<Job>(conn)?;

        // Check if the job is running
        if job.status != "running" {
            return Err(AppError::BadRequest("Job is not running".to_string()));
        }

        // Update job status to "stopped"
        let updated_job = diesel::update(jobs.find(job_id))
            .set((status.eq("stopped"), completed_at.eq(diesel::dsl::now)))
            .get_result::<Job>(conn)?;

        // TODO: Implement actual job stopping mechanism (e.g., sending a signal to the running process)

        Ok(updated_job)
    }

    pub async fn get_job_status(
        pool: &DbPool,
        job_id: Uuid,
        user_id: Uuid,
    ) -> Result<String, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;

        let job_status = jobs
            .filter(id.eq(job_id).and(user_id.eq(user_id)))
            .select(status)
            .first::<String>(conn)?;

        Ok(job_status)
    }

    pub async fn get_job_output(
        pool: &DbPool,
        job_id: Uuid,
        user_id: Uuid,
    ) -> Result<Option<serde_json::Value>, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;

        let job_results = jobs
            .filter(id.eq(job_id).and(user_id.eq(user_id)))
            .select(results)
            .first::<Option<serde_json::Value>>(conn)?;

        Ok(job_results)
    }

    pub async fn get_job_logs(
        pool: &DbPool,
        job_id: Uuid,
        user_id: Uuid,
    ) -> Result<String, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;

        let job = jobs
            .filter(id.eq(job_id).and(user_id.eq(user_id)))
            .first::<Job>(conn)?;

        // TODO: Implement actual log fetching mechanism
        // For now, we'll return a placeholder message
        Ok(format!("Logs for job {} are not yet implemented", job_id))
    }
}
==== END OF FILE: src//services/job_service.rs ====

==== START OF FILE: frontend/src//App.vue ====
<template>
  <div id="app">
    <router-view></router-view>
  </div>
</template>

<script setup lang="ts">
import { onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { useStore } from 'vuex';
import AuthService from './services/AuthService';

const router = useRouter();
const store = useStore();

onMounted(async () => {
  const token = AuthService.getToken();
  if (token) {
    try {
      const user = await AuthService.validateToken(token);
      store.commit('setLoggedIn', true);
      store.commit('setUser', user);
      if (router.currentRoute.value.path === '/login') {
        router.push('/studio/dashboard');
      }
    } catch (error) {
      console.error('Token validation failed:', error);
      AuthService.removeToken();
      store.commit('setLoggedIn', false);
      store.commit('setUser', null);
      router.push('/login');
    }
  } else {
    router.push('/login');
  }
});
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: #2c3e50;
}

nav {
  padding: 30px;
}

nav a {
  font-weight: bold;
  color: #2c3e50;
}

nav a.router-link-exact-active {
  color: #42b983;
}
</style>==== END OF FILE: frontend/src//App.vue ====

==== START OF FILE: frontend/src//main.ts ====
// frontend/src/main.ts

import { createApp } from 'vue';
import App from './App.vue';
import router from './router';
import store from './store';
import AuthService from '@/services/AuthService';

const token = AuthService.getToken();
if (token) {
  AuthService.setToken(token);
  store.commit('setLoggedIn', true);
  // Optionally fetch user data here
}

createApp(App).use(router).use(store).mount('#app');==== END OF FILE: frontend/src//main.ts ====

==== START OF FILE: frontend/src//extensions/tiptap.d.ts ====
import '@tiptap/core';

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    /**
     * Insert a Data Pill with the given value
     */
    insertDataPill: (value: string) => ReturnType;
  }
}

export {};==== END OF FILE: frontend/src//extensions/tiptap.d.ts ====

==== START OF FILE: frontend/src//extensions/DataPill.ts ====
// src/extensions/DataPill.ts

import { Node, mergeAttributes } from '@tiptap/core'

export interface DataPillOptions {
  HTMLAttributes: Record<string, any>
}

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    dataPill: {
      insertDataPill: (value: string) => ReturnType
    }
  }
}

export const DataPill = Node.create<DataPillOptions>({
  name: 'dataPill',

  group: 'inline',

  inline: true,

  atom: true,

  addOptions() {
    return {
      HTMLAttributes: {},
    }
  },

  addAttributes() {
    return {
      value: {
        default: null,
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'span[data-type="data-pill"]',
      },
    ]
  },

  renderHTML({ node, HTMLAttributes }) {
    return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': 'data-pill' }), node.attrs.value]
  },

  addCommands() {
    return {
      insertDataPill: (value: string) => ({ chain }) => {
        return chain()
          .insertContent({
            type: this.name,
            attrs: { value },
          })
          .run()
      },
    }
  },
})==== END OF FILE: frontend/src//extensions/DataPill.ts ====

==== START OF FILE: frontend/src//components/studio/editors/AmberStoreEditor.vue ====
<template>
  <div class="amber-store-editor">
    <h3>{{ isNew ? 'Create' : 'Edit' }} Amber Store</h3>
    <form @submit.prevent="handleSubmit">
      <div class="form-group">
        <label for="name">Name:</label>
        <input id="name" v-model="editedAmberStore.name" required>
      </div>
      <div class="form-group">
        <label for="data">Data (YAML):</label>
        <textarea id="data" v-model="yamlData" rows="10" required @input="validateYaml"></textarea>
      </div>
      <div class="form-group">
        <label for="secure_key_hash">Secure Key Hash:</label>
        <input id="secure_key_hash" v-model="editedAmberStore.secure_key_hash" required>
      </div>
      <div v-if="yamlError" class="error">
        {{ yamlError }}
      </div>
      <div class="form-actions">
        <button type="submit" :disabled="!!yamlError" class="save-button">Save</button>
        <button type="button" @click="$emit('cancel')" class="cancel-button">Cancel</button>
      </div>
    </form>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue';
import * as yaml from 'js-yaml';

interface AmberStore {
  id?: string;
  name: string;
  data: string;
  secure_key_hash: string;
}

const props = defineProps<{
  data: AmberStore;
}>();

const emit = defineEmits<{
  (e: 'save', amberStore: AmberStore): void;
  (e: 'cancel'): void;
}>();

const editedAmberStore = ref<AmberStore>({ ...props.data });
const yamlData = ref(yaml.dump(yaml.load(props.data.data) || {}, { indent: 2 }));
const yamlError = ref('');

const isNew = computed(() => !props.data.id);

watch(() => props.data, (newData) => {
  editedAmberStore.value = { ...newData };
  yamlData.value = yaml.dump(yaml.load(newData.data) || {}, { indent: 2 });
}, { deep: true });

function validateYaml() {
  try {
    yaml.load(yamlData.value);
    yamlError.value = '';
  } catch (error) {
    if (error instanceof Error) {
      yamlError.value = `Invalid YAML: ${error.message}`;
    } else {
      yamlError.value = 'Invalid YAML';
    }
  }
}

const handleSubmit = () => {
  if (!yamlError.value) {
    editedAmberStore.value.data = yamlData.value;
    emit('save', editedAmberStore.value);
  }
};
</script>

<style scoped>
.amber-store-editor {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.amber-store-editor h3 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 1.5rem;
}

.form-group {
  margin-bottom: 20px;
}

label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

input[type="text"], textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 1rem;
}

textarea {
  resize: vertical;
  min-height: 300px;
}

.error {
  color: #e74c3c;
  margin-bottom: 10px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
}

.save-button, .cancel-button {
  padding: 10px 20px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.save-button {
  background-color: #2ecc71;
  color: #fff;
  margin-right: 10px;
}

.save-button:hover:not(:disabled) {
  background-color: #27ae60;
}

.save-button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.cancel-button {
  background-color: #e74c3c;
  color: #fff;
}

.cancel-button:hover {
  background-color: #c0392b;
}
</style>==== END OF FILE: frontend/src//components/studio/editors/AmberStoreEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/PipelineEditor.vue ====
<template>
  <div class="pipeline-editor">
    <h3>{{ isNew ? 'Create' : 'Edit' }} Pipeline</h3>
    <form @submit.prevent="handleSubmit">
      <div class="form-group">
        <label for="name">Name:</label>
        <input id="name" v-model="editedPipeline.name" required>
      </div>
      <div class="form-group">
        <label for="data">Data (YAML):</label>
        <textarea id="data" v-model="yamlData" rows="10" required @input="validateYaml"></textarea>
      </div>
      <div v-if="yamlError" class="error">
        {{ yamlError }}
      </div>
      <div class="form-actions">
        <button type="submit" :disabled="!!yamlError" class="save-button">Save</button>
        <button type="button" @click="$emit('cancel')" class="cancel-button">Cancel</button>
      </div>
    </form>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue';
import * as yaml from 'js-yaml';

interface Pipeline {
  id: string;
  name: string;
  data: string;
}

const props = defineProps<{
  data: Pipeline;
}>();

const emit = defineEmits<{
  (e: 'save', pipeline: Pipeline): void;
  (e: 'cancel'): void;
}>();

// Create a custom type to handle all tags
const customTags = ['!Command', '!ShellCommand', '!Condition', '!Loop', '!Map', '!SubPipeline', '!HumanInTheLoop', '!RepeatUntil', '!PrintOutput', '!ForEach', '!TryCatch', '!Parallel', '!Timeout'];

const CUSTOM_SCHEMA = new yaml.Schema({
  include: [yaml.DEFAULT_SCHEMA],
  explicit: customTags.map(tag => new yaml.Type(tag, {
    kind: 'mapping',
  }))
} as yaml.SchemaDefinition);


function customStringify(obj: any): string {
  if (typeof obj === 'object' && obj !== null) {
    const key = Object.keys(obj)[0];
    if (customTags.includes(`!${key}`)) {
      return `!${key}\n${yaml.dump(obj[key], { schema: CUSTOM_SCHEMA, indent: 2 }).trim()}`;
    }
  }
  return yaml.dump(obj, { schema: CUSTOM_SCHEMA, indent: 2 }).trim();
}

function formatYaml(data: string): string {
  try {
    const parsedData = yaml.load(data, { schema: CUSTOM_SCHEMA }) as any;
    return customStringify(parsedData);
  } catch (error) {
    console.error('Error formatting YAML:', error);
    return data;
  }
}

const editedPipeline = ref<Pipeline>({ ...props.data });
const yamlData = ref(formatYaml(props.data.data));
const yamlError = ref('');

const isNew = computed(() => !props.data.id);

watch(() => props.data, (newData) => {
  console.log('New data received:', newData);
  editedPipeline.value = { ...newData };
  yamlData.value = formatYaml(newData.data);
}, { deep: true });

function validateYaml() {
  try {
    yaml.load(yamlData.value, { 
      schema: CUSTOM_SCHEMA,
    });
    yamlError.value = '';
  } catch (error) {
    if (error instanceof Error) {
      yamlError.value = `Invalid YAML: ${error.message}`;
    } else {
      yamlError.value = 'Invalid YAML';
    }
  }
}

const handleSubmit = () => {
  console.log('Handling submit');
  if (!yamlError.value) {
    editedPipeline.value.data = yamlData.value;
    const parsedData = yaml.load(yamlData.value, { schema: CUSTOM_SCHEMA });
    editedPipeline.value.data = JSON.stringify(parsedData);
    console.log('Emitting save with:', editedPipeline.value);
    emit('save', editedPipeline.value);
  } else {
    console.error('Cannot submit due to YAML error:', yamlError.value);
  }
};
</script>

<style scoped>
.pipeline-editor  {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.pipeline-editor  h3 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 1.5rem;
}

.form-group {
  margin-bottom: 20px;
}

label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

input[type="text"], textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 1rem;
}

textarea {
  resize: vertical;
}

.error {
  color: #e74c3c;
  margin-bottom: 10px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
}

.save-button, .cancel-button {
  padding: 10px 20px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.save-button {
  background-color: #2ecc71;
  color: #fff;
  margin-right: 10px;
}

.save-button:hover:not(:disabled) {
  background-color: #27ae60;
}

.save-button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.cancel-button {
  background-color: #e74c3c;
  color: #fff;
}

.cancel-button:hover {
  background-color: #c0392b;
}
</style>==== END OF FILE: frontend/src//components/studio/editors/PipelineEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/DockerFileEditor.vue ====
<template>
    <div class="docker-file-editor">
      <h3>{{ isNew ? 'Create' : 'Edit' }} Docker File</h3>
      <form @submit.prevent="handleSubmit">
        <div>
          <label for="name">Name:</label>
          <input type="text" id="name" v-model="editedDockerFile.name" required>
        </div>
        <div>
          <label for="content">Content:</label>
          <textarea id="content" v-model="editedDockerFile.content" rows="10" required></textarea>
        </div>
        <div>
        <button type="submit" class="save-button">Save</button>
        <button type="button" @click="$emit('cancel')" class="cancel-button">Cancel</button>
        </div>
      </form>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed } from 'vue';
  
  interface DockerFile {
    id?: string;
    name: string;
    content: string;
  }
  
  const props = defineProps<{
    dockerFile: DockerFile | null;
  }>();
  
  const emit = defineEmits<{
    (e: 'save', dockerFile: DockerFile): void;
    (e: 'cancel'): void;
  }>();
  
  const editedDockerFile = ref<DockerFile>({
    id: props.dockerFile?.id,
    name: props.dockerFile?.name || '',
    content: props.dockerFile?.content || '',
  });
  
  const isNew = computed(() => !props.dockerFile?.id);
  
  const handleSubmit = () => {
    emit('save', editedDockerFile.value);
  };
  </script>
  
<<style scoped>

.docker-file-editor {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.docker-file-editor h3 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 1.5rem;
}

.form-group {
  margin-bottom: 20px;
}

label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

input[type="text"], textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 1rem;
}

textarea {
  resize: vertical;
  min-height: 300px;
}

.error {
  color: #e74c3c;
  margin-bottom: 10px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
}

.save-button, .cancel-button {
  padding: 10px 20px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.save-button {
  background-color: #2ecc71;
  color: #fff;
  margin-right: 10px;
}

.save-button:hover:not(:disabled) {
  background-color: #27ae60;
}

.save-button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.cancel-button {
  background-color: #e74c3c;
  color: #fff;
}

.cancel-button:hover {
  background-color: #c0392b;
}
</style>==== END OF FILE: frontend/src//components/studio/editors/DockerFileEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/JobEditor.vue ====
<template>
  <div class="job-editor">
    <h3>{{ isNew ? 'Create' : 'Edit' }} Job</h3>
    <form @submit.prevent="handleSubmit">
      <div>
        <label for="worker_type">Worker Type:</label>
        <select id="worker_type" v-model="editedJob.worker_type" required>
          <option v-for="dockerFile in dockerFiles" :key="dockerFile.id" :value="dockerFile.id">
            {{ dockerFile.name }}
          </option>
        </select>
        <router-link to="/studio/dockerfiles">Manage Docker Files</router-link>
      </div>
      <div>
        <label for="config">Configuration:</label>
        <select id="config" v-model="editedJob.config" required>
          <option v-for="config in configurations" :key="config.id" :value="config.id">
            {{ config.name }}
          </option>
        </select>
        <router-link to="/studio/configurations">Manage Configurations</router-link>
      </div>
      <div>
        <label for="pipeline">Pipeline:</label>
        <select id="pipeline" v-model="editedJob.pipeline_id" required>
          <option v-for="pipeline in pipelines" :key="pipeline.id" :value="pipeline.id">
            {{ pipeline.name }}
          </option>
        </select>
        <router-link to="/studio/pipelines">Manage Pipelines</router-link>
      </div>
      <div>
        <label for="amber_store">Amber Store:</label>
        <select id="amber_store" v-model="editedJob.amber_id">
          <option :value="null">None</option>
          <option v-for="amberStore in amberStores" :key="amberStore.id" :value="amberStore.id">
            {{ amberStore.name }}
          </option>
        </select>
        <router-link to="/studio/amberstores">Manage Amber Stores</router-link>
      </div>
      <div>
        <label for="state_file_content">State File Content:</label>
        <textarea id="state_file_content" v-model="editedJob.state_file_content"></textarea>
      </div>
      <div>
        <label for="data_path">Data Path:</label>
        <input id="data_path" v-model="editedJob.data_path" />
      </div>
      <div>
        <label for="status">Status:</label>
        <input id="status" v-model="editedJob.status" required />
      </div>
      <div>
        <button type="submit" class="save-button">Save</button>
        <button type="button" @click="$emit('cancel')" class="cancel-button">Cancel</button>
      </div>
    </form>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue';

interface Job {
  id?: string;
  config: string;
  amber_id?: string | null;
  state_file_content?: string;
  data_path?: string;
  worker_type: string;
  triggers?: any;
  timers?: any;
  status: string;
  pipeline_id: string;
  results?: any;
}

const props = defineProps<{
  job: Job | null;
  dockerFiles: { id: string; name: string }[];
  configurations: { id: string; name: string }[];
  pipelines: { id: string; name: string }[];
  amberStores: { id: string; name: string }[];
}>();

const emit = defineEmits<{
  (e: 'save', job: Job): void;
  (e: 'cancel'): void;
}>();

const editedJob = ref<Job>(props.job ? { ...props.job } : {
  config: '',
  worker_type: '',
  status: '',
  pipeline_id: '',
} as Job);

const isNew = computed(() => !props.job?.id);


watch(() => props.job, (newJob) => {
  if (newJob) {
    editedJob.value = { ...newJob };
  }
}, { deep: true });

const handleSubmit = () => {
  emit('save', editedJob.value);
};
</script>

<style scoped>
.job-editor  {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

form > div {
  margin-bottom: 1rem;
}

label {
  display: block;
  margin-bottom: 0.5rem;
}

input, select, textarea {
  width: 100%;
  padding: 0.5rem;
}

.save-button, .cancel-button {
  padding: 10px 20px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.save-button {
  background-color: #2ecc71;
  color: #fff;
  margin-right: 10px;
}

.save-button:hover:not(:disabled) {
  background-color: #27ae60;
}

.save-button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.cancel-button {
  background-color: #e74c3c;
  color: #fff;
}

.cancel-button:hover {
  background-color: #c0392b;
}
</style>==== END OF FILE: frontend/src//components/studio/editors/JobEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/ConfigurationEditor.vue ====
<template>
  <div class="configuration-editor">
    <h3>{{ isNew ? 'Create' : 'Edit' }} Configuration</h3>
    <form @submit.prevent="handleSubmit">
      <div class="form-group">
        <label for="name">Name:</label>
        <input type="text" id="name" v-model="editedConfiguration.name" required>
      </div>
      <div class="form-group">
        <label for="data">Data (JSON):</label>
        <textarea id="data" v-model="jsonData" rows="10" required></textarea>
      </div>
      <div class="form-actions">
        <button type="submit" class="save-button">Save</button>
        <button type="button" @click="$emit('cancel')" class="cancel-button">Cancel</button>
      </div>
    </form>
  </div>
</template>
  
  <script setup lang="ts">
  import { ref, computed, watch } from 'vue';
  
  interface Configuration {
    id?: string;
    name: string;
    data: any;
  }
  
  const props = defineProps<{
    data: Configuration;
  }>();
  
  const emit = defineEmits<{
    (e: 'save', configuration: Configuration): void;
    (e: 'cancel'): void;
  }>();
  
  const editedConfiguration = ref<Configuration>({ ...props.data });
  const jsonData = ref(JSON.stringify(props.data.data, null, 2));
  
  const isNew = computed(() => !props.data.id);
  
  watch(() => props.data, (newData) => {
    editedConfiguration.value = { ...newData };
    jsonData.value = JSON.stringify(newData.data, null, 2);
  }, { deep: true });
  
  const handleSubmit = () => {
    try {
      editedConfiguration.value.data = JSON.parse(jsonData.value);
      emit('save', editedConfiguration.value);
    } catch (error) {
      alert('Invalid JSON data. Please check your input.');
    }
  };
  </script>
  
<style scoped>
.form-group {
  margin-bottom: 20px;
}

label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

input[type="text"], textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 1rem;
}

textarea {
  resize: vertical;
  min-height: 300px;
}

.error {
  color: #e74c3c;
  margin-bottom: 10px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
}

.save-button, .cancel-button {
  padding: 10px 20px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.save-button {
  background-color: #2ecc71;
  color: #fff;
  margin-right: 10px;
}

.save-button:hover:not(:disabled) {
  background-color: #27ae60;
}

.save-button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.cancel-button {
  background-color: #e74c3c;
  color: #fff;
}

.cancel-button:hover {
  background-color: #c0392b;
}


.configuration-editor {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.configuration-editor h3 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 1.5rem;
}

.form-group {
  margin-bottom: 20px;
}

label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

input[type="text"], textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 1rem;
}

textarea {
  resize: vertical;
  min-height: 300px;
}

.error {
  color: #e74c3c;
  margin-bottom: 10px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
}

.save-button, .cancel-button {
  padding: 10px 20px;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.save-button {
  background-color: #2ecc71;
  color: #fff;
  margin-right: 10px;
}

.save-button:hover:not(:disabled) {
  background-color: #27ae60;
}

.save-button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.cancel-button {
  background-color: #e74c3c;
  color: #fff;
}

.cancel-button:hover {
  background-color: #c0392b;
}
</style>==== END OF FILE: frontend/src//components/studio/editors/ConfigurationEditor.vue ====

==== START OF FILE: frontend/src//components/studio/JobList.vue ====
<template>
  <div class="job-list">
    <h2>Job List</h2>
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>URI</th>
          <th>Worker Type</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="job in jobs" :key="job.id">
          <td>{{ job.id }}</td>
          <td>{{ job.uri }}</td>
          <td>{{ job.worker_type }}</td>
          <td>
            <router-link :to="`/admin/jobs/${job.id}`">View</router-link> |
            <router-link :to="`/admin/jobs/${job.id}/edit`">Edit</router-link> |
            <button @click="deleteJob(job.id)" class="delete-button">Delete</button>
          </td>
        </tr>
      </tbody>
    </table>
    <p v-if="jobs.length === 0">No jobs available.</p>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted } from 'vue';
import axios from 'axios';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

export default defineComponent({
  name: 'JobList',
  setup() {
    const jobs = ref<Job[]>([]);
    const isLoading = ref(true);
    const errorMessage = ref('');

    const fetchJobs = async () => {
      try {
        const response = await axios.get('/jobs'); // Adjust the endpoint as needed
        jobs.value = response.data;
      } catch (error) {
        console.error('Failed to fetch jobs:', error);
        errorMessage.value = 'Failed to load jobs.';
      } finally {
        isLoading.value = false;
      }
    };

    const deleteJob = async (id: number) => {
      if (!confirm('Are you sure you want to delete this job?')) return;
      try {
        await axios.delete(`/api/jobs/${id}`); // Adjust the endpoint as needed
        jobs.value = jobs.value.filter(job => job.id !== id);
      } catch (error) {
        console.error('Failed to delete job:', error);
        alert('Failed to delete the job. Please try again.');
      }
    };

    onMounted(() => {
      fetchJobs();
    });

    return {
      jobs,
      isLoading,
      errorMessage,
      deleteJob,
    };
  },
});
</script>

<style scoped>
.job-list {
  padding: 20px;
}

.job-list table {
  width: 100%;
  border-collapse: collapse;
}

.job-list th,
.job-list td {
  border: 1px solid #ddd;
  padding: 8px;
}

.job-list th {
  background-color: #f2f2f2;
  text-align: left;
}

.delete-button {
  background-color: #c0392b;
  color: #fff;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
}

.delete-button:hover {
  background-color: #e74c3c;
}

button {
  background: none;
  border: none;
  color: #2980b9;
  cursor: pointer;
}

button:hover {
  text-decoration: underline;
}

p {
  margin-top: 20px;
  color: #7f8c8d;
}
</style>==== END OF FILE: frontend/src//components/studio/JobList.vue ====

==== START OF FILE: frontend/src//components/studio/StudioWorkspace.vue ====
<template>
    <div class="studio-workspace">
      <component
        :is="activeComponent"
        v-if="activeComponent"
        :key="activeTabId"
        :data="activeTabData"
      />
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, computed } from 'vue';
  import { useStore } from 'vuex';
  import ConfigurationEditor from '@/components/studio/editors/ConfigurationEditor.vue';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  import DockerFileEditor from '@/components/studio/editors/DockerFileEditor.vue';
  
  export default defineComponent({
    name: 'StudioWorkspace',
    components: {
      ConfigurationEditor,
      PipelineEditor,
      DockerFileEditor,
    },
    setup() {
      const store = useStore();
  
      const activeTabId = computed(() => store.state.studio.activeTabId);
      const activeTab = computed(() => store.getters['studio/activeTab']);
  
      const activeComponent = computed(() => {
        if (!activeTab.value) return null;
        switch (activeTab.value.type) {
          case 'configuration':
            return 'ConfigurationEditor';
          case 'pipeline':
            return 'PipelineEditor';
          case 'dockerFile':
            return 'DockerFileEditor';
          default:
            return null;
        }
      });
  
      const activeTabData = computed(() => activeTab.value?.data || {});
  
      return {
        activeTabId,
        activeComponent,
        activeTabData,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio-workspace {
    flex-grow: 1;
    padding: 1rem;
    overflow-y: auto;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioWorkspace.vue ====

==== START OF FILE: frontend/src//components/studio/StudioSidebar.vue ====
<template>
    <div :class="['sidebar', { collapsed: isCollapsed }]">
      <div class="toggle-button" @click="$emit('toggle')">
        <span v-if="!isCollapsed">«</span>
        <span v-else>»</span>
      </div>
      <nav>
        <ul>
          <li>
            <router-link to="/studio/dashboard">Dashboard</router-link>
          </li>
          <li>
            <router-link to="/studio/jobs">Jobs</router-link>
          </li>
          <li>
            <router-link to="/studio/pipelines">Pipelines</router-link>
          </li>
          <li>
            <router-link to="/studio/dockerfiles">Docker Files</router-link>
          </li>
          <li>
            <router-link to="/studio/settings">Settings</router-link>
          </li>
        </ul>
      </nav>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'StudioSidebar',
    props: {
      isCollapsed: {
        type: Boolean,
        required: true,
      },
    },
  });
  </script>
  
  <style scoped>
  .sidebar {
    width: 250px;
    background-color: #2c3e50;
    color: #ecf0f1;
    transition: width 0.3s;
    position: relative;
  }
  
  .sidebar.collapsed {
    width: 80px;
  }
  
  .toggle-button {
    position: absolute;
    top: 10px;
    right: -15px;
    background-color: #34495e;
    border-radius: 50%;
    padding: 5px;
    cursor: pointer;
  }
  
  nav ul {
    list-style: none;
    padding: 0;
    margin-top: 50px;
  }
  
  nav ul li {
    padding: 15px 20px;
  }
  
  nav ul li a {
    color: #ecf0f1;
    text-decoration: none;
    display: block;
  }
  
  nav ul li a.router-link-exact-active {
    background-color: #1abc9c;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioSidebar.vue ====

==== START OF FILE: frontend/src//components/studio/StudioHeader.vue ====
<template>
    <header class="studio-header">
      <button class="menu-button" @click="$emit('toggleSidebar')">☰</button>
      <div class="user-info">
        <span>Welcome, {{ userName }}</span>
        <button @click="logout">Logout</button>
      </div>
    </header>
  </template>
  
<script setup lang="ts">
import { computed } from 'vue';
import { useStore } from 'vuex';
import { useRouter } from 'vue-router';
import AuthService from '@/services/AuthService';

const store = useStore();
const router = useRouter();

const userName = computed(() => {
  const user = store.state.user;
  return user ? user.name || user.username : 'Guest';
});

const logout = () => {
  AuthService.logout();
  store.commit('setLoggedIn', false);
  store.commit('setUser', null);
  router.push('/');
};
</script>
  
  <style scoped>
  .studio-header {
    height: 60px;
    background-color: #ecf0f1;
    display: flex;
    align-items: center;
    padding: 0 20px;
    justify-content: space-between;
    border-bottom: 1px solid #bdc3c7;
  }
  
  .menu-button {
    font-size: 24px;
    background: none;
    border: none;
    cursor: pointer;
  }
  
  .user-info {
    display: flex;
    align-items: center;
  }
  
  .user-info span {
    margin-right: 15px;
  }
  
  .user-info button {
    padding: 5px 10px;
    cursor: pointer;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioHeader.vue ====

==== START OF FILE: frontend/src//components/studio/PipelineList.vue ====
<!-- frontend/src/components/studio/PipelineList.vue -->
<template>
    <div class="pipeline-list">
      <h2>Pipeline List</h2>
      <router-link to="/studio/pipelines/create" class="create-button">Create New Pipeline</router-link>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Description</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="pipeline in pipelines" :key="pipeline.id">
            <td>{{ pipeline.id }}</td>
            <td>{{ pipeline.name }}</td>
            <td>{{ pipeline.description }}</td>
            <td>
              <router-link :to="`/studio/pipelines/${pipeline.id}`">View</router-link> |
              <router-link :to="`/studio/pipelines/${pipeline.id}/edit`">Edit</router-link> |
              <button @click="deletePipeline(pipeline.id)" class="delete-button">Delete</button>
            </td>
          </tr>
        </tbody>
      </table>
      <p v-if="pipelines.length === 0">No pipelines available.</p>
      <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
      <p v-if="isLoading" class="loading">Loading pipelines...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    id: number;
    name: string;
    description: string;
    // ... other properties
  }
  
  const pipelines = ref<Pipeline[]>([]);
  const isLoading = ref(true);
  const errorMessage = ref('');
  
  const fetchPipelines = async () => {
    try {
      const response = await apiClient.get('/pipelines');
      pipelines.value = response.data;
    } catch (error: any) {
      errorMessage.value = error.response?.data?.message || 'Failed to load pipelines.';
    } finally {
      isLoading.value = false;
    }
  };
  
  const deletePipeline = async (id: number) => {
    if (!confirm('Are you sure you want to delete this pipeline?')) return;
    try {
      await apiClient.delete(`/pipelines/${id}`);
      pipelines.value = pipelines.value.filter(pipeline => pipeline.id !== id);
    } catch (error: any) {
      alert('Failed to delete the pipeline. Please try again.');
    }
  };
  
  onMounted(() => {
    fetchPipelines();
  });
  </script>
  
  <style scoped>
  .pipeline-list {
    padding: 20px;
  }
  .pipeline-list .create-button {
    display: inline-block;
    margin-bottom: 15px;
  }
  .pipeline-list table {
    width: 100%;
    border-collapse: collapse;
  }
  .pipeline-list th,
  .pipeline-list td {
    border: 1px solid #ddd;
    padding: 8px;
  }
  .pipeline-list th {
    background-color: #f2f2f2;
    text-align: left;
  }
  .delete-button {
    background-color: #c0392b;
    color: #fff;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
  }
  .delete-button:hover {
    background-color: #e74c3c;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//components/studio/PipelineList.vue ====

==== START OF FILE: frontend/src//components/LoginLogout.vue ====
<template>
    <button @click="toggleLogin">{{ buttonText }}</button>
  </template>
  
  <script lang="ts">
  import { computed, defineComponent } from 'vue'
  import { useStore } from 'vuex'
  
  export default defineComponent({
    setup() {
      const store = useStore()
  
      const isLoggedIn = computed(() => store.getters.isLoggedIn)
      const buttonText = computed(() => isLoggedIn.value ? 'Logout' : 'Login')
  
      const toggleLogin = async () => {
        if (isLoggedIn.value) {
          await store.dispatch('logout')
        } else {
          // For simplicity, we're not handling the login form here.
          // You might want to show a login modal or navigate to a login page.
          console.log('Show login form')
        }
      }
  
      return {
        buttonText,
        toggleLogin
      }
    }
  })
  </script>==== END OF FILE: frontend/src//components/LoginLogout.vue ====

==== START OF FILE: frontend/src//components/Greet.vue ====
<script setup lang="ts">
import { ref } from "vue";
import { invoke } from "@tauri-apps/api/tauri";

const greetMsg = ref("");
const name = ref("");

async function greet() {
  greetMsg.value = await invoke("greet", { name: name.value });
}
</script>

<template>
  <form class="row" @submit.prevent="greet">
    <input id="greet-input" v-model="name" placeholder="Enter a name..." />
    <button type="submit">Greet</button>
  </form>

  <p>{{ greetMsg }}</p>
</template>==== END OF FILE: frontend/src//components/Greet.vue ====

==== START OF FILE: frontend/src//components/common/TreeView.vue ====
<template>
    <ul class="tree-view">
      <li v-for="item in items" :key="item.name">
        <div @click="toggleItem(item)">
          <span v-if="item.children && item.children.length">
            {{ item.expanded ? '▼' : '▶' }}
          </span>
          <span @click="$emit('item-click', item)">{{ item.name }}</span>
        </div>
        <TreeView
          v-if="item.children && item.children.length && item.expanded"
          :items="item.children"
          @item-click="$emit('item-click', $event)"
        />
      </li>
    </ul>
  </template>
  
  <script lang="ts">
  import { defineComponent, PropType } from 'vue';
  
  interface TreeItem {
    name: string;
    children?: TreeItem[];
    expanded?: boolean;
  }
  
  export default defineComponent({
    name: 'TreeView',
    props: {
      items: {
        type: Array as PropType<TreeItem[]>,
        required: true,
      },
    },
    emits: ['item-click'],
    methods: {
      toggleItem(item: TreeItem) {
        if (item.children && item.children.length) {
          item.expanded = !item.expanded;
        }
      },
    },
  });
  </script>
  
  <style scoped>
  .tree-view {
    list-style-type: none;
    padding-left: 1rem;
  }
  .tree-view li {
    cursor: pointer;
  }
  </style>==== END OF FILE: frontend/src//components/common/TreeView.vue ====

==== START OF FILE: frontend/src//components/JsonEditorWithPills.vue ====
<!-- JsonEditorWithPills.vue -->
<template>
    <div class="json-editor-with-pills">
      <MonacoEditor
        v-model="code"
        language="json"
        :options="editorOptions"
        @editorMounted="onEditorMounted"
      />
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref, watch } from 'vue';

  import * as MonacoEditor from 'monaco-editor';



  export default defineComponent({
    name: 'JsonEditorWithPills',
    components: { MonacoEditor },
    props: {
      modelValue: {
        type: String,
        required: true,
      },
    },
    emits: ['update:modelValue'],
    setup(props, { emit }) {
      const code = ref(props.modelValue);
  
      const editorOptions = {
        automaticLayout: true,
        // Additional editor options
      };
  
      const onEditorMounted = () => {
        // Implement data pills functionality here
        // e.g., custom syntax highlighting, hover tips, or decorations
      };
  
      watch(code, (newValue) => {
        emit('update:modelValue', newValue);
      });
  
      return {
        code,
        editorOptions,
        onEditorMounted,
      };
    },
  });
  </script>
  
  <style scoped>
  .json-editor-with-pills {
    height: 400px; /* Adjust as needed */
  }
  </style>==== END OF FILE: frontend/src//components/JsonEditorWithPills.vue ====

==== START OF FILE: frontend/src//vite-env.d.ts ====
/// <reference types="vite/client" />

declare module "*.vue" {
  import type { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
==== END OF FILE: frontend/src//vite-env.d.ts ====

==== START OF FILE: frontend/src//config.ts ====
export const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';==== END OF FILE: frontend/src//config.ts ====

==== START OF FILE: frontend/src//views/studio/Settings.vue ====
<template>
    <div class="settings">
      <h1>Settings</h1>
      <p>Manage your Studio settings here.</p>
      <!-- Add settings forms and options here -->
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Settings',
  });
  </script>
  
  <style scoped>
  .settings {
    padding: 20px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Settings.vue ====

==== START OF FILE: frontend/src//views/studio/Dashboard.vue ====
<template>
    <div class="dashboard">
      <h1>Studio Dashboard</h1>
      <p>Welcome to the Studio Dashboard!</p>
      <!-- Add more dashboard widgets and information here -->
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Dashboard',
  });
  </script>
  
  <style scoped>
  .dashboard {
    padding: 20px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Dashboard.vue ====

==== START OF FILE: frontend/src//views/studio/DockerFileEditor.vue ====
<!-- frontend/src/views/studio/DockerFileEdit.vue -->
<template>
  <div class="docker-file-edit">
    <h1>{{ isNew ? 'Create' : 'Edit' }} Docker File</h1>
    <div v-if="dockerFile" class="editor-container">
      <DockerFileEditor
        :dockerFile="dockerFile"
        @save="updateDockerFile"
        @cancel="cancelEdit"
      />
    </div>
    <div v-else class="loading-container">
      <p>Loading Docker file details...</p>
    </div>
    <p v-if="isLoading" class="loading">{{ isNew ? 'Creating' : 'Updating' }} Docker file...</p>
    <p v-if="error" class="error">{{ error }}</p>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import DockerFileEditor from '@/components/studio/editors/DockerFileEditor.vue';
import apiClient from '@/services/apiClient';

interface DockerFile {
  id?: string;
  name: string;
  content: string;
}

const route = useRoute();
const router = useRouter();
const dockerFile = ref<DockerFile | null>(null);
const isLoading = ref(false);
const error = ref<string | null>(null);

const isNew = computed(() => route.params.id === 'new');

const fetchDockerFile = async () => {
  if (isNew.value) {
    dockerFile.value = { name: '', content: '' };
    return;
  }

  try {
    const response = await apiClient.get(`/docker_files/${route.params.id}`);
    dockerFile.value = response.data;
  } catch (err: any) {
    console.error('Failed to load Docker file details:', err);
    error.value = 'Failed to load Docker file. Please try again.';
  }
};

const updateDockerFile = async (updatedDockerFile: DockerFile) => {
  isLoading.value = true;
  error.value = null;
  try {
    if (isNew.value) {
      await apiClient.post('/docker_files', updatedDockerFile);
    } else {
      await apiClient.put(`/docker_files/${dockerFile.value?.id}`, updatedDockerFile);
    }
    router.push('/studio/dockerfiles');
  } catch (err: any) {
    console.error('Failed to update Docker file:', err);
    error.value = `Failed to ${isNew.value ? 'create' : 'update'} the Docker file. Please try again.`;
  } finally {
    isLoading.value = false;
  }
};

const cancelEdit = () => {
  router.push('/studio/dockerfiles');
};

onMounted(() => {
  fetchDockerFile();
});
</script>

<style scoped>
.docker-file-edit {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
}

h1 {
  font-size: 2rem;
  margin-bottom: 20px;
  color: #2c3e50;
}

.editor-container {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.loading-container {
  text-align: center;
  padding: 20px;
  background-color: #f8f9fa;
  border-radius: 5px;
}

.loading, .error {
  margin-top: 15px;
  padding: 10px;
  border-radius: 5px;
  text-align: center;
}

.loading {
  background-color: #e1f5fe;
  color: #0288d1;
}

.error {
  background-color: #ffebee;
  color: #c62828;
}
</style>==== END OF FILE: frontend/src//views/studio/DockerFileEditor.vue ====

==== START OF FILE: frontend/src//views/studio/Jobs.vue ====
<template>
  <div class="jobs">
    <div class="jobs-header">
      <h2>Jobs</h2>
      <button @click="showEditor = true" class="add-button">Create New Job</button>
    </div>
    
    <div v-if="jobs.length" class="job-grid">
      <div v-for="job in jobs" :key="job.id" class="job-card">
        <h3>Job ID: {{ job.id }}</h3>
        <p>Worker Type: {{ getDockerFileName(job.worker_type) }}</p>
        <p>Configuration: {{ getConfigurationName(job.config) }}</p>
        <p>Pipeline: {{ getPipelineName(job.pipeline_id) }}</p>
        <p>Amber Store: {{ getAmberStoreName(job.amber_id) }}</p>
        <p>Status: {{ job.status }}</p>
        <div class="job-actions">
          <button @click="editJob(job)" class="edit-button">Edit</button>
          <button @click="deleteJob(job.id!)" class="delete-button">Delete</button>
          <button @click="startJob(job.id!)" class="start-button">Start</button>
          <button @click="stopJob(job.id!)" class="stop-button">Stop</button>
        </div>
      </div>
    </div>
    <p v-else class="no-jobs">No jobs available.</p>
    <p v-if="error" class="error">{{ error }}</p>
    <p v-if="isLoading" class="loading">Loading...</p>

    <div v-if="showEditor" class="modal">
      <div class="modal-content">
        <JobEditor
          :job="selectedJob"
          :dockerFiles="dockerFiles"
          :configurations="configurations"
          :pipelines="pipelines"
          :amberStores="amberStores"
          @save="handleSave"
          @cancel="showEditor = false"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import JobEditor from '@/components/studio/editors/JobEditor.vue';
import apiClient from '@/services/apiClient';

interface Job {
  id?: string;
  config: string;
  amber_id?: string | null;
  state_file_content?: string;
  data_path?: string;
  worker_type: string;
  triggers?: any;
  timers?: any;
  status: string;
  pipeline_id: string;
  results?: any;
}

const jobs = ref<Job[]>([]);
const showEditor = ref(false);
const selectedJob = ref<Job | null>(null);
const error = ref<string | null>(null);
const isLoading = ref(false);

const dockerFiles = ref<{ id: string; name: string }[]>([]);
const configurations = ref<{ id: string; name: string }[]>([]);
const pipelines = ref<{ id: string; name: string }[]>([]);
const amberStores = ref<{ id: string; name: string }[]>([]);

const fetchJobs = async () => {
  isLoading.value = true;
  error.value = null;
  try {
    const response = await apiClient.get('/jobs');
    jobs.value = response.data;
  } catch (err: any) {
    error.value = 'Failed to fetch jobs. Please try again.';
    console.error('Error fetching jobs:', err);
  } finally {
    isLoading.value = false;
  }
};

const fetchRelatedData = async () => {
  try {
    const [dockerResponse, configResponse, pipelineResponse, amberResponse] = await Promise.all([
      apiClient.get('/docker_files'),
      apiClient.get('/configurations'),
      apiClient.get('/pipelines'),
      apiClient.get('/amber_store')
    ]);
    dockerFiles.value = dockerResponse.data;
    configurations.value = configResponse.data;
    pipelines.value = pipelineResponse.data;
    amberStores.value = amberResponse.data;
  } catch (err: any) {
    console.error('Error fetching related data:', err);
  }
};

const getDockerFileName = (id: string) => {
  const docker = dockerFiles.value.find(d => d.id === id);
  return docker ? docker.name : 'Unknown';
};

const getConfigurationName = (id: string) => {
  const config = configurations.value.find(c => c.id === id);
  return config ? config.name : 'Unknown';
};

const getPipelineName = (id: string) => {
  const pipeline = pipelines.value.find(p => p.id === id);
  return pipeline ? pipeline.name : 'Unknown';
};

const getAmberStoreName = (id: string | null | undefined) => {
  if (!id) return 'N/A';
  const amber = amberStores.value.find(a => a.id === id);
  return amber ? amber.name : 'Unknown';
};

const editJob = (job: Job) => {
  selectedJob.value = { ...job };
  showEditor.value = true;
};

const handleSave = async (job: Job) => {
  isLoading.value = true;
  error.value = null;
  try {
    if (job.id) {
      await apiClient.put(`/jobs/${job.id}`, job);
    } else {
      await apiClient.post('/jobs', job);
    }
    await fetchJobs();
    showEditor.value = false;
  } catch (err: any) {
    error.value = 'Failed to save job. Please try again.';
    console.error('Error saving job:', err);
  } finally {
    isLoading.value = false;
  }
};

const deleteJob = async (id: string) => {
  if (!confirm('Are you sure you want to delete this job?')) return;
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.delete(`/jobs/${id}`);
    await fetchJobs();
  } catch (err: any) {
    error.value = 'Failed to delete job. Please try again.';
    console.error('Error deleting job:', err);
  } finally {
    isLoading.value = false;
  }
};

const startJob = async (id: string) => {
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.post(`/jobs/${id}/start`);
    await fetchJobs();
  } catch (err: any) {
    error.value = 'Failed to start job. Please try again.';
    console.error('Error starting job:', err);
  } finally {
    isLoading.value = false;
  }
};

const stopJob = async (id: string) => {
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.post(`/jobs/${id}/stop`);
    await fetchJobs();
  } catch (err: any) {
    error.value = 'Failed to stop job. Please try again.';
    console.error('Error stopping job:', err);
  } finally {
    isLoading.value = false;
  }
};

onMounted(() => {
  fetchJobs();
  fetchRelatedData();
});
</script>

<style scoped>
.jobs {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.jobs-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.add-button {
  background-color: #3498db;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.add-button:hover {
  background-color: #2980b9;
}

.job-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
}

.job-card {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.job-card h3 {
  margin: 0 0 10px 0;
  font-size: 1.2rem;
}

.job-actions {
  display: flex;
  justify-content: flex-end;
}

.edit-button, .delete-button, .start-button, .stop-button {
  background-color: transparent;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  margin-left: 10px;
  transition: color 0.3s ease;
}

.edit-button {
  color: #3498db;
}

.edit-button:hover {
  color: #2980b9;
}

.delete-button {
  color: #e74c3c;
}

.delete-button:hover {
  color: #c0392b;
}

.start-button {
  color: #2ecc71;
}

.start-button:hover {
  color: #27ae60;
}

.stop-button {
  color: #95a5a6;
}

.stop-button:hover {
  color: #7f8c8d;
}

.no-jobs {
  text-align: center;
  color: #7f8c8d;
  margin-top: 50px;
}

.error {
  color: #e74c3c;
  margin-top: 10px;
}

.loading {
  color: #3498db;
  margin-top: 10px;
}

.modal {
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background-color: #fefefe;
  padding: 20px;
  border: 1px solid #888;
  width: 90%;
  max-width: 1200px;
  max-height: 90vh;
  overflow-y: auto;
  border-radius: 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
</style>==== END OF FILE: frontend/src//views/studio/Jobs.vue ====

==== START OF FILE: frontend/src//views/studio/Configurations.vue ====
<template>
  <div class="configurations">
    <div class="configurations-header">
      <h1>Configurations</h1>
      <button @click="showEditor = true" class="add-button">
        <i class="fas fa-plus"></i> Create New Configuration
      </button>
    </div>

    <!-- Configuration Editor Modal -->
    <div v-if="showEditor" class="modal">
      <div class="modal-content">
        <ConfigurationEditor
          :data="selectedConfiguration"
          @save="handleSave"
          @cancel="showEditor = false"
        />
      </div>
    </div>

    <!-- List of Configurations -->
    <div v-if="configurations.length" class="configuration-grid">
      <div v-for="configuration in configurations" :key="configuration.id" class="configuration-card">
        <h3>{{ configuration.name }}</h3>
        <div class="configuration-actions">
          <button @click="editConfiguration(configuration)" class="edit-button">
            <i class="fas fa-edit"></i> Edit
          </button>
          <button @click="configuration.id && deleteConfiguration(configuration.id)" class="delete-button">
            <i class="fas fa-trash"></i> Delete
          </button>
        </div>
      </div>
    </div>
    <div v-else class="no-configurations">
      <p>No configurations available. Click the "Create New Configuration" button to create one.</p>
    </div>

    <p v-if="error" class="error">{{ error }}</p>
    <p v-if="isLoading" class="loading">Loading...</p>
  </div>
</template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import ConfigurationEditor from '@/components/studio/editors/ConfigurationEditor.vue';
  import apiClient from '@/services/apiClient';
  
  interface Configuration {
    id?: string;
    name: string;
    data: any;
  }
  
  const configurations = ref<Configuration[]>([]);
  const showEditor = ref(false);
  const selectedConfiguration = ref<Configuration>({ name: '', data: {} });
  const error = ref<string | null>(null);
  const isLoading = ref(false);
  
  const fetchConfigurations = async () => {
    isLoading.value = true;
    error.value = null;
    try {
      const response = await apiClient.get('/configurations');
      configurations.value = response.data;
    } catch (err: any) {
      error.value = 'Failed to fetch configurations. Please try again.';
      console.error('Error fetching configurations:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  const editConfiguration = (configuration: Configuration) => {
    selectedConfiguration.value = { ...configuration };
    showEditor.value = true;
  };
  
  const handleSave = async (configuration: Configuration) => {
    isLoading.value = true;
    error.value = null;
    try {
      if (configuration.id) {
        await apiClient.put(`/configurations/${configuration.id}`, configuration);
      } else {
        await apiClient.post('/configurations', configuration);
      }
      await fetchConfigurations();
      showEditor.value = false;
    } catch (err: any) {
      error.value = 'Failed to save configuration. Please try again.';
      console.error('Error saving configuration:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  const deleteConfiguration = async (id: string) => {
    if (!confirm('Are you sure you want to delete this configuration?')) return;
    isLoading.value = true;
    error.value = null;
    try {
      await apiClient.delete(`/configurations/${id}`);
      await fetchConfigurations();
    } catch (err: any) {
      error.value = 'Failed to delete configuration. Please try again.';
      console.error('Error deleting configuration:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  onMounted(fetchConfigurations);
  </script>
  
<style scoped>
.configurations {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.configurations-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.add-button {
  background-color: #3498db;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.add-button:hover {
  background-color: #2980b9;
}

.configuration-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
}

.configuration-card {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.configuration-card h3 {
  margin: 0 0 10px 0;
  font-size: 1.2rem;
}

.configuration-actions {
  display: flex;
  justify-content: flex-end;
}

.edit-button, .delete-button {
  background-color: transparent;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  margin-left: 10px;
  transition: color 0.3s ease;
}

.edit-button {
  color: #3498db;
}

.edit-button:hover {
  color: #2980b9;
}

.delete-button {
  color: #e74c3c;
}

.delete-button:hover {
  color: #c0392b;
}

.no-configurations {
  text-align: center;
  color: #7f8c8d;
  margin-top: 50px;
}

.error {
  color: #e74c3c;
  margin-top: 10px;
}

.loading {
  color: #3498db;
  margin-top: 10px;
}

.modal {
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background-color: #fefefe;
  padding: 20px;
  border: 1px solid #888;
  width: 90%;
  max-width: 1200px;
  max-height: 90vh;
  overflow-y: auto;
  border-radius: 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
</style>
==== END OF FILE: frontend/src//views/studio/Configurations.vue ====

==== START OF FILE: frontend/src//views/studio/DockerFiles.vue ====
<template>
  <div class="docker-files">
    <div class="docker-files-header">
      <h1>Docker Files</h1>
      <button @click="showEditor = true" class="add-button">
        <i class="fas fa-plus"></i> Create New Docker File
      </button>
    </div>

    <!-- Docker File Editor Modal -->
    <div v-if="showEditor" class="modal">
      <div class="modal-content">
        <DockerFileEditor
          :dockerFile="selectedDockerFile"
          @save="handleSave"
          @cancel="showEditor = false"
        />
      </div>
    </div>

    <!-- List of Docker Files -->
    <div v-if="dockerFiles.length" class="docker-file-grid">
      <div v-for="dockerFile in dockerFiles" :key="dockerFile.id" class="docker-file-card">
        <h3>{{ dockerFile.name }}</h3>
        <div class="docker-file-actions">
          <button @click="editDockerFile(dockerFile)" class="edit-button">
            <i class="fas fa-edit"></i> Edit
          </button>
          <button @click="dockerFile.id && deleteDockerFile(dockerFile.id)" class="delete-button">
            <i class="fas fa-trash"></i> Delete
          </button>
        </div>
      </div>
    </div>
    <div v-else class="no-docker-files">
      <p>No Docker files available. Click the "Create New Docker File" button to create one.</p>
    </div>

    <p v-if="error" class="error">{{ error }}</p>
    <p v-if="isLoading" class="loading">Loading...</p>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import DockerFileEditor from '@/components/studio/editors/DockerFileEditor.vue';
import apiClient from '@/services/apiClient';

interface DockerFile {
  id?: string;
  name: string;
  content: string;
}

const dockerFiles = ref<DockerFile[]>([]);
const showEditor = ref(false);
const selectedDockerFile = ref<DockerFile | null>(null);
const error = ref<string | null>(null);
const isLoading = ref(false);

const fetchDockerFiles = async () => {
  isLoading.value = true;
  error.value = null;
  try {
    const response = await apiClient.get('/docker_files');
    dockerFiles.value = response.data;
  } catch (err: any) {
    error.value = 'Failed to fetch Docker files. Please try again.';
    console.error('Error fetching Docker files:', err);
  } finally {
    isLoading.value = false;
  }
};




const editDockerFile = (dockerFile: DockerFile) => {
  selectedDockerFile.value = { ...dockerFile };
  showEditor.value = true;
};

const handleSave = async (dockerFile: DockerFile) => {
  isLoading.value = true;
  error.value = null;
  try {
    if (dockerFile.id) {
      await apiClient.put(`/docker_files/${dockerFile.id}`, dockerFile);
    } else {
      await apiClient.post('/docker_files', dockerFile);
    }
    await fetchDockerFiles();
    showEditor.value = false;
  } catch (err: any) {
    error.value = 'Failed to save Docker file. Please try again.';
    console.error('Error saving Docker file:', err);
  } finally {
    isLoading.value = false;
  }
};

const deleteDockerFile = async (id: string) => {
  if (!confirm('Are you sure you want to delete this Docker file?')) return;
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.delete(`/docker_files/${id}`);
    await fetchDockerFiles();
  } catch (err: any) {
    error.value = 'Failed to delete Docker file. Please try again.';
    console.error('Error deleting Docker file:', err);
  } finally {
    isLoading.value = false;
  }
};

onMounted(fetchDockerFiles);
</script>

<style scoped>
.docker-files {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.docker-files-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.add-button {
  background-color: #3498db;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.add-button:hover {
  background-color: #2980b9;
}

.docker-file-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
}

.docker-file-card {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.docker-file-card h3 {
  margin: 0 0 10px 0;
  font-size: 1.2rem;
}

.docker-file-actions {
  display: flex;
  justify-content: flex-end;
}

.edit-button, .delete-button {
  background-color: transparent;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  margin-left: 10px;
  transition: color 0.3s ease;
}

.edit-button {
  color: #3498db;
}

.edit-button:hover {
  color: #2980b9;
}

.delete-button {
  color: #e74c3c;
}

.delete-button:hover {
  color: #c0392b;
}

.no-docker-files {
  text-align: center;
  color: #7f8c8d;
  margin-top: 50px;
}

.error {
  color: #e74c3c;
  margin-top: 10px;
}

.loading {
  color: #3498db;
  margin-top: 10px;
}
.modal {
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background-color: #fefefe;
  padding: 20px;
  border: 1px solid #888;
  width: 90%;
  max-width: 1200px;
  max-height: 90vh;
  overflow-y: auto;
  border-radius: 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
</style>==== END OF FILE: frontend/src//views/studio/DockerFiles.vue ====

==== START OF FILE: frontend/src//views/studio/Pipelines.vue ====
<template>
  <div class="pipelines">
    <div class="pipelines-header">
      <h1>Pipelines</h1>
      <button @click="addPipeline" class="add-button">
        <i class="fas fa-plus"></i> Add New Pipeline
      </button>
    </div>

    <!-- Pipeline Editor Modal -->
    <div v-if="showEditor && selectedPipeline" class="modal">
      <div class="modal-content">
        <PipelineEditor
          :data="selectedPipeline"
          @save="handleSave"
          @cancel="closeEditor"
        />
      </div>
    </div>

    <!-- List of Pipelines -->
    <div v-if="pipelines.length" class="pipeline-grid">
      <div v-for="pipeline in pipelines" :key="pipeline.id" class="pipeline-card">
        <h3>{{ pipeline.name }}</h3>
        <div class="pipeline-actions">
          <button @click="editPipeline(pipeline)" class="edit-button">
            <i class="fas fa-edit"></i> Edit
          </button>
          <button @click="deletePipeline(pipeline.id)" class="delete-button">
            <i class="fas fa-trash"></i> Delete
          </button>
        </div>
      </div>
    </div>
    <div v-else class="no-pipelines">
      <p>No pipelines available. Click the "Add New Pipeline" button to create one.</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
import apiClient from '@/services/apiClient';
import * as yaml from 'js-yaml';

interface Pipeline {
  id: string;
  name: string;
  data: string;
}

const pipelines = ref<Pipeline[]>([]);
const showEditor = ref(false);
const selectedPipeline = ref<Pipeline | null>(null);

const fetchPipelines = async () => {
  try {
    const response = await apiClient.get('/pipelines');
    pipelines.value = response.data;
  } catch (error) {
    console.error('Failed to fetch pipelines:', error);
  }
};

const addPipeline = () => {
  selectedPipeline.value = {
    id: '',  // Use an empty string as a temporary ID
    name: '',
    data: '',
  };
  showEditor.value = true;
};

const editPipeline = (pipeline: Pipeline) => {
  selectedPipeline.value = { ...pipeline };
  showEditor.value = true;
};

const handleSave = async (updatedPipeline: Pipeline) => {
  try {
    const pipelineData = {
      ...updatedPipeline,
      data: yaml.load(updatedPipeline.data),
    };

    if (updatedPipeline.id) {
      await apiClient.put(`/pipelines/${updatedPipeline.id}`, pipelineData);
    } else {
      await apiClient.post('/pipelines', pipelineData);
    }
    await fetchPipelines();
    closeEditor();
  } catch (error) {
    console.error('Failed to save pipeline:', error);
  }
};

const deletePipeline = async (id: string | undefined) => {
  if (!id) {
    console.error('Cannot delete pipeline: ID is undefined');
    return;
  }
  if (confirm('Are you sure you want to delete this pipeline?')) {
    try {
      await apiClient.delete(`/pipelines/${id}`);
      await fetchPipelines();
    } catch (error) {
      console.error('Failed to delete pipeline:', error);
    }
  }
};

const closeEditor = () => {
  showEditor.value = false;
  selectedPipeline.value = null;
};

onMounted(() => {
  fetchPipelines();
});
</script>

<style scoped>
.pipelines {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
}

.pipelines-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.add-button {
  background-color: #3498db;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.add-button:hover {
  background-color: #2980b9;
}

.pipeline-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
}

.pipeline-card {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.pipeline-card h3 {
  margin: 0 0 10px 0;
  font-size: 1.2rem;
}

.pipeline-actions {
  display: flex;
  justify-content: flex-end;
}

.edit-button, .delete-button {
  background-color: transparent;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  margin-left: 10px;
  transition: color 0.3s ease;
}

.edit-button {
  color: #3498db;
}

.edit-button:hover {
  color: #2980b9;
}

.delete-button {
  color: #e74c3c;
}

.delete-button:hover {
  color: #c0392b;
}

.no-pipelines {
  text-align: center;
  color: #7f8c8d;
  margin-top: 50px;
}

.error {
  color: #e74c3c;
  margin-top: 10px;
}

.loading {
  color: #3498db;
  margin-top: 10px;
}

.modal {
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background-color: #fefefe;
  padding: 20px;
  border: 1px solid #888;
  width: 90%;
  max-width: 1200px;
  max-height: 90vh;
  overflow-y: auto;
  border-radius: 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
</style>==== END OF FILE: frontend/src//views/studio/Pipelines.vue ====

==== START OF FILE: frontend/src//views/studio/AmberStores.vue ====
<template>
  <div class="amber-stores">
    <div class="amber-stores-header">
      <h1>Amber Stores</h1>
      <button @click="addAmberStore" class="add-button">
        <i class="fas fa-plus"></i> Add New Amber Store
      </button>
    </div>

    <!-- Amber Store Editor Modal -->
    <div v-if="showEditor" class="modal">
      <div class="modal-content">
        <AmberStoreEditor
          :data="selectedAmberStore"
          @save="handleSave"
          @cancel="closeEditor"
        />
      </div>
    </div>

    <!-- List of Amber Stores -->
    <div v-if="amberStores.length" class="amber-store-grid">
      <div v-for="amberStore in amberStores" :key="amberStore.id" class="amber-store-card">
        <h3>{{ amberStore.name }}</h3>
        <p>ID: {{ amberStore.id }}</p>
        <div class="amber-store-actions">
          <button @click="editAmberStore(amberStore)" class="edit-button">
            <i class="fas fa-edit"></i> Edit
          </button>
          <button @click="deleteAmberStore(amberStore.id)" class="delete-button">
            <i class="fas fa-trash"></i> Delete
          </button>
        </div>
      </div>
    </div>
    <div v-else class="no-amber-stores">
      <p>No amber stores available. Click the "Add New Amber Store" button to create one.</p>
    </div>

    <p v-if="error" class="error">{{ error }}</p>
    <p v-if="isLoading" class="loading">Loading...</p>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import * as yaml from 'js-yaml';

import AmberStoreEditor from '@/components/studio/editors/AmberStoreEditor.vue';
import apiClient from '@/services/apiClient';

interface AmberStore {
  id?: string;
  name: string;
  data: string;
  secure_key_hash: string;
}

const amberStores = ref<AmberStore[]>([]);
const showEditor = ref(false);
const selectedAmberStore = ref<AmberStore>({ name: '', data: '{}', secure_key_hash: '' });
const error = ref<string | null>(null);
const isLoading = ref(false);

const fetchAmberStores = async () => {
  isLoading.value = true;
  error.value = null;
  try {
    const response = await apiClient.get('/amber_store');
    amberStores.value = response.data;
  } catch (err: any) {
    error.value = 'Failed to fetch amber stores. Please try again.';
    console.error('Error fetching amber stores:', err);
  } finally {
    isLoading.value = false;
  }
};

const addAmberStore = () => {
  selectedAmberStore.value = { name: '', data: '{}', secure_key_hash: '' };
  showEditor.value = true;
};

const editAmberStore = (amberStore: AmberStore) => {
  try {
    selectedAmberStore.value = { 
      ...amberStore,
      data: typeof amberStore.data === 'string' 
        ? yaml.dump(yaml.load(amberStore.data) || {}, { indent: 2 })
        : yaml.dump(amberStore.data || {}, { indent: 2 })
    };
    showEditor.value = true;
  } catch (err) {
    console.error('Error parsing AmberStore data:', err);
    error.value = 'Invalid data format in AmberStore. Unable to edit.';
  }
};

const handleSave = async (amberStore: AmberStore) => {
  isLoading.value = true;
  error.value = null;
  try {
    if (amberStore.id) {
      await apiClient.put(`/amber_store/${amberStore.id}`, amberStore);
    } else {
      await apiClient.post('/amber_store', amberStore);
    }
    await fetchAmberStores();
    closeEditor();
  } catch (err: any) {
    error.value = 'Failed to save amber store. Please try again.';
    console.error('Error saving amber store:', err);
  } finally {
    isLoading.value = false;
  }
};

const deleteAmberStore = async (id: string | undefined) => {
  if (!id) {
    console.error('Cannot delete amber store: ID is undefined');
    return;
  }
  if (!confirm('Are you sure you want to delete this amber store?')) return;
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.delete(`/amber_store/${id}`);
    await fetchAmberStores();
  } catch (err: any) {
    error.value = 'Failed to delete amber store. Please try again.';
    console.error('Error deleting amber store:', err);
  } finally {
    isLoading.value = false;
  }
};

const closeEditor = () => {
  showEditor.value = false;
  selectedAmberStore.value = { name: '', data: '{}', secure_key_hash: '' };
};

onMounted(fetchAmberStores);
</script>

<style scoped>
.amber-stores {
  max-width: 1200px;
  margin: 0 auto;
}

.amber-stores-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.add-button {
  background-color: #3498db;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.3s ease;
}

.add-button:hover {
  background-color: #2980b9;
}

.amber-store-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
}

.amber-store-card {
  background-color: #fff;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  padding: 20px;
}

.amber-store-card h3 {
  margin: 0 0 10px 0;
  font-size: 1.2rem;
}

.amber-store-card p {
  margin: 0 0 10px 0;
  color: #7f8c8d;
}

.amber-store-actions {
  display: flex;
  justify-content: flex-end;
}

.edit-button, .delete-button {
  background-color: transparent;
  border: none;
  cursor: pointer;
  font-size: 0.9rem;
  margin-left: 10px;
  transition: color 0.3s ease;
}

.edit-button {
  color: #3498db;
}

.edit-button:hover {
  color: #2980b9;
}

.delete-button {
  color: #e74c3c;
}

.delete-button:hover {
  color: #c0392b;
}

.no-amber-stores {
  text-align: center;
  color: #7f8c8d;
  margin-top: 50px;
}

.error {
  color: #e74c3c;
  margin-top: 10px;
}

.loading {
  color: #3498db;
  margin-top: 10px;
}

.modal {
  position: fixed;
  z-index: 1;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,0.4);
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal-content {
  background-color: #fefefe;
  padding: 20px;
  border: 1px solid #888;
  width: 90%;
  max-width: 1200px;
  max-height: 90vh;
  overflow-y: auto;
  border-radius: 5px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
</style>==== END OF FILE: frontend/src//views/studio/AmberStores.vue ====

==== START OF FILE: frontend/src//views/Login.vue ====
<template>
    <div class="login">
      <h2>Login</h2>
      <form @submit.prevent="login">
        <input v-model="username" type="text" placeholder="Username" required />
        <input v-model="password" type="password" placeholder="Password" required />
        <button type="submit">Login</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  import { useRouter } from 'vue-router';
  import { useStore } from 'vuex';
  import AuthService from '../services/AuthService';
  
  export default defineComponent({
    name: 'Login',
    setup() {
      const username = ref('');
      const password = ref('');
      const router = useRouter();
      const store = useStore();
  
      const login = async () => {
        try {
          const { token, user } = await AuthService.login(username.value, password.value);
          AuthService.setToken(token);
          store.commit('setLoggedIn', true);
          store.commit('setUser', user);
          router.push('/studio/dashboard');
        } catch (error) {
          console.error('Login failed:', error);
          // Handle login error (e.g., show error message)
        }
      };
  
      return { username, password, login };
    },
  });
  </script>
  
  <style scoped>
  .login {
    max-width: 300px;
    margin: 50px auto;
  }
  </style>==== END OF FILE: frontend/src//views/Login.vue ====

==== START OF FILE: frontend/src//views/Home.vue ====
<template>
    <div class="home">
      <h1>Welcome to FluentCLI Web Services</h1>
      <p>This is the home page.</p>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Home'
  });
  </script>==== END OF FILE: frontend/src//views/Home.vue ====

==== START OF FILE: frontend/src//views/Studio.vue ====
<template>
  <div class="studio">
    <nav class="studio-sidebar" :class="{ 'collapsed': isSidebarCollapsed }">
      <div class="sidebar-header">
        <button @click="toggleSidebar" class="toggle-sidebar">
          <i class="fas fa-bars"></i>
        </button>
        <h1>FluentCLI Studio</h1>
      </div>
      <router-link to="/studio/dashboard">
        <i class="fas fa-tachometer-alt"></i>
        <span>Dashboard</span>
      </router-link>
      <router-link to="/studio/jobs">
        <i class="fas fa-tasks"></i>
        <span>Jobs</span>
      </router-link>
      <router-link to="/studio/pipelines">
        <i class="fas fa-project-diagram"></i>
        <span>Pipelines</span>
      </router-link>
      <router-link to="/studio/dockerfiles">
        <i class="fab fa-docker"></i>
        <span>Docker Files</span>
      </router-link>
      <router-link to="/studio/configurations">
        <i class="fas fa-cogs"></i>
        <span>Configurations</span>
      </router-link>
      <router-link to="/studio/amberstores">
        <i class="fas fa-database"></i>
        <span>Amber Stores</span>
      </router-link>
    </nav>
    <main class="studio-main">
      <StudioHeader @toggleSidebar="toggleSidebar" />
      <div class="content-area">
        <router-view />
      </div>
    </main>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { useRoute } from 'vue-router';
import StudioHeader from '@/components/studio/StudioHeader.vue';

const isSidebarCollapsed = ref(false);
const route = useRoute();

const toggleSidebar = () => {
  isSidebarCollapsed.value = !isSidebarCollapsed.value;
};

computed(() => {
  const routeName = route.name as string;
  return routeName.charAt(0).toUpperCase() + routeName.slice(1);
});
</script>

<style scoped>
.studio {
  display: flex;
  height: 100vh;
  font-family: 'Arial', sans-serif;
}

.studio-sidebar {
  width: 250px;
  background-color: #2c3e50;
  color: #ecf0f1;
  transition: width 0.3s ease;
}

.studio-sidebar.collapsed {
  width: 60px;
}

.sidebar-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
}

.sidebar-header h1 {
  font-size: 1.2rem;
  margin: 0;
}

.toggle-sidebar {
  background: none;
  border: none;
  color: #ecf0f1;
  cursor: pointer;
  font-size: 1.2rem;
}

.studio-sidebar a {
  display: flex;
  align-items: center;
  color: #ecf0f1;
  text-decoration: none;
  padding: 15px 20px;
  transition: background-color 0.3s ease;
}

.studio-sidebar a:hover {
  background-color: #34495e;
}

.studio-sidebar a.router-link-active {
  background-color: #3498db;
}

.studio-sidebar i {
  margin-right: 10px;
  width: 20px;
  text-align: center;
}

.studio-main {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  background-color: #f5f5f5;
}

.studio-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.studio-header h2 {
  margin: 0;
  font-size: 1.5rem;
}

.user-menu {
  display: flex;
  align-items: center;
}

.user-menu span {
  margin-right: 10px;
}

.logout-button {
  background-color: #e74c3c;
  color: #fff;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
}

.content-area {
  flex-grow: 1;
  padding: 20px;
  overflow-y: auto;
}
</style>==== END OF FILE: frontend/src//views/Studio.vue ====

==== START OF FILE: frontend/src//views/admin/Login.vue ====
<template>
  <div class="login">
    <h2>Login</h2>
    <form @submit.prevent="login">
      <input v-model="username" type="text" placeholder="Username" required />
      <input v-model="password" type="password" placeholder="Password" required />
      <button type="submit" :disabled="isLoading">
        {{ isLoading ? 'Logging in...' : 'Login' }}
      </button>
    </form>
    <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue';
import { useRouter } from 'vue-router';
import { useStore } from 'vuex';
import AuthService from '@/services/AuthService';

export default defineComponent({
  name: 'Login',
  setup() {
    const username = ref('');
    const password = ref('');
    const errorMessage = ref('');
    const isLoading = ref(false);
    const router = useRouter();
    const store = useStore();

    const login = async () => {
      errorMessage.value = '';
      isLoading.value = true;
      try {
        const { token, user } = await AuthService.login(username.value, password.value);
        AuthService.setToken(token);
        store.commit('setLoggedIn', true);
        store.commit('setUser', user);
        router.push('/');
      } catch (error: any) {
        console.error('Login failed:', error);
        errorMessage.value = error.response?.data?.message || 'Login failed. Please try again.';
      } finally {
        isLoading.value = false;
      }
    };

    return { username, password, login, errorMessage, isLoading };
  },
});
</script>

<style scoped>
.login {
  max-width: 300px;
  margin: 50px auto;
  padding: 20px;
  border: 1px solid #bdc3c7;
  border-radius: 5px;
  background-color: #fff;
}

.login h2 {
  text-align: center;
  margin-bottom: 20px;
}

.login form {
  display: flex;
  flex-direction: column;
}

.login input {
  padding: 10px;
  margin-bottom: 15px;
  border: 1px solid #bdc3c7;
  border-radius: 3px;
}

.login button {
  padding: 10px;
  background-color: #2c3e50;
  color: #ecf0f1;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}

.login button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.error {
  color: red;
  text-align: center;
  margin-top: 10px;
}
</style>==== END OF FILE: frontend/src//views/admin/Login.vue ====

==== START OF FILE: frontend/src//views/Admin.vue ====
<template>
    <div>
      <h1>Admin</h1>
      <nav>
        <RouterLink to="/admin/jobs">Job List</RouterLink> |
        <RouterLink to="/admin/jobs/create">Create Job</RouterLink> 
      </nav>
      <RouterView />
    </div>
  </template>
  
  <script setup lang="ts">
    import { RouterLink, RouterView } from 'vue-router';

  </script>
  
  <style scoped>
    /* Add your styles here */
  </style>==== END OF FILE: frontend/src//views/Admin.vue ====

==== START OF FILE: frontend/src//services/AuthService.ts ====
import apiClient from './apiClient';

interface LoginResponse {
  token: string;
  user: any; // Define a proper type based on your user structure
}

const AuthService = {
  async login(username: string, password: string): Promise<LoginResponse> {
    const response = await apiClient.post('/users/login', { username, password });
    return response.data;
  },

  async validateToken(token: string): Promise<any> {
    try {
      const response = await apiClient.get('/users/validate-token', {
        headers: { Authorization: `Bearer ${token}` }
      });
      return response.data;
    } catch (error) {
      throw new Error('Invalid token');
    }
  },

  logout() {
    localStorage.removeItem('token');
    delete apiClient.defaults.headers.common['Authorization'];
    window.location.href = '/login';
  },

  setToken(token: string) {
    localStorage.setItem('token', token);
    apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;
  },

  getToken(): string | null {
    return localStorage.getItem('token');
  },

  removeToken(): void {
    localStorage.removeItem('token');
  },
};

export default AuthService;==== END OF FILE: frontend/src//services/AuthService.ts ====

==== START OF FILE: frontend/src//services/apiClient.ts ====
import axios from 'axios';
import { API_URL } from '@/config';
import AuthService from './AuthService';

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  },
});

// Request interceptor to add the auth token to headers
apiClient.interceptors.request.use(
  (config) => {
    const token = AuthService.getToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor to handle global errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle unauthorized access globally
    if (error.response && error.response.status === 401) {
      AuthService.logout();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default apiClient;==== END OF FILE: frontend/src//services/apiClient.ts ====

==== START OF FILE: frontend/src//store/types.ts ====
export interface RootState {
    // Define your root state properties here
    // For example:
    // user: User | null;
    // isAuthenticated: boolean;
  }==== END OF FILE: frontend/src//store/types.ts ====

==== START OF FILE: frontend/src//store/index.ts ====
import { createStore } from 'vuex';

export default createStore({
  state: {
    isLoggedIn: false,
    user: null,
  },
  mutations: {
    setLoggedIn(state, value: boolean) {
      state.isLoggedIn = value;
    },
    setUser(state, user: any) {
      state.user = user;
    },
  },
  actions: {
    login({ commit }, { user }) { // Removed 'token' since it's unused
      commit('setLoggedIn', true);
      commit('setUser', user);
    },
    logout({ commit }) {
      commit('setLoggedIn', false);
      commit('setUser', null);
    },
  },
  getters: {
    isLoggedIn: (state) => state.isLoggedIn,
    user: (state) => state.user,
  },
});==== END OF FILE: frontend/src//store/index.ts ====

==== START OF FILE: frontend/src//store/modules/studio.ts ====
import { Module } from 'vuex';
import { RootState } from '../types';

interface StudioState {
  openTabs: Array<{ id: string; name: string; type: string; data: any }>;
  activeTabId: string | null;
}

const studioModule: Module<StudioState, RootState> = {
  namespaced: true,
  state: {
    openTabs: [],
    activeTabId: null,
  },
  mutations: {
    addTab(state, tab) {
      state.openTabs.push(tab);
      state.activeTabId = tab.id;
    },
    closeTab(state, tabId) {
      const index = state.openTabs.findIndex((tab) => tab.id === tabId);
      if (index !== -1) {
        state.openTabs.splice(index, 1);
        if (state.activeTabId === tabId) {
          state.activeTabId = state.openTabs.length > 0 ? state.openTabs[0].id : null;
        }
      }
    },
    setActiveTab(state, tabId) {
      state.activeTabId = tabId;
    },
    updateTabData(state, { tabId, data }) {
      const tab = state.openTabs.find((tab) => tab.id === tabId);
      if (tab) {
        tab.data = data;
      }
    },
  },
  actions: {
    openTab({ commit, state }, { id, name, type, data }) {
      const existingTab = state.openTabs.find((tab) => tab.id === id);
      if (existingTab) {
        commit('setActiveTab', id);
      } else {
        commit('addTab', { id, name, type, data });
      }
    },
  },
  getters: {
    activeTab: (state) => state.openTabs.find((tab) => tab.id === state.activeTabId),
  },
};

export default studioModule;==== END OF FILE: frontend/src//store/modules/studio.ts ====

==== START OF FILE: frontend/src//router/index.ts ====
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router';
import { useStore } from 'vuex';


import Home from '../views/Home.vue';
import Login from '../views/Login.vue';
import Admin from '../views/Admin.vue';
import Studio from '../views/Studio.vue';
import Dashboard from '../views/studio/Dashboard.vue';

import Pipelines from '../views/studio/Pipelines.vue';
import Settings from '../views/studio/Settings.vue';


import DockerFiles from '../views/studio/DockerFiles.vue';
import AmberStores from '../views/studio/AmberStores.vue';
import Jobs from '../views/studio/Jobs.vue';


const routes: Array<RouteRecordRaw> = [
  { path: '/', name: 'Home', component: Home },
  { path: '/login', name: 'Login', component: Login },
  { path: '/admin', name: 'Admin', component: Admin },
  {
    path: '/studio',
    name: 'Studio',
    component: Studio,
    meta: { requiresAuth: true },
    children: [
      { path: 'dashboard', name: 'Dashboard', component: Dashboard },
      {
        path: '/studio/jobs',
        name: 'Jobs',
        component: Jobs,
        meta: { requiresAuth: true }
      },
      { path: 'pipelines', name: 'Pipelines', component: Pipelines, meta: { requiresAuth: true } },
      { path: 'settings', name: 'Settings', component: Settings },
      {
        path: 'dockerfiles',
        name: 'DockerFiles',
        component: DockerFiles,
        meta: { requiresAuth: true }
      },
      {
        path: '/studio/configurations',
        name: 'Configurations',
        component: () => import('@/views/studio/Configurations.vue'),
        meta: { requiresAuth: true }
      },
      {
        path: '/studio/amberstores',
        name: 'AmberStores',
        component: AmberStores,
        meta: { requiresAuth: true }
      },
    ],
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// Navigation Guard
router.beforeEach((to, _, next) => {
  const store = useStore();
  const isLoggedIn = store.state.isLoggedIn;

  if (to.matched.some(record => record.meta.requiresAuth)) {
    if (!isLoggedIn) {
      next('/login');
    } else {
      next();
    }
  } else if (to.path === '/login' && isLoggedIn) {
    next('/studio/dashboard');
  } else {
    next();
  }
});

export default router;==== END OF FILE: frontend/src//router/index.ts ====

