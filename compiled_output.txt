==== START OF FILE: src//error.rs ====
// src/error.rs

use thiserror::Error;
use std::error::Error as StdError;
use diesel::r2d2;
use actix_web;
use actix_web::ResponseError;
use actix_web::http::StatusCode;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Database error: {0}")]
    DatabaseError(#[from] diesel::result::Error),

    #[error("Environment variable not found: {0}")]
    EnvVarError(#[from] std::env::VarError),

    #[error("Not found")]
    NotFound,

    #[error("Bad request: {0}")]
    BadRequest(String),

    #[error("R2D2 error: {0}")]
    R2D2Error(#[from] r2d2::PoolError),

    #[error("Unauthorized")]
    Unauthorized,

    #[error("Internal server error")]
    InternalServerError,

    #[error("Generic error: {0}")]
    GenericError(Box<dyn StdError + Send + Sync>),

    #[error("Migration error: {0}")]
    MigrationError(#[from] diesel_migrations::MigrationError),

    #[error("Authentication error")]
    AuthenticationError,

    #[error("Fluent CLI error: {0}")]
    FluentCLIError(String),
}

impl From<Box<dyn StdError + Send + Sync>> for AppError {
    fn from(error: Box<dyn StdError + Send + Sync>) -> Self {
        AppError::GenericError(error)
    }
}

impl ResponseError for AppError {
    fn status_code(&self) -> StatusCode {
        match self {
            AppError::NotFound => StatusCode::NOT_FOUND,
            AppError::BadRequest(_) => StatusCode::BAD_REQUEST,
            AppError::Unauthorized => StatusCode::UNAUTHORIZED,
            AppError::AuthenticationError => StatusCode::UNAUTHORIZED,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    fn error_response(&self) -> actix_web::HttpResponse {
        actix_web::HttpResponse::build(self.status_code())
            .json(serde_json::json!({ "error": self.to_string() }))
    }
}
==== END OF FILE: src//error.rs ====

==== START OF FILE: src//config.rs ====
==== END OF FILE: src//config.rs ====

==== START OF FILE: src//lib.rs ====
pub mod error;
mod db;
mod models;
pub mod schema;
pub mod handlers;
pub mod routes;
pub mod services;
pub mod utils;
==== END OF FILE: src//lib.rs ====

==== START OF FILE: src//utils/error.rs ====
==== END OF FILE: src//utils/error.rs ====

==== START OF FILE: src//utils/encryption.rs ====
use aes::Aes256;
use block_modes::{BlockMode, Cbc};
use block_modes::block_padding::Pkcs7;
use hex;
use rand::Rng;
use std::env;
use std::str;

type Aes256Cbc = Cbc<Aes256, Pkcs7>;

fn get_key() -> Vec<u8> {
    let key = env::var("ENCRYPTION_KEY").expect("ENCRYPTION_KEY must be set");
    hex::decode(key).expect("Invalid ENCRYPTION_KEY")
}

pub fn encrypt_data(data: &str) -> String {
    let key = get_key();
    let iv = rand::thread_rng().gen::<[u8; 16]>();
    let cipher = Aes256Cbc::new_from_slices(&key, &iv).unwrap();
    let ciphertext = cipher.encrypt_vec(data.as_bytes());
    format!("{}:{}", hex::encode(iv), hex::encode(ciphertext))
}

pub fn decrypt_data(encrypted_data: &str) -> String {
    let key = get_key();
    let parts: Vec<&str> = encrypted_data.split(':').collect();
    let iv = hex::decode(parts[0]).unwrap();
    let ciphertext = hex::decode(parts[1]).unwrap();
    let cipher = Aes256Cbc::new_from_slices(&key, &iv).unwrap();
    let decrypted_data = cipher.decrypt_vec(&ciphertext).unwrap();
    str::from_utf8(&decrypted_data).unwrap().to_string()
}==== END OF FILE: src//utils/encryption.rs ====

==== START OF FILE: src//utils/auth.rs ====
use actix_web::{dev::ServiceRequest, Error, HttpMessage};
use actix_web::dev::{Service, Transform};
use futures::future::{ok, Ready};
use futures::Future;
use std::pin::Pin;
use bcrypt::{DEFAULT_COST, hash, verify};
use crate::utils::jwt::validate_token;
use crate::error::AppError;

pub fn hash_password(password: &str) -> Result<String, AppError> {
    hash(password, DEFAULT_COST).map_err(|_| AppError::InternalServerError)
}

pub fn verify_password(password: &str, hash: &str) -> Result<bool, AppError> {
    verify(password, hash).map_err(|_| AppError::InternalServerError)
}

pub struct Auth;

impl<S, B> Transform<S, ServiceRequest> for Auth
where
    S: Service<ServiceRequest, Response = actix_web::dev::ServiceResponse<B>, Error = Error> + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Transform = AuthMiddleware<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ok(AuthMiddleware { service })
    }
}

pub struct AuthMiddleware<S> {
    service: S,
}

impl<S, B> Service<ServiceRequest> for AuthMiddleware<S>
where
    S: Service<ServiceRequest, Response = actix_web::dev::ServiceResponse<B>, Error = Error> + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>>>>;

    fn poll_ready(&self, cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        self.service.poll_ready(cx)
    }

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let auth_header = req.headers().get("Authorization").and_then(|h| h.to_str().ok());

        if let Some(auth_header) = auth_header {
            if auth_header.starts_with("Bearer ") {
                let token = &auth_header[7..];
                match validate_token(token) {
                    Ok(user_id) => {
                        req.extensions_mut().insert(user_id);
                        let fut = self.service.call(req);
                        return Box::pin(async move {
                            let res = fut.await?;
                            Ok(res)
                        });
                    }
                    Err(_) => {
                        return Box::pin(async { Err(actix_web::error::ErrorUnauthorized("Invalid token")) });
                    }
                }
            }
        }

        Box::pin(async { Err(actix_web::error::ErrorUnauthorized("Authorization header missing or malformed")) })
    }
}==== END OF FILE: src//utils/auth.rs ====

==== START OF FILE: src//utils/mod.rs ====
pub mod auth;
pub mod jwt;
pub mod encryption;==== END OF FILE: src//utils/mod.rs ====

==== START OF FILE: src//utils/jwt.rs ====
use crate::error::AppError;
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::env;
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: Uuid,
    exp: usize,
}

pub fn generate_token(user_id: Uuid) -> Result<String, AppError> {
    let expiration = chrono::Utc::now()
        .checked_add_signed(chrono::Duration::hours(24))
        .expect("valid timestamp")
        .timestamp();

    let claims = Claims {
        sub: user_id,
        exp: expiration as usize,
    };

    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(secret.as_bytes()),
    )
    .map_err(|_| AppError::InternalServerError)
}

pub fn validate_token(token: &str) -> Result<Uuid, AppError> {
    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret.as_bytes()),
        &Validation::default(),
    )
    .map_err(|_| AppError::AuthenticationError)?;

    Ok(token_data.claims.sub)
}
==== END OF FILE: src//utils/jwt.rs ====

==== START OF FILE: src//models/docker_file.rs ====
use crate::schema::docker_files;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = docker_files)]
pub struct DockerFile {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub content: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "docker_files"]
pub struct NewDockerFile {
    pub user_id: Uuid,
    pub name: String,
    pub content: String,
}

#[derive(Deserialize, Debug)]
pub struct NewDockerFilePayload {
    pub name: String,
    pub content: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "docker_files"]
pub struct UpdateDockerFile {
    pub name: Option<String>,
    pub content: Option<String>,
}==== END OF FILE: src//models/docker_file.rs ====

==== START OF FILE: src//models/job.rs ====
use crate::schema::jobs;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = jobs)]
pub struct Job {
    pub id: Uuid,
    pub user_id: Uuid,
    pub uri: String,
    pub config: Value, // Reference to configuration ID
    pub amber_id: Option<Uuid>, // Reference to amber_store ID
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String, // Reference to docker_file ID
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
}

#[derive(Insertable, Debug)]
#[table_name = "jobs"]
pub struct NewJob {
    pub user_id: Uuid,
    pub uri: String,
    pub config: Value,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
}

#[derive(Deserialize, Debug)]
pub struct NewJobPayload {
    pub uri: String,
    pub config: Value,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "jobs"]
pub struct UpdateJob {
    pub uri: Option<String>,
    pub config: Option<Value>,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: Option<String>,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: Option<String>,
}==== END OF FILE: src//models/job.rs ====

==== START OF FILE: src//models/configuration.rs ====
use crate::schema::configurations;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = configurations)]
pub struct Configuration {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}


#[derive(Insertable, Debug)]
#[table_name = "configurations"]
pub struct NewConfiguration {
    pub user_id: Uuid,
    pub name: String,
    pub data: serde_json::Value,
}

#[derive(Deserialize, Debug)]
pub struct NewConfigurationPayload {
    pub name: String,
    pub data: serde_json::Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "configurations"]
pub struct UpdateConfiguration {
    pub name: Option<String>,
    pub data: Option<serde_json::Value>,
}==== END OF FILE: src//models/configuration.rs ====

==== START OF FILE: src//models/worker.rs ====
use crate::schema::workers;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = workers)]
pub struct Worker {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub worker_type: Uuid, // Reference to docker_file ID
    pub active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "workers"]
pub struct NewWorker {
    pub user_id: Uuid,
    pub name: String,
    pub worker_type: Uuid,
    pub active: bool,
}

#[derive(Deserialize, Debug)]
pub struct NewWorkerPayload {
    pub name: String,
    pub worker_type: Uuid,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "workers"]
pub struct UpdateWorker {
    pub name: Option<String>,
    pub worker_type: Option<Uuid>,
    pub active: Option<bool>,
}==== END OF FILE: src//models/worker.rs ====

==== START OF FILE: src//models/user.rs ====
use crate::schema::users;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Serialize, Deserialize)]
#[diesel(table_name = users)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Deserialize)]
pub struct NewUser {
    pub username: String,
    pub email: String,
    pub password: String, // This field is not in the database, but used for user creation
}

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUserDB {
    pub username: String,
    pub email: String,
    pub password_hash: String,
}

#[derive(AsChangeset, Deserialize)]
#[diesel(table_name = users)]
pub struct UpdateUser {
    pub username: Option<String>,
    pub email: Option<String>,
}
==== END OF FILE: src//models/user.rs ====

==== START OF FILE: src//models/active_worker.rs ====
use crate::schema::active_workers;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = active_workers)]
pub struct ActiveWorker {
    pub id: Uuid,
    pub user_id: Uuid,
    pub worker_type: String,
    pub is_active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}==== END OF FILE: src//models/active_worker.rs ====

==== START OF FILE: src//models/amber_store.rs ====
use crate::schema::amber_store;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = amber_store)]
pub struct AmberStore {
    pub id: Uuid,
    pub user_id: Uuid,
    pub data: serde_json::Value,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}
#[derive(Insertable, Debug)]
#[table_name = "amber_store"]
pub struct NewAmberStore {
    pub user_id: Uuid,
    pub data: serde_json::Value,
}

#[derive(Deserialize, Debug)]
pub struct NewAmberStorePayload {
    pub data: serde_json::Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "amber_store"]
pub struct UpdateAmberStore {
    pub data: Option<serde_json::Value>,
}==== END OF FILE: src//models/amber_store.rs ====

==== START OF FILE: src//models/mod.rs ====

pub mod user;
pub mod api_key;
pub mod amber_store;
pub mod secure_vault;
pub mod configuration;
pub mod pipeline;
pub mod docker_file;
pub mod active_worker;
pub mod job;
pub mod worker;==== END OF FILE: src//models/mod.rs ====

==== START OF FILE: src//models/pipeline.rs ====
use crate::schema::pipelines;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = pipelines)]
pub struct Pipeline {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "pipelines"]
pub struct NewPipeline {
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
}

#[derive(Deserialize, Debug)]
pub struct NewPipelinePayload {
    pub name: String,
    pub data: Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "pipelines"]
pub struct UpdatePipeline {
    pub name: Option<String>,
    pub data: Option<Value>,
}==== END OF FILE: src//models/pipeline.rs ====

==== START OF FILE: src//models/secure_vault.rs ====
use crate::schema::secure_vaults;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = secure_vaults)]
pub struct SecureVault {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub encrypted_data: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "secure_vaults"]
pub struct NewSecureVault {
    pub user_id: Uuid,
    pub name: String,
    pub encrypted_data: String,
}

#[derive(Deserialize, Debug)]
pub struct NewSecureVaultPayload {
    pub name: String,
    pub data: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "secure_vaults"]
pub struct UpdateSecureVault {
    pub name: Option<String>,
    pub encrypted_data: Option<String>,
}==== END OF FILE: src//models/secure_vault.rs ====

==== START OF FILE: src//models/api_key.rs ====
use crate::schema::api_keys;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = api_keys)]
pub struct ApiKey {
    pub id: Uuid,
    pub user_id: Uuid,
    pub key_value: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
}
==== END OF FILE: src//models/api_key.rs ====

==== START OF FILE: src//routes.rs ====
use actix_web::{web, HttpResponse, Scope};
use crate::utils::auth::Auth;
use crate::handlers::{user, job, api_key, amber_store, secure_vault, configuration, pipeline, docker_file, worker};

pub fn configure_routes() -> Scope {
    web::scope("")
        // User routes
        .service(
            web::scope("/users")
                .route("", web::post().to(user::create_user))
                .route("", web::get().to(user::list_users))
                .route("/{id}", web::get().to(user::get_user))
                .route("/{id}", web::put().to(user::update_user))
                .route("/{id}", web::delete().to(user::delete_user))
                .route("/login", web::post().to(user::login))
                .route("/refresh", web::post().to(user::refresh_token))
                
        )
        // API Key routes
        .service(
            web::scope("/api_keys")
                .route("", web::post().to(api_key::create_api_key))
                .route("", web::get().to(api_key::list_api_keys))
                .route("/{id}", web::delete().to(api_key::delete_api_key))
        )
        // Job routes
        .service(
            web::scope("/jobs")
                .wrap(Auth)
                    .route("", web::post().to(job::create_job))
                    .route("", web::get().to(job::list_jobs))
                    .route("/{id}", web::get().to(job::get_job))
                    .route("/{id}", web::put().to(job::update_job))
                    .route("/{id}", web::delete().to(job::delete_job))
                    .route("/{id}/start", web::post().to(job::start_job))
                    .route("/{id}/stop", web::post().to(job::stop_job))
                    .route("/{id}/status", web::get().to(job::get_job_status))
                    .route("/{id}/output", web::get().to(job::get_job_output))
                    .route("/{id}/logs", web::get().to(job::get_job_logs))
        )
        // Amber Store routes
        .service(
            web::scope("/amber_store")
            .wrap(Auth)
                .route("", web::post().to(amber_store::create_amber_store))
                .route("", web::get().to(amber_store::list_amber_stores))
                .route("/{id}", web::get().to(amber_store::get_amber_store))
                .route("/{id}", web::put().to(amber_store::update_amber_store))
                .route("/{id}", web::delete().to(amber_store::delete_amber_store))
        )

        // Vault Store routes
        .service(
            web::scope("/secure_vaults")
            .wrap(Auth)
                .route("", web::post().to(secure_vault::create_secure_vault))
                .route("", web::get().to(secure_vault::list_secure_vaults))
                .route("/{id}", web::get().to(secure_vault::get_secure_vault))
                .route("/{id}", web::put().to(secure_vault::update_secure_vault))
                .route("/{id}", web::delete().to(secure_vault::delete_secure_vault))
        )
        // Configuration routes
        .service(
            web::scope("/configurations")
                .wrap(Auth)
                    .route("", web::post().to(configuration::create_configuration))
                    .route("", web::get().to(configuration::list_configurations))
                    .route("/{id}", web::get().to(configuration::get_configuration))
                    .route("/{id}", web::put().to(configuration::update_configuration))
                    .route("/{id}", web::delete().to(configuration::delete_configuration))
        )
        // Pipeline routes
        .service(
            web::scope("/pipelines")
                .wrap(Auth)
                    .route("", web::post().to(pipeline::create_pipeline))
                    .route("", web::get().to(pipeline::list_pipelines))
                    .route("/{id}", web::get().to(pipeline::get_pipeline))
                    .route("/{id}", web::put().to(pipeline::update_pipeline))
                    .route("/{id}", web::delete().to(pipeline::delete_pipeline))
        )
        // Docker File routes
        .service(
            web::scope("/docker_files")
            .wrap(Auth)
                .route("", web::post().to(docker_file::create_docker_file))
                .route("", web::get().to(docker_file::list_docker_files))
                .route("/{id}", web::get().to(docker_file::get_docker_file))
                .route("/{id}", web::put().to(docker_file::update_docker_file))
                .route("/{id}", web::delete().to(docker_file::delete_docker_file))
        )

        // Worker routes
        .service(
            web::scope("/workers")
            .wrap(Auth)
                .route("", web::post().to(worker::create_worker))
                .route("", web::get().to(worker::list_workers))
                .route("/{id}", web::get().to(worker::get_worker))
                .route("/{id}", web::put().to(worker::update_worker))
                .route("/{id}", web::delete().to(worker::delete_worker))
                .route("/{id}/activate", web::post().to(worker::activate_worker))
                .route("/{id}/deactivate", web::post().to(worker::deactivate_worker))
        )
}

==== END OF FILE: src//routes.rs ====

==== START OF FILE: src//schema.rs ====
// @generated automatically by Diesel CLI.

diesel::table! {
    active_workers (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        worker_type -> Varchar,
        is_active -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    amber_store (id) {
        id -> Uuid,
        user_id -> Uuid,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    api_keys (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        key_value -> Varchar,
        description -> Nullable<Text>,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        expires_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    configurations (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    docker_files (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        content -> Text,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    jobs (id) {
        id -> Uuid,
        user_id -> Uuid,
        uri -> Text,
        config -> Jsonb,
        amber_id -> Nullable<Uuid>,
        state_file_content -> Nullable<Text>,
        data_path -> Nullable<Text>,
        #[max_length = 255]
        worker_type -> Varchar,
        triggers -> Nullable<Jsonb>,
        timers -> Nullable<Jsonb>,
        #[max_length = 255]
        status -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        started_at -> Nullable<Timestamptz>,
        completed_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    pipelines (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    secure_vault (id) {
        id -> Uuid,
        user_id -> Uuid,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    secure_vaults (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        encrypted_data -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    users (id) {
        id -> Uuid,
        #[max_length = 255]
        username -> Varchar,
        #[max_length = 255]
        email -> Varchar,
        #[max_length = 255]
        password_hash -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    workers (id) {
        id -> Uuid,
        user_id -> Uuid,
        name -> Varchar,
        worker_type -> Uuid,
        active -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::joinable!(active_workers -> users (user_id));
diesel::joinable!(amber_store -> users (user_id));
diesel::joinable!(api_keys -> users (user_id));
diesel::joinable!(configurations -> users (user_id));
diesel::joinable!(docker_files -> users (user_id));
diesel::joinable!(jobs -> amber_store (amber_id));
diesel::joinable!(jobs -> users (user_id));
diesel::joinable!(pipelines -> users (user_id));
diesel::joinable!(secure_vault -> users (user_id));
diesel::joinable!(secure_vaults -> users (user_id));
diesel::joinable!(workers -> docker_files (worker_type));

diesel::allow_tables_to_appear_in_same_query!(
    active_workers,
    amber_store,
    api_keys,
    configurations,
    docker_files,
    jobs,
    pipelines,
    secure_vault,
    secure_vaults,
    users,
    workers,
);
==== END OF FILE: src//schema.rs ====

==== START OF FILE: src//db/db.rs ====
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool, PoolError};
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use dotenv::dotenv;
use std::env;
use crate::error::AppError;

pub type DbPool = Pool<ConnectionManager<PgConnection>>;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations");

pub fn create_db_pool() -> Result<DbPool, PoolError> {
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    Pool::builder().build(manager)
}

pub fn setup_database(pool: &DbPool) -> Result<(), AppError> {
    let mut conn = pool.get()?;
    conn.run_pending_migrations(MIGRATIONS)?;
    Ok(())
}==== END OF FILE: src//db/db.rs ====

==== START OF FILE: src//db/mod.rs ====
pub mod db;

pub use db::{create_db_pool, setup_database, DbPool};==== END OF FILE: src//db/mod.rs ====

==== START OF FILE: src//main.rs ====
mod db;
mod error;
mod models;
mod schema;
mod routes;
mod handlers;
mod services;
mod utils;
use dotenv::dotenv;

use actix_web::{App, HttpServer, http, middleware, web};
use actix_cors::Cors;

use db::{create_db_pool, setup_database};
use routes::configure_routes;


#[actix_web::main]
async fn main() -> std::io::Result<()> {
    std::env::set_var("RUST_LOG", "debug"); //remove at release
    dotenv().ok();
    env_logger::init();

    // Set up the database
    let pool = create_db_pool().expect("Failed to create database pool");
    setup_database(&pool).expect("Failed to set up database");
    println!("Database setup complete");


    HttpServer::new(move || {
        let cors = Cors::default()
            .allow_any_origin() // Be cautious with this in production environments
            .allowed_methods(vec!["GET", "POST", "PUT", "DELETE"])
            .allowed_headers(vec![http::header::AUTHORIZATION, http::header::ACCEPT])
            .allowed_header(http::header::CONTENT_TYPE)
            .max_age(3600);

        App::new()
            .wrap(cors)
            .wrap(middleware::Logger::default())
            .app_data(web::Data::new(pool.clone()))
            .service(configure_routes())
    })



    .bind("0.0.0.0:8000")?
    .run()
    .await
}==== END OF FILE: src//main.rs ====

==== START OF FILE: src//handlers/docker_file.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::docker_file_service::DockerFileService;
use crate::models::docker_file::{NewDockerFile, UpdateDockerFile, NewDockerFilePayload};

pub async fn create_docker_file(
    pool: web::Data<DbPool>,
    new_docker_file_payload: web::Json<NewDockerFilePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating docker file for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_docker_file_payload);

    let new_docker_file = NewDockerFile {
        user_id,
        name: new_docker_file_payload.name.clone(),
        content: new_docker_file_payload.content.clone(),
    };
    match DockerFileService::create_docker_file(&pool, new_docker_file) {
        Ok(docker_file) => {
            log::info!("Docker file created successfully: {:?}", docker_file);
            HttpResponse::Created().json(docker_file)
        },
        Err(e) => {
            log::error!("Error creating docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create docker file")
        }
    }
}

pub async fn list_docker_files(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::list_docker_files(&pool, user_id) {
        Ok(docker_files) => HttpResponse::Ok().json(docker_files),
        Err(e) => {
            log::error!("Error listing docker files: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list docker files")
        }
    }
}

pub async fn get_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::get_docker_file(&pool, docker_file_id.into_inner(), user_id) {
        Ok(docker_file) => HttpResponse::Ok().json(docker_file),
        Err(e) => {
            log::error!("Error getting docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get docker file")
        }
    }
}

pub async fn update_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    update_data: web::Json<UpdateDockerFile>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::update_docker_file(&pool, docker_file_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(docker_file) => HttpResponse::Ok().json(docker_file),
        Err(e) => {
            log::error!("Error updating docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update docker file")
        }
    }
}

pub async fn delete_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::delete_docker_file(&pool, docker_file_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete docker file")
        }
    }
}==== END OF FILE: src//handlers/docker_file.rs ====

==== START OF FILE: src//handlers/job.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::job_service::JobService;
use crate::models::job::{NewJob, UpdateJob, NewJobPayload};

pub async fn create_job(
    pool: web::Data<DbPool>,
    new_job_payload: web::Json<NewJobPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating job for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_job_payload);

    let new_job = NewJob {
        user_id,
        uri: new_job_payload.uri.clone(),
        config: new_job_payload.config.clone(),
        amber_id: new_job_payload.amber_id,
        state_file_content: new_job_payload.state_file_content.clone(),
        data_path: new_job_payload.data_path.clone(),
        worker_type: new_job_payload.worker_type.clone(),
        triggers: new_job_payload.triggers.clone(),
        timers: new_job_payload.timers.clone(),
        status: new_job_payload.status.clone(),
    };
    log::info!("New job data: {:?}", new_job);

    match JobService::create_job(&pool, new_job) {
        Ok(job) => {
            log::info!("Job created successfully: {:?}", job);
            HttpResponse::Created().json(job)
        },
        Err(e) => {
            log::error!("Error creating job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create job")
        }
    }
}

pub async fn list_jobs(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::list_jobs(&pool, user_id) {
        Ok(jobs) => HttpResponse::Ok().json(jobs),
        Err(e) => {
            log::error!("Error listing jobs: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list jobs")
        }
    }
}

pub async fn get_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error getting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job")
        }
    }
}

pub async fn update_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    update_data: web::Json<UpdateJob>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::update_job(&pool, job_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error updating job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update job")
        }
    }
}

pub async fn delete_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::delete_job(&pool, job_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete job")
        }
    }
}

pub async fn start_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::start_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error starting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to start job")
        }
    }
}

pub async fn stop_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::stop_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error stopping job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to stop job")
        }
    }
}

pub async fn get_job_status(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_status(&pool, job_id.into_inner(), user_id) {
        Ok(status) => HttpResponse::Ok().json(status),
        Err(e) => {
            log::error!("Error getting job status: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job status")
        }
    }
}

pub async fn get_job_output(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_output(&pool, job_id.into_inner(), user_id) {
        Ok(output) => HttpResponse::Ok().json(output),
        Err(e) => {
            log::error!("Error getting job output: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job output")
        }
    }
}

pub async fn get_job_logs(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_logs(&pool, job_id.into_inner(), user_id) {
        Ok(logs) => HttpResponse::Ok().json(logs),
        Err(e) => {
            log::error!("Error getting job logs: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job logs")
        }
    }
}==== END OF FILE: src//handlers/job.rs ====

==== START OF FILE: src//handlers/configuration.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::configuration_service::ConfigurationService;
use crate::models::configuration::{NewConfiguration, UpdateConfiguration, NewConfigurationPayload};

pub async fn create_configuration(
    pool: web::Data<DbPool>,
    new_configuration_payload: web::Json<NewConfigurationPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating configuration for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_configuration_payload);

    let new_configuration = NewConfiguration {
        user_id,
        name: new_configuration_payload.name.clone(),
        data: new_configuration_payload.data.clone(),
    };
    match ConfigurationService::create_configuration(&pool, new_configuration) {
        Ok(configuration) => {
            log::info!("Configuration created successfully: {:?}", configuration);
            HttpResponse::Created().json(configuration)
        },
        Err(e) => {
            log::error!("Error creating configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create configuration")
        }
    }
}

pub async fn list_configurations(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::list_configurations(&pool, user_id) {
        Ok(configurations) => HttpResponse::Ok().json(configurations),
        Err(e) => {
            log::error!("Error listing configurations: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list configurations")
        }
    }
}

pub async fn get_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::get_configuration(&pool, configuration_id.into_inner(), user_id) {
        Ok(configuration) => HttpResponse::Ok().json(configuration),
        Err(e) => {
            log::error!("Error getting configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get configuration")
        }
    }
}

pub async fn update_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    update_data: web::Json<UpdateConfiguration>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::update_configuration(&pool, configuration_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(configuration) => HttpResponse::Ok().json(configuration),
        Err(e) => {
            log::error!("Error updating configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update configuration")
        }
    }
}

pub async fn delete_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::delete_configuration(&pool, configuration_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete configuration")
        }
    }
}==== END OF FILE: src//handlers/configuration.rs ====

==== START OF FILE: src//handlers/worker.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::worker_service::WorkerService;
use crate::models::worker::{NewWorker, UpdateWorker, NewWorkerPayload};


pub async fn create_worker(
    pool: web::Data<DbPool>,
    new_worker_payload: web::Json<NewWorkerPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating worker for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_worker_payload);

    let new_worker = NewWorker {
        user_id,
        name: new_worker_payload.name.clone(),
        worker_type: new_worker_payload.worker_type,
        active: false,
    };
    log::info!("New worker data: {:?}", new_worker);

    match WorkerService::create_worker(&pool, new_worker) {
        Ok(worker) => {
            log::info!("Worker created successfully: {:?}", worker);
            HttpResponse::Created().json(worker)
        },
        Err(e) => {
            log::error!("Error creating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create worker")
        }
    }
}

pub async fn list_workers(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::list_workers(&pool, user_id) {
        Ok(workers) => HttpResponse::Ok().json(workers),
        Err(e) => {
            log::error!("Error listing workers: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list workers")
        }
    }
}

pub async fn get_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::get_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error getting worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get worker")
        }
    }
}

pub async fn update_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    update_data: web::Json<UpdateWorker>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::update_worker(&pool, worker_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error updating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update worker")
        }
    }
}

pub async fn delete_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::delete_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete worker")
        }
    }
}

pub async fn activate_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::activate_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error activating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to activate worker")
        }
    }
}

pub async fn deactivate_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::deactivate_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error deactivating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to deactivate worker")
        }
    }
}==== END OF FILE: src//handlers/worker.rs ====

==== START OF FILE: src//handlers/user.rs ====
use crate::models::user::{NewUser, UpdateUser};
use crate::error::AppError;

use actix_web::{web, HttpResponse, Responder, Error};
use crate::db::DbPool;
use serde_json::json; 
use uuid::Uuid;





use crate::services::user_service::UserService;
use crate::utils::jwt::generate_token;
use serde::{Deserialize};

#[derive(Deserialize)]
pub struct LoginRequest {
    username: String,
    password: String,
}


pub async fn create_user(
    pool: web::Data<DbPool>,
    new_user: web::Json<NewUser>,
) -> Result<HttpResponse, AppError> {
    if UserService::email_exists(&pool, &new_user.email)? {
        return Err(AppError::BadRequest("Email already in use".into()));
    }

    let user = UserService::create_user(&pool, new_user.into_inner())?;
    Ok(HttpResponse::Created().json(user))
}

pub async fn login(
    pool: web::Data<DbPool>,
    login_req: web::Json<LoginRequest>,
) -> Result<HttpResponse, Error> {
    match UserService::login(&pool, &login_req.username, &login_req.password) {
        Ok(user) => {
            match generate_token(user.id) {
                Ok(token) => Ok(HttpResponse::Ok().json(json!({ "token": token, "user": user }))),
                Err(e) => {
                    log::error!("Token generation error: {:?}", e);
                    Err(actix_web::error::ErrorInternalServerError("Failed to generate token"))
                }
            }
        },
        Err(e) => {
            log::error!("Login error: {:?}", e);
            match e {
                AppError::AuthenticationError => Err(actix_web::error::ErrorUnauthorized("Invalid credentials")),
                _ => Err(actix_web::error::ErrorInternalServerError("Login failed"))
            }
        }
    }
}

pub async fn list_users(pool: web::Data<DbPool>) -> Result<HttpResponse, Error> {
    match UserService::list_users(&pool) {
        Ok(users) => Ok(HttpResponse::Ok().json(users)),
        Err(e) => {
            log::error!("Error listing users: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to list users"))
        }
    }
}

use actix_web::HttpRequest;

pub async fn get_user(
    req: HttpRequest,
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
) -> Result<HttpResponse, Error> {
    log::info!("Received GET user request. User ID: {:?}, Headers: {:?}", user_id, req.headers());
    match UserService::get_user(&pool, user_id.into_inner()) {
        Ok(user) => Ok(HttpResponse::Ok().json(user)),
        Err(e) => {
            log::error!("Error getting user: {:?}", e);
            match e {
                AppError::NotFound => Err(actix_web::error::ErrorNotFound("User not found")),
                _ => Err(actix_web::error::ErrorInternalServerError("Failed to get user"))
            }
        }
    }
}

pub async fn update_user(
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
    user_data: web::Json<UpdateUser>,
) -> Result<HttpResponse, Error> {
    match UserService::update_user(&pool, user_id.into_inner(), user_data.into_inner()) {
        Ok(user) => Ok(HttpResponse::Ok().json(user)),
        Err(e) => {
            log::error!("Error updating user: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to update user"))
        }
    }
}

pub async fn delete_user(
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
) -> Result<HttpResponse, Error> {
    match UserService::delete_user(&pool, user_id.into_inner()) {
        Ok(_) => Ok(HttpResponse::NoContent().finish()),
        Err(e) => {
            log::error!("Error deleting user: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to delete user"))
        }
    }
}

pub async fn refresh_token(pool: web::Data<DbPool>, token: web::Json<String>) -> impl Responder {
    match UserService::refresh_token(&pool, &token.into_inner()) {
        Ok(new_token) => HttpResponse::Ok().json(serde_json::json!({ "token": new_token })),
        Err(_) => HttpResponse::Unauthorized().json(serde_json::json!({ "error": "Invalid token" })),
    }
}

==== END OF FILE: src//handlers/user.rs ====

==== START OF FILE: src//handlers/amber_store.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::amber_store_service::AmberStoreService;
use crate::models::amber_store::{NewAmberStore, UpdateAmberStore, NewAmberStorePayload};


pub async fn create_amber_store(
    pool: web::Data<DbPool>,
    new_amber_store_payload: web::Json<NewAmberStorePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating amber store for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_amber_store_payload);

    let new_amber_store = NewAmberStore {
        user_id,
        data: new_amber_store_payload.data.clone(),
    };
    match AmberStoreService::create_amber_store(&pool, new_amber_store) {
        Ok(amber_store) => {
            log::info!("Amber store created successfully: {:?}", amber_store);
            HttpResponse::Created().json(amber_store)
        },
        Err(e) => {
            log::error!("Error creating amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create amber store")
        }
    }
}

pub async fn list_amber_stores(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::list_amber_stores(&pool, user_id) {
        Ok(amber_stores) => HttpResponse::Ok().json(amber_stores),
        Err(e) => {
            log::error!("Error listing amber stores: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list amber stores")
        }
    }
}

pub async fn get_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::get_amber_store(&pool, amber_store_id.into_inner(), user_id) {
        Ok(amber_store) => HttpResponse::Ok().json(amber_store),
        Err(e) => {
            log::error!("Error getting amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get amber store")
        }
    }
}

pub async fn update_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    update_data: web::Json<UpdateAmberStore>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::update_amber_store(&pool, amber_store_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(amber_store) => HttpResponse::Ok().json(amber_store),
        Err(e) => {
            log::error!("Error updating amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update amber store")
        }
    }
}

pub async fn delete_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::delete_amber_store(&pool, amber_store_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete amber store")
        }
    }
}==== END OF FILE: src//handlers/amber_store.rs ====

==== START OF FILE: src//handlers/mod.rs ====
pub mod user;
pub mod job;
pub mod api_key;
pub mod amber_store;
pub mod secure_vault;
pub mod configuration;
pub mod pipeline;
pub mod docker_file;
pub mod worker;==== END OF FILE: src//handlers/mod.rs ====

==== START OF FILE: src//handlers/pipeline.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::pipeline_service::PipelineService;
use crate::models::pipeline::{NewPipeline, UpdatePipeline, NewPipelinePayload};

pub async fn create_pipeline(
    pool: web::Data<DbPool>,
    new_pipeline_payload: web::Json<NewPipelinePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating pipeline for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_pipeline_payload);

    let new_pipeline = NewPipeline {
        user_id,
        name: new_pipeline_payload.name.clone(),
        data: new_pipeline_payload.data.clone(),
    };
    match PipelineService::create_pipeline(&pool, new_pipeline) {
        Ok(pipeline) => {
            log::info!("Pipeline created successfully: {:?}", pipeline);
            HttpResponse::Created().json(pipeline)
        },
        Err(e) => {
            log::error!("Error creating pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create pipeline")
        }
    }
}

pub async fn list_pipelines(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::list_pipelines(&pool, user_id) {
        Ok(pipelines) => HttpResponse::Ok().json(pipelines),
        Err(e) => {
            log::error!("Error listing pipelines: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list pipelines")
        }
    }
}

pub async fn get_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::get_pipeline(&pool, pipeline_id.into_inner(), user_id) {
        Ok(pipeline) => HttpResponse::Ok().json(pipeline),
        Err(e) => {
            log::error!("Error getting pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get pipeline")
        }
    }
}

pub async fn update_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    update_data: web::Json<UpdatePipeline>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::update_pipeline(&pool, pipeline_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(pipeline) => HttpResponse::Ok().json(pipeline),
        Err(e) => {
            log::error!("Error updating pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update pipeline")
        }
    }
}

pub async fn delete_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::delete_pipeline(&pool, pipeline_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete pipeline")
        }
    }
}==== END OF FILE: src//handlers/pipeline.rs ====

==== START OF FILE: src//handlers/secure_vault.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::secure_vault_service::SecureVaultService;
use crate::models::secure_vault::{NewSecureVault, UpdateSecureVault, NewSecureVaultPayload};
use crate::utils::encryption::encrypt_data;

pub async fn create_secure_vault(
    pool: web::Data<DbPool>,
    new_secure_vault_payload: web::Json<NewSecureVaultPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating secure vault for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_secure_vault_payload);

    let encrypted_data = encrypt_data(&new_secure_vault_payload.data);
    let new_secure_vault = NewSecureVault {
        user_id,
        name: new_secure_vault_payload.name.clone(),
        encrypted_data,
    };
    log::info!("New secure vault data: {:?}", new_secure_vault);

    match SecureVaultService::create_secure_vault(&pool, new_secure_vault) {
        Ok(secure_vault) => {
            log::info!("Secure vault created successfully: {:?}", secure_vault);
            HttpResponse::Created().json(secure_vault)
        },
        Err(e) => {
            log::error!("Error creating secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create secure vault")
        }
    }
}

pub async fn list_secure_vaults(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::list_secure_vaults(&pool, user_id) {
        Ok(secure_vaults) => HttpResponse::Ok().json(secure_vaults),
        Err(e) => {
            log::error!("Error listing secure vaults: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list secure vaults")
        }
    }
}

pub async fn get_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::get_secure_vault(&pool, secure_vault_id.into_inner(), user_id) {
        Ok(secure_vault) => HttpResponse::Ok().json(secure_vault),
        Err(e) => {
            log::error!("Error getting secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get secure vault")
        }
    }
}

pub async fn update_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    update_data: web::Json<UpdateSecureVault>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::update_secure_vault(&pool, secure_vault_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(secure_vault) => HttpResponse::Ok().json(secure_vault),
        Err(e) => {
            log::error!("Error updating secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update secure vault")
        }
    }
}

pub async fn delete_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::delete_secure_vault(&pool, secure_vault_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete secure vault")
        }
    }
}==== END OF FILE: src//handlers/secure_vault.rs ====

==== START OF FILE: src//handlers/api_key.rs ====
use actix_web::{web, HttpResponse, Responder};

pub async fn create_api_key() -> impl Responder {
    HttpResponse::Ok().body("Create API key")
}

pub async fn list_api_keys() -> impl Responder {
    HttpResponse::Ok().body("List API keys")
}

pub async fn delete_api_key() -> impl Responder {
    HttpResponse::Ok().body("Delete API key")
}
==== END OF FILE: src//handlers/api_key.rs ====

==== START OF FILE: src//services/fluentcli_service.rs ====
use crate::error::AppError;
use std::process::Command;

pub struct FluentCLIService;

impl FluentCLIService {
    pub fn execute_command(&self, command: &str) -> Result<String, AppError> {
        let output = Command::new("fluentcli")
            .args(command.split_whitespace())
            .output()
            .map_err(|e| AppError::FluentCLIError(e.to_string()))?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(AppError::FluentCLIError(String::from_utf8_lossy(&output.stderr).to_string()))
        }
    }
}==== END OF FILE: src//services/fluentcli_service.rs ====

==== START OF FILE: src//services/worker_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::worker::{Worker, NewWorker, UpdateWorker};
use diesel::prelude::*;
use uuid::Uuid;

pub struct WorkerService;

impl WorkerService {
    pub fn create_worker(pool: &DbPool, new_worker: NewWorker) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new worker into database: {:?}", new_worker);
        match diesel::insert_into(workers)
            .values(&new_worker)
            .get_result(conn) {
            Ok(worker) => {
                log::info!("Worker inserted into database: {:?}", worker);
                Ok(worker)
            },
            Err(e) => {
                log::error!("Error inserting worker into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_workers(pool: &DbPool, user_id: Uuid) -> Result<Vec<Worker>, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        workers.filter(user_id.eq(user_id)).load::<Worker>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        workers.filter(id.eq(worker_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_worker(pool: &DbPool, worker_id: Uuid, update_data: UpdateWorker, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }

    pub fn activate_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(active.eq(true))
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn deactivate_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(active.eq(false))
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
}==== END OF FILE: src//services/worker_service.rs ====

==== START OF FILE: src//services/configuration_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::configuration::{Configuration, NewConfiguration, UpdateConfiguration};
use diesel::prelude::*;
use uuid::Uuid;

pub struct ConfigurationService;

impl ConfigurationService {
    pub fn create_configuration(pool: &DbPool, new_configuration: NewConfiguration) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new configuration into database: {:?}", new_configuration);
        diesel::insert_into(configurations)
            .values(&new_configuration)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_configurations(pool: &DbPool, user_id: Uuid) -> Result<Vec<Configuration>, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        configurations.filter(user_id.eq(user_id)).load::<Configuration>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_configuration(pool: &DbPool, configuration_id: Uuid, user_id: Uuid) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_configuration(pool: &DbPool, configuration_id: Uuid, update_data: UpdateConfiguration, user_id: Uuid) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_configuration(pool: &DbPool, configuration_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/configuration_service.rs ====

==== START OF FILE: src//services/docker_file_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::docker_file::{DockerFile, NewDockerFile, UpdateDockerFile};
use diesel::prelude::*;
use uuid::Uuid;

pub struct DockerFileService;

impl DockerFileService {
    pub fn create_docker_file(pool: &DbPool, new_docker_file: NewDockerFile) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new docker file into database: {:?}", new_docker_file);
        diesel::insert_into(docker_files)
            .values(&new_docker_file)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_docker_files(pool: &DbPool, user_id: Uuid) -> Result<Vec<DockerFile>, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        docker_files.filter(user_id.eq(user_id)).load::<DockerFile>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_docker_file(pool: &DbPool, docker_file_id: Uuid, user_id: Uuid) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_docker_file(pool: &DbPool, docker_file_id: Uuid, update_data: UpdateDockerFile, user_id: Uuid) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_docker_file(pool: &DbPool, docker_file_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/docker_file_service.rs ====

==== START OF FILE: src//services/pipeline_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::pipeline::{Pipeline, NewPipeline, UpdatePipeline};
use diesel::prelude::*;
use uuid::Uuid;

pub struct PipelineService;

impl PipelineService {
    pub fn create_pipeline(pool: &DbPool, new_pipeline: NewPipeline) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new pipeline into database: {:?}", new_pipeline);
        diesel::insert_into(pipelines)
            .values(&new_pipeline)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_pipelines(pool: &DbPool, user_id: Uuid) -> Result<Vec<Pipeline>, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        pipelines.filter(user_id.eq(user_id)).load::<Pipeline>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_pipeline(pool: &DbPool, pipeline_id: Uuid, user_id: Uuid) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_pipeline(pool: &DbPool, pipeline_id: Uuid, update_data: UpdatePipeline, user_id: Uuid) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_pipeline(pool: &DbPool, pipeline_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/pipeline_service.rs ====

==== START OF FILE: src//services/mod.rs ====
pub mod job_service;
pub mod fluentcli_service;
pub mod user_service;
pub mod amber_store_service;
pub mod configuration_service;
pub mod docker_file_service;
pub mod pipeline_service;
pub mod worker_service;
pub mod secure_vault_service;==== END OF FILE: src//services/mod.rs ====

==== START OF FILE: src//services/secure_vault_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::secure_vault::{SecureVault, NewSecureVault, UpdateSecureVault};
use diesel::prelude::*;
use uuid::Uuid;

pub struct SecureVaultService;

impl SecureVaultService {
    pub fn create_secure_vault(pool: &DbPool, new_secure_vault: NewSecureVault) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new secure vault into database: {:?}", new_secure_vault);
        match diesel::insert_into(secure_vaults)
            .values(&new_secure_vault)
            .get_result(conn) {
            Ok(secure_vault) => {
                log::info!("Secure vault inserted into database: {:?}", secure_vault);
                Ok(secure_vault)
            },
            Err(e) => {
                log::error!("Error inserting secure vault into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_secure_vaults(pool: &DbPool, user_id: Uuid) -> Result<Vec<SecureVault>, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Listing secure vaults for user_id: {:?}", user_id);
        secure_vaults.filter(user_id.eq(user_id))
            .load::<SecureVault>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_secure_vault(pool: &DbPool, secure_vault_id: Uuid, user_id: Uuid) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Getting secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id)))
            .first::<SecureVault>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_secure_vault(pool: &DbPool, secure_vault_id: Uuid, update_data: UpdateSecureVault, user_id: Uuid) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Updating secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        diesel::update(secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_secure_vault(pool: &DbPool, secure_vault_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Deleting secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        diesel::delete(secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map(|_| ())
            .map_err(AppError::DatabaseError)
    }
}==== END OF FILE: src//services/secure_vault_service.rs ====

==== START OF FILE: src//services/amber_store_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::amber_store::{AmberStore, NewAmberStore, UpdateAmberStore};
use diesel::prelude::*;
use uuid::Uuid;

pub struct AmberStoreService;

impl AmberStoreService {
    pub fn create_amber_store(pool: &DbPool, new_amber_store: NewAmberStore) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new amber store into database: {:?}", new_amber_store);
        diesel::insert_into(amber_store)
            .values(&new_amber_store)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_amber_stores(pool: &DbPool, user_id: Uuid) -> Result<Vec<AmberStore>, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        amber_store.filter(user_id.eq(user_id)).load::<AmberStore>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_amber_store(pool: &DbPool, amber_store_id: Uuid, user_id: Uuid) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_amber_store(pool: &DbPool, amber_store_id: Uuid, update_data: UpdateAmberStore, user_id: Uuid) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_amber_store(pool: &DbPool, amber_store_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/amber_store_service.rs ====

==== START OF FILE: src//services/user_service.rs ====
use std::fmt::Debug;
use actix_web::HttpMessage;
use chrono::Utc;
use crate::db::DbPool;
use crate::error::AppError;
use crate::utils::auth::{hash_password, verify_password};
use crate::models::user::{NewUser, User, UpdateUser, NewUserDB};
use diesel::prelude::*;
use uuid::Uuid;
use crate::utils::jwt;

pub struct UserService;

impl UserService {
    pub fn create_user(pool: &DbPool, new_user: NewUser) -> Result<User, AppError> {
        use crate::schema::users;
        let conn = &mut pool.get()?;
    
        let hashed_password = hash_password(&new_user.password)?;
        let new_user_db = NewUserDB {
            username: new_user.username,
            email: new_user.email,
            password_hash: hashed_password, // Use password_hash field
        };
    
        diesel::insert_into(users::table)
            .values(&new_user_db) // Use new_user_db for insertion
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn login(pool: &DbPool, username: &str, password: &str) -> Result<User, AppError> {
        let user = Self::get_user_by_username(pool, username.to_string())?;
        match verify_password(password, &user.password_hash) {
            Ok(is_valid) => {
                if is_valid {
                    Ok(user)
                } else {
                    Err(AppError::AuthenticationError)
                }
            },
            Err(e) => {
                log::error!("Password verification error: {:?}", e);
                Err(AppError::InternalServerError)
            }
        }
    }

    pub fn get_user_by_username(pool: &DbPool, username_: String) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;

        let conn = &mut pool.get()?;
        
        users
            .filter(username.eq(username_))
            .first(conn)
            .map_err(|error| {
                if error == diesel::result::Error::NotFound {
                    AppError::NotFound
                } else {
                    AppError::DatabaseError(error)
                }
            })
    }


    pub fn get_user(pool: &DbPool, user_id: Uuid) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Received GET user request. User ID: {:?},", user_id);
        users.find(user_id)
            .first(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn update_user(pool: &DbPool, user_id: Uuid, update_data: UpdateUser) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(users.find(user_id))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn delete_user(pool: &DbPool, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(users.find(user_id))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }

    pub fn email_exists(pool: &DbPool, email: &str) -> Result<bool, AppError> {
        use crate::schema::users::dsl::*;
        
        let conn = &mut pool.get()?;
        let count = users.filter(email.eq(email))
                         .count()
                         .get_result::<i64>(conn)?;
        
        Ok(count > 0)
    }

    pub fn list_users(pool: &DbPool) -> Result<Vec<User>, AppError> {
        use crate::schema::users::dsl::*; // Add this line to import users
        let conn = &mut pool.get()?;
        users.load::<User>(conn).map_err(AppError::DatabaseError)
    }

    pub fn refresh_token(pool: &DbPool, token: &str) -> Result<String, AppError> {
        let user_id = jwt::validate_token(token)?;
        let user = Self::get_user(pool, user_id)?;
        jwt::generate_token(user.id)
    }

    
}
==== END OF FILE: src//services/user_service.rs ====

==== START OF FILE: src//services/job_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::job::{Job, NewJob, UpdateJob};
use diesel::prelude::*;
use uuid::Uuid;

pub struct JobService;

impl JobService {
    pub fn create_job(pool: &DbPool, new_job: NewJob) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new job into database: {:?}", new_job);
        match diesel::insert_into(jobs)
            .values(&new_job)
            .get_result(conn) {
            Ok(job) => {
                log::info!("Job inserted into database: {:?}", job);
                Ok(job)
            },
            Err(e) => {
                log::error!("Error inserting job into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_jobs(pool: &DbPool, user_id: Uuid) -> Result<Vec<Job>, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Listing jobs for user_id: {:?}", user_id);
        jobs.filter(user_id.eq(user_id))
            .load::<Job>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Getting job with id: {:?} for user_id: {:?}", job_id, user_id);
        jobs.filter(id.eq(job_id).and(user_id.eq(user_id)))
            .first::<Job>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_job(pool: &DbPool, job_id: Uuid, update_data: UpdateJob, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Updating job with id: {:?} for user_id: {:?}", job_id, user_id);
        diesel::update(jobs.filter(id.eq(job_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Deleting job with id: {:?} for user_id: {:?}", job_id, user_id);
        diesel::delete(jobs.filter(id.eq(job_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map(|_| ())
            .map_err(AppError::DatabaseError)
    }

    pub fn start_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        // Implement the logic to start a job
        unimplemented!()
    }

    pub fn stop_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        // Implement the logic to stop a job
        unimplemented!()
    }

    pub fn get_job_status(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the status of a job
        unimplemented!()
    }

    pub fn get_job_output(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the output of a job
        unimplemented!()
    }

    pub fn get_job_logs(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the logs of a job
        unimplemented!()
    }
}==== END OF FILE: src//services/job_service.rs ====

==== START OF FILE: frontend/src//App.vue ====
<template>
  <div id="app">
    <button @click="toggleLogin">{{ loginButtonText }}</button>

    <nav>
      <router-link to="/">Home</router-link> |
      <router-link to="/admin">Admin</router-link> |
      <router-link to="/studio">Studio</router-link> 
    </nav>
    <router-view></router-view>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue';
import { useStore } from 'vuex'
import axios from 'axios';
import AuthService from './services/AuthService';

const toggleLogin = async () => {
  if (isLoggedIn.value) {
    // Logout
    AuthService.logout();
    store.commit('setLoggedIn', false);
    store.commit('setUser', null);
  } else {
    // Login
    const credentials = {
      username: 'testuser',
      password: 'testpassword'
    };
    try {
      const { token, user } = await AuthService.login(credentials.username, credentials.password);
      AuthService.setToken(token);
      store.commit('setLoggedIn', true);
      store.commit('setUser', user);
    } catch (error) {
      console.error('Login failed:', error);
    }
  }
};



export default defineComponent({
  setup() {
    const store = useStore()
    const isLoggedIn = computed(() => store.state.isLoggedIn)
    const loginButtonText = computed(() => isLoggedIn.value ? 'Logout' : 'Login')

    const toggleLogin = async () => {
  if (isLoggedIn.value) {
    // Logout
    try {
-     await axios.post('/users/logout')
      AuthService.logout();
      store.commit('setLoggedIn', false)
      store.commit('setUser', null)
    } catch (error) {
      console.error('Logout failed:', error)
    }
  } else {
        // For simplicity, we're using hardcoded credentials here.
        // In a real app, you'd have a login form.
        const credentials = {
          username: 'testuser',
          password: 'testpassword'
        }
        try {
          const response = await axios.post('/api/users/login', credentials)
          store.commit('setLoggedIn', true)
          store.commit('setUser', response.data.user)
        } catch (error) {
          console.error('Login failed:', error)
        }
      }
    }

    return {
      loginButtonText,
      toggleLogin
    }
  }
})
</script>


<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: #2c3e50;
}

nav {
  padding: 30px;
}

nav a {
  font-weight: bold;
  color: #2c3e50;
}

nav a.router-link-exact-active {
  color: #42b983;
}
</style>==== END OF FILE: frontend/src//App.vue ====

==== START OF FILE: frontend/src//main.ts ====
import { createApp } from 'vue';
import App from './App.vue';
import router from './router';
import store from './store';
import AuthService from './services/AuthService';

const token = AuthService.getToken();
if (token) {
  AuthService.setToken(token);
  store.commit('setLoggedIn', true);
  // Optionally fetch user data here
}

createApp(App).use(router).use(store).mount('#app');==== END OF FILE: frontend/src//main.ts ====

==== START OF FILE: frontend/src//components/studio/editors/PipelineEditor.vue ====
<template>
    <div class="pipeline-editor">
      <h2>Pipeline Editor</h2>
      <form @submit.prevent="savePipeline">
        <div>
          <label for="name">Name:</label>
          <input type="text" id="name" v-model="pipeline.name" required />
        </div>
        <div>
          <label for="stages">Stages:</label>
          <div v-for="(stage, index) in pipeline.stages" :key="index">
            <input type="text" v-model="stage.name" placeholder="Stage name" />
            <textarea v-model="stage.command" placeholder="Stage command"></textarea>
            <button type="button" @click="removeStage(index)">Remove Stage</button>
          </div>
          <button type="button" @click="addStage">Add Stage</button>
        </div>
        <button type="submit">Save Pipeline</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  
  interface Pipeline {
    name: string;
    stages: Array<{ name: string; command: string }>;
  }
  
  export default defineComponent({
    name: 'PipelineEditor',
    props: {
      data: {
        type: Object as () => Pipeline,
        required: true,
      },
    },
    setup(props) {
      const pipeline = ref<Pipeline>({ 
        name: props.data.name || '',
        stages: props.data.stages || []
      });
  
      const addStage = () => {
        pipeline.value.stages.push({ name: '', command: '' });
      };
  
      const removeStage = (index: number) => {
        pipeline.value.stages.splice(index, 1);
      };
  
      const savePipeline = () => {
        // Implement save logic
        console.log('Saving pipeline:', pipeline.value);
      };
  
      return {
        pipeline,
        addStage,
        removeStage,
        savePipeline,
      };
    },
  });
  </script>==== END OF FILE: frontend/src//components/studio/editors/PipelineEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/DockerFileEditor.vue ====
<template>
    <div class="dockerfile-editor">
      <h2>Dockerfile Editor</h2>
      <form @submit.prevent="saveDockerfile">
        <div>
          <label for="name">Name:</label>
          <input type="text" id="name" v-model="dockerfile.name" required />
        </div>
        <div>
          <label for="content">Content:</label>
          <textarea id="content" v-model="dockerfile.content" rows="20" required></textarea>
        </div>
        <button type="submit">Save Dockerfile</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  
  export default defineComponent({
    name: 'DockerFileEditor',
    props: {
      data: {
        type: Object,
        required: true,
      },
    },
    setup(props) {
      const dockerfile = ref({ ...props.data });
  
      const saveDockerfile = () => {
        // Implement save logic
        console.log('Saving Dockerfile:', dockerfile.value);
      };
  
      return {
        dockerfile,
        saveDockerfile,
      };
    },
  });
  </script>==== END OF FILE: frontend/src//components/studio/editors/DockerFileEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/ConfigurationEditor.vue ====
<template>
    <div class="configuration-editor">
      <h2>Configuration Editor</h2>
      <form @submit.prevent="saveConfiguration">
        <div>
          <label for="name">Name:</label>
          <input type="text" id="name" v-model="config.name" required />
        </div>
        <div>
          <label for="data">Data:</label>
          <textarea id="data" v-model="config.data" rows="10" required></textarea>
        </div>
        <button type="submit">Save Configuration</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  
  export default defineComponent({
    name: 'ConfigurationEditor',
    props: {
      data: {
        type: Object,
        required: true,
      },
    },
    setup(props) {
      const config = ref({ ...props.data });
  
      const saveConfiguration = () => {
        // Implement save logic
        console.log('Saving configuration:', config.value);
      };
  
      return {
        config,
        saveConfiguration,
      };
    },
  });
  </script>==== END OF FILE: frontend/src//components/studio/editors/ConfigurationEditor.vue ====

==== START OF FILE: frontend/src//components/studio/StudioWorkspace.vue ====
<template>
    <div class="studio-workspace">
      <component
        :is="activeComponent"
        v-if="activeComponent"
        :key="activeTabId"
        :data="activeTabData"
      />
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, computed } from 'vue';
  import { useStore } from 'vuex';
  import ConfigurationEditor from '@/components/studio/editors/ConfigurationEditor.vue';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  import DockerFileEditor from '@/components/studio/editors/DockerFileEditor.vue';
  
  export default defineComponent({
    name: 'StudioWorkspace',
    components: {
      ConfigurationEditor,
      PipelineEditor,
      DockerFileEditor,
    },
    setup() {
      const store = useStore();
  
      const activeTabId = computed(() => store.state.studio.activeTabId);
      const activeTab = computed(() => store.getters['studio/activeTab']);
  
      const activeComponent = computed(() => {
        if (!activeTab.value) return null;
        switch (activeTab.value.type) {
          case 'configuration':
            return 'ConfigurationEditor';
          case 'pipeline':
            return 'PipelineEditor';
          case 'dockerFile':
            return 'DockerFileEditor';
          default:
            return null;
        }
      });
  
      const activeTabData = computed(() => activeTab.value?.data || {});
  
      return {
        activeTabId,
        activeComponent,
        activeTabData,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio-workspace {
    flex-grow: 1;
    padding: 1rem;
    overflow-y: auto;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioWorkspace.vue ====

==== START OF FILE: frontend/src//components/studio/StudioSidebar.vue ====
<template>
    <div class="studio-sidebar">
      <h3>Project Explorer</h3>
      <nav>
        <router-link to="/studio/configurations">Configurations</router-link>
        <router-link to="/studio/pipelines">Pipelines</router-link>
        <router-link to="/studio/dockerfiles">Docker Files</router-link>
      </nav>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  import TreeView from '@/components/common/TreeView.vue';
  
  export default defineComponent({
    name: 'StudioSidebar',
    components: { TreeView },
    setup() {
      const projectStructure = ref([
        {
          name: 'Project',
          children: [
            { name: 'Configurations', children: [] },
            { name: 'Pipelines', children: [] },
            { name: 'Docker Files', children: [] },
          ],
        },
      ]);
  
      const handleItemClick = (item: any) => {
        console.log('Clicked item:', item);
        // Implement logic to open the clicked item in the workspace
      };
  
      return { projectStructure, handleItemClick };
    },
  });
  </script>
  
  <style scoped>
  .studio-sidebar {
    width: 250px;
    background-color: #f0f0f0;
    padding: 1rem;
    overflow-y: auto;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioSidebar.vue ====

==== START OF FILE: frontend/src//components/studio/StudioHeader.vue ====
<template>
    <div class="studio-header">
      <div class="tabs">
        <div
          v-for="tab in openTabs"
          :key="tab.id"
          :class="['tab', { active: tab.id === activeTabId }]"
          @click="setActiveTab(tab.id)"
        >
          {{ tab.name }}
          <button class="close-tab" @click.stop="closeTab(tab.id)">&times;</button>
        </div>
      </div>
      <div class="actions">
        <button @click="saveCurrentTab">Save</button>
        <button @click="runCurrentTab">Run</button>
      </div>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, computed } from 'vue';
  import { useStore } from 'vuex';
  
  export default defineComponent({
    name: 'StudioHeader',
    setup() {
      const store = useStore();
  
      const openTabs = computed(() => store.state.studio.openTabs);
      const activeTabId = computed(() => store.state.studio.activeTabId);
  
      const setActiveTab = (tabId: string) => {
        store.commit('studio/setActiveTab', tabId);
      };
  
      const closeTab = (tabId: string) => {
        store.commit('studio/closeTab', tabId);
      };
  
      const saveCurrentTab = () => {
        // Implement save logic
      };
  
      const runCurrentTab = () => {
        // Implement run logic
      };
  
      return {
        openTabs,
        activeTabId,
        setActiveTab,
        closeTab,
        saveCurrentTab,
        runCurrentTab,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background-color: #e0e0e0;
    padding: 0.5rem;
  }
  
  .tabs {
    display: flex;
  }
  
  .tab {
    padding: 0.5rem 1rem;
    background-color: #d0d0d0;
    margin-right: 0.5rem;
    cursor: pointer;
  }
  
  .tab.active {
    background-color: #ffffff;
  }
  
  .close-tab {
    margin-left: 0.5rem;
    border: none;
    background: none;
    cursor: pointer;
  }
  
  .actions button {
    margin-left: 0.5rem;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioHeader.vue ====

==== START OF FILE: frontend/src//components/LoginLogout.vue ====
<template>
    <button @click="toggleLogin">{{ buttonText }}</button>
  </template>
  
  <script lang="ts">
  import { computed, defineComponent } from 'vue'
  import { useStore } from 'vuex'
  
  export default defineComponent({
    setup() {
      const store = useStore()
  
      const isLoggedIn = computed(() => store.getters.isLoggedIn)
      const buttonText = computed(() => isLoggedIn.value ? 'Logout' : 'Login')
  
      const toggleLogin = async () => {
        if (isLoggedIn.value) {
          await store.dispatch('logout')
        } else {
          // For simplicity, we're not handling the login form here.
          // You might want to show a login modal or navigate to a login page.
          console.log('Show login form')
        }
      }
  
      return {
        buttonText,
        toggleLogin
      }
    }
  })
  </script>==== END OF FILE: frontend/src//components/LoginLogout.vue ====

==== START OF FILE: frontend/src//components/Greet.vue ====
<script setup lang="ts">
import { ref } from "vue";
import { invoke } from "@tauri-apps/api/tauri";

const greetMsg = ref("");
const name = ref("");

async function greet() {
  greetMsg.value = await invoke("greet", { name: name.value });
}
</script>

<template>
  <form class="row" @submit.prevent="greet">
    <input id="greet-input" v-model="name" placeholder="Enter a name..." />
    <button type="submit">Greet</button>
  </form>

  <p>{{ greetMsg }}</p>
</template>==== END OF FILE: frontend/src//components/Greet.vue ====

==== START OF FILE: frontend/src//components/common/TreeView.vue ====
<template>
    <ul class="tree-view">
      <li v-for="item in items" :key="item.name">
        <div @click="toggleItem(item)">
          <span v-if="item.children && item.children.length">
            {{ item.expanded ? '' : '' }}
          </span>
          <span @click="$emit('item-click', item)">{{ item.name }}</span>
        </div>
        <TreeView
          v-if="item.children && item.children.length && item.expanded"
          :items="item.children"
          @item-click="$emit('item-click', $event)"
        />
      </li>
    </ul>
  </template>
  
  <script lang="ts">
  import { defineComponent, PropType } from 'vue';
  
  interface TreeItem {
    name: string;
    children?: TreeItem[];
    expanded?: boolean;
  }
  
  export default defineComponent({
    name: 'TreeView',
    props: {
      items: {
        type: Array as PropType<TreeItem[]>,
        required: true,
      },
    },
    emits: ['item-click'],
    methods: {
      toggleItem(item: TreeItem) {
        if (item.children && item.children.length) {
          item.expanded = !item.expanded;
        }
      },
    },
  });
  </script>
  
  <style scoped>
  .tree-view {
    list-style-type: none;
    padding-left: 1rem;
  }
  .tree-view li {
    cursor: pointer;
  }
  </style>==== END OF FILE: frontend/src//components/common/TreeView.vue ====

==== START OF FILE: frontend/src//vite-env.d.ts ====
/// <reference types="vite/client" />

declare module "*.vue" {
  import type { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
==== END OF FILE: frontend/src//vite-env.d.ts ====

==== START OF FILE: frontend/src//config.ts ====
export const API_URL = process.env.NODE_ENV === 'production' ? 'https://your-production-url.com' : 'http://localhost:8000';==== END OF FILE: frontend/src//config.ts ====

==== START OF FILE: frontend/src//views/Login.vue ====
<template>
    <div class="login">
      <h2>Login</h2>
      <form @submit.prevent="login">
        <input v-model="username" type="text" placeholder="Username" required>
        <input v-model="password" type="password" placeholder="Password" required>
        <button type="submit">Login</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  import { useRouter } from 'vue-router';
  import AuthService from '../services/AuthService';
  
  export default defineComponent({
    name: 'Login',
    setup() {
      const username = ref('');
      const password = ref('');
      const router = useRouter();
  
      const login = async () => {
        try {
          const token = await AuthService.login(username.value, password.value);
          localStorage.setItem('token', token);
          router.push('/');
        } catch (error) {
          console.error('Login failed:', error);
          // Handle login error (e.g., show error message)
        }
      };
  
      return { username, password, login };
    }
  });
  </script>==== END OF FILE: frontend/src//views/Login.vue ====

==== START OF FILE: frontend/src//views/Home.vue ====
<template>
    <div class="home">
      <h1>Welcome to FluentCLI Web Services</h1>
      <p>This is the home page.</p>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Home'
  });
  </script>==== END OF FILE: frontend/src//views/Home.vue ====

==== START OF FILE: frontend/src//views/Studio.vue ====
<template>
    <div class="studio">
      <StudioSidebar />
      <div class="studio-main">
        <StudioHeader />
        <router-view></router-view>
      </div>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  import StudioSidebar from '@/components/studio/StudioSidebar.vue';
  import StudioHeader from '@/components/studio/StudioHeader.vue';
  
  export default defineComponent({
    name: 'Studio',
    components: {
      StudioSidebar,
      StudioHeader,
    },
  });
  </script>

  
  <style scoped>
  .studio {
    display: flex;
    height: calc(100vh - 60px);
  }
  
  .studio-main {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
  }
  </style>==== END OF FILE: frontend/src//views/Studio.vue ====

==== START OF FILE: frontend/src//views/admin/JobCreate.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref } from 'vue';
import { useRouter } from 'vue-router';

interface Job {
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const router = useRouter();
const newJob = ref<Job>({
  uri: '',
  config: {},
  worker_type: '',
  // ... initialize other properties
});

const createJob = async () => {
  try {
    await axios.post('/jobs', newJob.value);
    router.push('/admin/jobs'); // Redirect to job list after successful creation
  } catch (error) {
    console.error(error);
    // Handle error, e.g., display an error message to the user
  }
};
</script>

<template>
  <div>
    <h1>Create Job</h1>
    <form @submit.prevent="createJob">
      <label for="uri">URI:</label>
      <input type="text" id="uri" v-model="newJob.uri" />

      <!-- ... input fields for other job properties ... -->

      <button type="submit">Create</button>
    </form>
  </div>
</template>==== END OF FILE: frontend/src//views/admin/JobCreate.vue ====

==== START OF FILE: frontend/src//views/admin/JobList.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref, onMounted } from 'vue';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const jobs = ref<Job[]>([]);

onMounted(async () => {
  try {
    const response = await axios.get('/jobs');
    jobs.value = response.data;
  } catch (error) {
    console.error(error);
    // Handle error, e.g., display an error message to the user
  }
});
</script>

<template>
  <div>
    <h1>Jobs</h1>
    <ul>
      <li v-for="job in jobs" :key="job.id">
        <router-link :to="`/admin/jobs/${job.id}`">{{ job.uri }}</router-link>
      </li>
    </ul>
  </div>
</template>==== END OF FILE: frontend/src//views/admin/JobList.vue ====

==== START OF FILE: frontend/src//views/admin/JobDetails.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref, onMounted } from 'vue';
import { useRoute } from 'vue-router';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const route = useRoute();
const job = ref<Job | null>(null);

onMounted(async () => {
  try {
    const response = await axios.get(`/jobs/${route.params.id}`);
    job.value = response.data;
  } catch (error) {
    console.error(error);
    // Handle error, e.g., display an error message to the user
  }
});
</script>

<template>
  <div v-if="job">
    <h1>Job Details</h1>
    <p>URI: {{ job.uri }}</p>
    <p>Config: {{ job.config }}</p>
    <p>Worker Type: {{ job.worker_type }}</p>
    <!-- ... display other job details ... -->
  </div>
  <div v-else>
    <p>Loading job details...</p>
  </div>
</template>==== END OF FILE: frontend/src//views/admin/JobDetails.vue ====

==== START OF FILE: frontend/src//views/admin/JobEdit.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref, onMounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const route = useRoute();
const router = useRouter();
const job = ref<Job | null>(null);

onMounted(async () => {
  try {
    const response = await axios.get(`/jobs/${route.params.id}`);
    job.value = response.data;
  } catch (error) {
    console.error(error);
    // Handle error, e.g., display an error message to the user
  }
});

const updateJob = async () => {
  try {
    await axios.put(`/jobs/${route.params.id}`, job.value);
    router.push('/admin/jobs'); // Redirect to job list after successful update
  } catch (error) {
    console.error(error);
    // Handle error, e.g., display an error message to the user
  }
};
</script>

<template>
  <div v-if="job">
    <h1>Edit Job</h1>
    <form @submit.prevent="updateJob">
      <label for="uri">URI:</label>
      <input type="text" id="uri" v-model="job.uri" />

      <!-- ... input fields for other job properties ... -->

      <button type="submit">Update</button>
    </form>
  </div>
  <div v-else>
    <p>Loading job details...</p>
  </div>
</template>==== END OF FILE: frontend/src//views/admin/JobEdit.vue ====

==== START OF FILE: frontend/src//views/WorkerTypeList.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref, onMounted } from 'vue';

interface WorkerType {
  id: number;
  name: string;
  // ... other properties
}

const workerTypes = ref<WorkerType[]>([]);

onMounted(async () => {
  try {
    const response = await axios.get('/worker-types'); // Replace with your actual API endpoint
    workerTypes.value = response.data;
  } catch (error) {
    console.error(error);
    // Handle error, e.g., display an error message to the user
  }
});
</script>

<template>
  <div>
    <h1>Worker Types</h1>
    <ul>
      <li v-for="workerType in workerTypes" :key="workerType.id">
        {{ workerType.name }}
      </li>
    </ul>
  </div>
</template>==== END OF FILE: frontend/src//views/WorkerTypeList.vue ====

==== START OF FILE: frontend/src//views/Admin.vue ====
<template>
    <div>
      <h1>Admin</h1>
      <nav>
        <RouterLink to="/admin/jobs">Job List</RouterLink> |
        <RouterLink to="/admin/jobs/create">Create Job</RouterLink> 
      </nav>
      <RouterView />
    </div>
  </template>
  
  <script setup lang="ts">
    import { RouterLink, RouterView } from 'vue-router';

  </script>
  
  <style scoped>
    /* Add your styles here */
  </style>==== END OF FILE: frontend/src//views/Admin.vue ====

==== START OF FILE: frontend/src//services/AuthService.ts ====
import axios from 'axios';
import { API_URL } from '../config';

export default {
  async login(username: string, password: string): Promise<{ token: string, user: any }> {
    const response = await axios.post(`${API_URL}/users/login`, { username, password });
    return response.data;
  },

  logout() {
    localStorage.removeItem('token');
    delete axios.defaults.headers.common['Authorization'];
  },

  setToken(token: string) {
    localStorage.setItem('token', token);
    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
  },
  

  getToken(): string | null {
    return localStorage.getItem('token');
  }
};==== END OF FILE: frontend/src//services/AuthService.ts ====

==== START OF FILE: frontend/src//store/types.ts ====
export interface RootState {
    // Define your root state properties here
    // For example:
    // user: User | null;
    // isAuthenticated: boolean;
  }==== END OF FILE: frontend/src//store/types.ts ====

==== START OF FILE: frontend/src//store/index.ts ====
// src/store/index.ts

import { createStore } from 'vuex'

export default createStore({
  state: {
    isLoggedIn: false,
    user: null
  },
  mutations: {
    setLoggedIn(state, value: boolean) {
      state.isLoggedIn = value
    },
    setUser(state, user) {
      state.user = user
    }
  }
})==== END OF FILE: frontend/src//store/index.ts ====

==== START OF FILE: frontend/src//store/modules/studio.ts ====
import { Module } from 'vuex';
import { RootState } from '../types';

interface StudioState {
  openTabs: Array<{ id: string; name: string; type: string; data: any }>;
  activeTabId: string | null;
}

const studioModule: Module<StudioState, RootState> = {
  namespaced: true,
  state: {
    openTabs: [],
    activeTabId: null,
  },
  mutations: {
    addTab(state, tab) {
      state.openTabs.push(tab);
      state.activeTabId = tab.id;
    },
    closeTab(state, tabId) {
      const index = state.openTabs.findIndex((tab) => tab.id === tabId);
      if (index !== -1) {
        state.openTabs.splice(index, 1);
        if (state.activeTabId === tabId) {
          state.activeTabId = state.openTabs.length > 0 ? state.openTabs[0].id : null;
        }
      }
    },
    setActiveTab(state, tabId) {
      state.activeTabId = tabId;
    },
    updateTabData(state, { tabId, data }) {
      const tab = state.openTabs.find((tab) => tab.id === tabId);
      if (tab) {
        tab.data = data;
      }
    },
  },
  actions: {
    openTab({ commit, state }, { id, name, type, data }) {
      const existingTab = state.openTabs.find((tab) => tab.id === id);
      if (existingTab) {
        commit('setActiveTab', id);
      } else {
        commit('addTab', { id, name, type, data });
      }
    },
  },
  getters: {
    activeTab: (state) => state.openTabs.find((tab) => tab.id === state.activeTabId),
  },
};

export default studioModule;==== END OF FILE: frontend/src//store/modules/studio.ts ====

==== START OF FILE: frontend/src//router/index.ts ====
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router';
import Home from '../views/Home.vue';
import Login from '../views/Login.vue';
import Admin from '../views/Admin.vue';
import Studio from '../views/Studio.vue';
import JobList from '../views/admin/JobList.vue';
import JobDetails from '../views/admin/JobDetails.vue';
import JobCreate from '../views/admin/JobCreate.vue';
import JobEdit from '../views/admin/JobEdit.vue';
import WorkerTypeList from '../views/WorkerTypeList.vue'; // This one remains in the root views folder
import AuthService from '../services/AuthService';

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  {
    path: '/login',
    name: 'Login',
    component: Login
  },
  {
    path: '/admin',
    name: 'Admin',
    component: Admin,
    meta: { requiresAuth: true }
  },
  {
    path: '/studio',
    name: 'Studio',
    component: Studio,
    meta: { requiresAuth: true },
    children: [
      {
        path: 'configurations',
        name: 'Configurations',
        component: () => import('@/components/studio/editors/ConfigurationEditor.vue'),
      },
      {
        path: 'pipelines',
        name: 'Pipelines',
        component: () => import('@/components/studio/editors/PipelineEditor.vue'),
      },
      {
        path: 'dockerfiles',
        name: 'DockerFiles',
        component: () => import('@/components/studio/editors/DockerFileEditor.vue'),
      },
    ],
  },
  { path: '/admin/jobs', name: 'JobList', component: JobList },
  { path: '/admin/jobs/:id', name: 'JobDetails', component: JobDetails },
  { path: '/admin/jobs/create', name: 'JobCreate', component: JobCreate },
  { path: '/admin/jobs/:id/edit', name: 'JobEdit', component: JobEdit },
  { path: '/admin/worker-types', name: 'WorkerTypeList', component: WorkerTypeList },
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

router.beforeEach((to, _, next) => {
  const isAuthenticated = !!AuthService.getToken();
  if (to.matched.some(record => record.meta.requiresAuth) && !isAuthenticated) {
    next('/login');
  } else {
    next();
  }
});

export default router;==== END OF FILE: frontend/src//router/index.ts ====

