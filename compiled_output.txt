==== START OF FILE: src//error.rs ====
// src/error.rs

use thiserror::Error;
use std::error::Error as StdError;
use diesel::r2d2;
use actix_web;
use actix_web::ResponseError;
use actix_web::http::StatusCode;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Database error: {0}")]
    DatabaseError(#[from] diesel::result::Error),

    #[error("Environment variable not found: {0}")]
    EnvVarError(#[from] std::env::VarError),

    #[error("Not found")]
    NotFound,

    #[error("Bad request: {0}")]
    BadRequest(String),

    #[error("R2D2 error: {0}")]
    R2D2Error(#[from] r2d2::PoolError),

    #[error("Unauthorized")]
    Unauthorized,

    #[error("Internal server error")]
    InternalServerError,

    #[error("Generic error: {0}")]
    GenericError(Box<dyn StdError + Send + Sync>),

    #[error("Migration error: {0}")]
    MigrationError(#[from] diesel_migrations::MigrationError),

    #[error("Authentication error")]
    AuthenticationError,

    #[error("Fluent CLI error: {0}")]
    FluentCLIError(String),
}

impl From<Box<dyn StdError + Send + Sync>> for AppError {
    fn from(error: Box<dyn StdError + Send + Sync>) -> Self {
        AppError::GenericError(error)
    }
}

impl ResponseError for AppError {
    fn status_code(&self) -> StatusCode {
        match self {
            AppError::NotFound => StatusCode::NOT_FOUND,
            AppError::BadRequest(_) => StatusCode::BAD_REQUEST,
            AppError::Unauthorized => StatusCode::UNAUTHORIZED,
            AppError::AuthenticationError => StatusCode::UNAUTHORIZED,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    fn error_response(&self) -> actix_web::HttpResponse {
        actix_web::HttpResponse::build(self.status_code())
            .json(serde_json::json!({ "error": self.to_string() }))
    }
}
==== END OF FILE: src//error.rs ====

==== START OF FILE: src//config.rs ====
==== END OF FILE: src//config.rs ====

==== START OF FILE: src//lib.rs ====
pub mod error;
mod db;
mod models;
pub mod schema;
pub mod handlers;
pub mod routes;
pub mod services;
pub mod utils;
==== END OF FILE: src//lib.rs ====

==== START OF FILE: src//utils/error.rs ====
==== END OF FILE: src//utils/error.rs ====

==== START OF FILE: src//utils/encryption.rs ====
use aes::Aes256;
use block_modes::{BlockMode, Cbc};
use block_modes::block_padding::Pkcs7;
use hex;
use rand::Rng;
use std::env;
use std::str;

type Aes256Cbc = Cbc<Aes256, Pkcs7>;

fn get_key() -> Vec<u8> {
    let key = env::var("ENCRYPTION_KEY").expect("ENCRYPTION_KEY must be set");
    hex::decode(key).expect("Invalid ENCRYPTION_KEY")
}

pub fn encrypt_data(data: &str) -> String {
    let key = get_key();
    let iv = rand::thread_rng().gen::<[u8; 16]>();
    let cipher = Aes256Cbc::new_from_slices(&key, &iv).unwrap();
    let ciphertext = cipher.encrypt_vec(data.as_bytes());
    format!("{}:{}", hex::encode(iv), hex::encode(ciphertext))
}

pub fn decrypt_data(encrypted_data: &str) -> String {
    let key = get_key();
    let parts: Vec<&str> = encrypted_data.split(':').collect();
    let iv = hex::decode(parts[0]).unwrap();
    let ciphertext = hex::decode(parts[1]).unwrap();
    let cipher = Aes256Cbc::new_from_slices(&key, &iv).unwrap();
    let decrypted_data = cipher.decrypt_vec(&ciphertext).unwrap();
    str::from_utf8(&decrypted_data).unwrap().to_string()
}==== END OF FILE: src//utils/encryption.rs ====

==== START OF FILE: src//utils/auth.rs ====
use actix_web::{dev::ServiceRequest, Error, HttpMessage};
use actix_web::dev::{Service, Transform};
use futures::future::{ok, Ready};
use futures::Future;
use std::pin::Pin;
use bcrypt::{DEFAULT_COST, hash, verify};
use crate::utils::jwt::validate_token;
use crate::error::AppError;

pub fn hash_password(password: &str) -> Result<String, AppError> {
    hash(password, DEFAULT_COST).map_err(|_| AppError::InternalServerError)
}

pub fn verify_password(password: &str, hash: &str) -> Result<bool, AppError> {
    verify(password, hash).map_err(|_| AppError::InternalServerError)
}

pub struct Auth;

impl<S, B> Transform<S, ServiceRequest> for Auth
where
    S: Service<ServiceRequest, Response = actix_web::dev::ServiceResponse<B>, Error = Error> + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Transform = AuthMiddleware<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ok(AuthMiddleware { service })
    }
}

pub struct AuthMiddleware<S> {
    service: S,
}

impl<S, B> Service<ServiceRequest> for AuthMiddleware<S>
where
    S: Service<ServiceRequest, Response = actix_web::dev::ServiceResponse<B>, Error = Error> + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>>>>;

    fn poll_ready(&self, cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        self.service.poll_ready(cx)
    }

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let auth_header = req.headers().get("Authorization").and_then(|h| h.to_str().ok());

        if let Some(auth_header) = auth_header {
            if auth_header.starts_with("Bearer ") {
                let token = &auth_header[7..];
                match validate_token(token) {
                    Ok(user_id) => {
                        req.extensions_mut().insert(user_id);
                        let fut = self.service.call(req);
                        return Box::pin(async move {
                            let res = fut.await?;
                            Ok(res)
                        });
                    }
                    Err(_) => {
                        return Box::pin(async { Err(actix_web::error::ErrorUnauthorized("Invalid token")) });
                    }
                }
            }
        }

        Box::pin(async { Err(actix_web::error::ErrorUnauthorized("Authorization header missing or malformed")) })
    }
}==== END OF FILE: src//utils/auth.rs ====

==== START OF FILE: src//utils/mod.rs ====
pub mod auth;
pub mod jwt;
pub mod encryption;==== END OF FILE: src//utils/mod.rs ====

==== START OF FILE: src//utils/jwt.rs ====
use crate::error::AppError;
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::env;
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: Uuid,
    exp: usize,
}

pub fn generate_token(user_id: Uuid) -> Result<String, AppError> {
    let expiration = chrono::Utc::now()
        .checked_add_signed(chrono::Duration::hours(24))
        .expect("valid timestamp")
        .timestamp();

    let claims = Claims {
        sub: user_id,
        exp: expiration as usize,
    };

    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(secret.as_bytes()),
    )
    .map_err(|_| AppError::InternalServerError)
}

pub fn validate_token(token: &str) -> Result<Uuid, AppError> {
    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret.as_bytes()),
        &Validation::default(),
    )
    .map_err(|_| AppError::AuthenticationError)?;

    Ok(token_data.claims.sub)
}
==== END OF FILE: src//utils/jwt.rs ====

==== START OF FILE: src//models/docker_file.rs ====
use crate::schema::docker_files;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = docker_files)]
pub struct DockerFile {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub content: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "docker_files"]
pub struct NewDockerFile {
    pub user_id: Uuid,
    pub name: String,
    pub content: String,
}

#[derive(Deserialize, Debug)]
pub struct NewDockerFilePayload {
    pub name: String,
    pub content: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "docker_files"]
pub struct UpdateDockerFile {
    pub name: Option<String>,
    pub content: Option<String>,
}==== END OF FILE: src//models/docker_file.rs ====

==== START OF FILE: src//models/job.rs ====
use crate::schema::jobs;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = jobs)]
pub struct Job {
    pub id: Uuid,
    pub user_id: Uuid,
    pub uri: Uuid,
    pub config: Value,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
    pub results: Option<Value>,
    pub pipeline_id: Uuid,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
}

#[derive(Insertable, Debug)]
#[table_name = "jobs"]
pub struct NewJob {
    pub user_id: Uuid,
    pub uri: Uuid,
    pub config: Value,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
    pub pipeline_id: Uuid,
    pub results: Option<Value>,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "jobs"]
pub struct UpdateJob {
    pub config: Option<Value>,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: Option<String>,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: Option<String>,
    pub results: Option<Value>,
    pub pipeline_id: Option<Uuid>,
}

#[derive(Deserialize, Debug)]
pub struct NewJobPayload {
    pub uri: Option<String>,
    pub config: Value,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
    pub pipeline_id: Uuid,
    pub results: Option<Value>,
}==== END OF FILE: src//models/job.rs ====

==== START OF FILE: src//models/configuration.rs ====
use crate::schema::configurations;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = configurations)]
pub struct Configuration {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}


#[derive(Insertable, Debug)]
#[table_name = "configurations"]
pub struct NewConfiguration {
    pub user_id: Uuid,
    pub name: String,
    pub data: serde_json::Value,
}

#[derive(Deserialize, Debug)]
pub struct NewConfigurationPayload {
    pub name: String,
    pub data: serde_json::Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "configurations"]
pub struct UpdateConfiguration {
    pub name: Option<String>,
    pub data: Option<serde_json::Value>,
}==== END OF FILE: src//models/configuration.rs ====

==== START OF FILE: src//models/worker.rs ====
use crate::schema::workers;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = workers)]
pub struct Worker {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub worker_type: Uuid, // Reference to docker_file ID
    pub active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "workers"]
pub struct NewWorker {
    pub user_id: Uuid,
    pub name: String,
    pub worker_type: Uuid,
    pub active: bool,
}

#[derive(Deserialize, Debug)]
pub struct NewWorkerPayload {
    pub name: String,
    pub worker_type: Uuid,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "workers"]
pub struct UpdateWorker {
    pub name: Option<String>,
    pub worker_type: Option<Uuid>,
    pub active: Option<bool>,
}==== END OF FILE: src//models/worker.rs ====

==== START OF FILE: src//models/user.rs ====
use crate::schema::users;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Serialize, Deserialize)]
#[diesel(table_name = users)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Deserialize)]
pub struct NewUser {
    pub username: String,
    pub email: String,
    pub password: String, // This field is not in the database, but used for user creation
}

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUserDB {
    pub username: String,
    pub email: String,
    pub password_hash: String,
}

#[derive(AsChangeset, Deserialize)]
#[diesel(table_name = users)]
pub struct UpdateUser {
    pub username: Option<String>,
    pub email: Option<String>,
}
==== END OF FILE: src//models/user.rs ====

==== START OF FILE: src//models/active_worker.rs ====
use crate::schema::active_workers;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = active_workers)]
pub struct ActiveWorker {
    pub id: Uuid,
    pub user_id: Uuid,
    pub worker_type: String,
    pub is_active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}==== END OF FILE: src//models/active_worker.rs ====

==== START OF FILE: src//models/amber_store.rs ====
use crate::schema::amber_store;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_yaml::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = amber_store)]
pub struct AmberStore {
    pub id: Uuid,
    pub user_id: Uuid,
    pub data: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
#[derive(Insertable, Debug)]
#[table_name = "amber_store"]
pub struct NewAmberStore {
    pub user_id: Uuid,
    pub data: String,
}

#[derive(Deserialize, Debug)]
pub struct NewAmberStorePayload {
    pub data: serde_yaml::Value,
}

#[derive(AsChangeset, Deserialize, Debug )]
#[table_name = "amber_store"]
pub struct UpdateAmberStore {
    pub data: Option<String>,
}==== END OF FILE: src//models/amber_store.rs ====

==== START OF FILE: src//models/mod.rs ====

pub mod user;
pub mod api_key;
pub mod amber_store;
pub mod secure_vault;
pub mod configuration;
pub mod pipeline;
pub mod docker_file;
pub mod active_worker;
pub mod job;
pub mod worker;==== END OF FILE: src//models/mod.rs ====

==== START OF FILE: src//models/pipeline.rs ====
use crate::schema::pipelines;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = pipelines)]
pub struct Pipeline {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "pipelines"]
pub struct NewPipeline {
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
}

#[derive(Deserialize, Debug)]
pub struct NewPipelinePayload {
    pub name: String,
    pub data: Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "pipelines"]
pub struct UpdatePipeline {
    pub name: Option<String>,
    pub data: Option<Value>,
}==== END OF FILE: src//models/pipeline.rs ====

==== START OF FILE: src//models/secure_vault.rs ====
use crate::schema::secure_vaults;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = secure_vaults)]
pub struct SecureVault {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub encrypted_data: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "secure_vaults"]
pub struct NewSecureVault {
    pub user_id: Uuid,
    pub name: String,
    pub encrypted_data: String,
}

#[derive(Deserialize, Debug)]
pub struct NewSecureVaultPayload {
    pub name: String,
    pub data: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "secure_vaults"]
pub struct UpdateSecureVault {
    pub name: Option<String>,
    pub encrypted_data: Option<String>,
}==== END OF FILE: src//models/secure_vault.rs ====

==== START OF FILE: src//models/api_key.rs ====
use crate::schema::api_keys;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = api_keys)]
pub struct ApiKey {
    pub id: Uuid,
    pub user_id: Uuid,
    pub key_value: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
}
==== END OF FILE: src//models/api_key.rs ====

==== START OF FILE: src//routes.rs ====
use actix_web::{web, HttpResponse, Scope};
use crate::utils::auth::Auth;
use crate::handlers::{user, job, api_key, amber_store, secure_vault, configuration, pipeline, docker_file, worker};

pub fn configure_routes() -> Scope {
    web::scope("")
        // User routes
        .service(
            web::scope("/users")
                .route("", web::post().to(user::create_user))
                .route("", web::get().to(user::list_users))
                .route("/{id}", web::get().to(user::get_user))
                .route("/{id}", web::put().to(user::update_user))
                .route("/{id}", web::delete().to(user::delete_user))
                .route("/login", web::post().to(user::login))
                .route("/refresh", web::post().to(user::refresh_token))
                
        )
        // API Key routes
        .service(
            web::scope("/api_keys")
                .route("", web::post().to(api_key::create_api_key))
                .route("", web::get().to(api_key::list_api_keys))
                .route("/{id}", web::delete().to(api_key::delete_api_key))
        )
        // Job routes
        .service(
            web::scope("/jobs")
                .wrap(Auth)
                    .route("", web::post().to(job::create_job))
                    .route("", web::get().to(job::list_jobs))
                    .route("/{id}", web::get().to(job::get_job))
                    .route("/{id}", web::put().to(job::update_job))
                    .route("/{id}", web::delete().to(job::delete_job))
                    .route("/{id}/start", web::post().to(job::start_job))
                    .route("/{id}/stop", web::post().to(job::stop_job))
                    .route("/{id}/status", web::get().to(job::get_job_status))
                    .route("/{id}/output", web::get().to(job::get_job_output))
                    .route("/{id}/logs", web::get().to(job::get_job_logs))
        )
        // Amber Store routes
        .service(
            web::scope("/amber_store")
            .wrap(Auth)
                .route("", web::post().to(amber_store::create_amber_store))
                .route("", web::get().to(amber_store::list_amber_stores))
                .route("/{id}", web::get().to(amber_store::get_amber_store))
                .route("/{id}", web::put().to(amber_store::update_amber_store))
                .route("/{id}", web::delete().to(amber_store::delete_amber_store))
        )

        // Vault Store routes
        .service(
            web::scope("/secure_vaults")
            .wrap(Auth)
                .route("", web::post().to(secure_vault::create_secure_vault))
                .route("", web::get().to(secure_vault::list_secure_vaults))
                .route("/{id}", web::get().to(secure_vault::get_secure_vault))
                .route("/{id}", web::put().to(secure_vault::update_secure_vault))
                .route("/{id}", web::delete().to(secure_vault::delete_secure_vault))
        )
        // Configuration routes
        .service(
            web::scope("/configurations")
                .wrap(Auth)
                    .route("", web::post().to(configuration::create_configuration))
                    .route("", web::get().to(configuration::list_configurations))
                    .route("/{id}", web::get().to(configuration::get_configuration))
                    .route("/{id}", web::put().to(configuration::update_configuration))
                    .route("/{id}", web::delete().to(configuration::delete_configuration))
        )
        // Pipeline routes
        .service(
            web::scope("/pipelines")
                .wrap(Auth)
                    .route("", web::post().to(pipeline::create_pipeline))
                    .route("", web::get().to(pipeline::list_pipelines))
                    .route("/{id}", web::get().to(pipeline::get_pipeline))
                    .route("/{id}", web::put().to(pipeline::update_pipeline))
                    .route("/{id}", web::delete().to(pipeline::delete_pipeline))
        )
        // Docker File routes
        .service(
            web::scope("/docker_files")
            .wrap(Auth)
                .route("", web::post().to(docker_file::create_docker_file))
                .route("", web::get().to(docker_file::list_docker_files))
                .route("/{id}", web::get().to(docker_file::get_docker_file))
                .route("/{id}", web::put().to(docker_file::update_docker_file))
                .route("/{id}", web::delete().to(docker_file::delete_docker_file))
        )

        // Worker routes
        .service(
            web::scope("/workers")
            .wrap(Auth)
                .route("", web::post().to(worker::create_worker))
                .route("", web::get().to(worker::list_workers))
                .route("/{id}", web::get().to(worker::get_worker))
                .route("/{id}", web::put().to(worker::update_worker))
                .route("/{id}", web::delete().to(worker::delete_worker))
                .route("/{id}/activate", web::post().to(worker::activate_worker))
                .route("/{id}/deactivate", web::post().to(worker::deactivate_worker))
        )
}

==== END OF FILE: src//routes.rs ====

==== START OF FILE: src//schema.rs ====
// @generated automatically by Diesel CLI.

diesel::table! {
    active_workers (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        worker_type -> Varchar,
        is_active -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    amber_store (id) {
        id -> Uuid,
        user_id -> Uuid,
        data -> Text,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    api_keys (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        key_value -> Varchar,
        description -> Nullable<Text>,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        expires_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    configurations (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    docker_files (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        content -> Text,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    jobs (id) {
        id -> Uuid,
        user_id -> Uuid,
        uri -> Uuid,
        config -> Jsonb,
        amber_id -> Nullable<Uuid>,
        state_file_content -> Nullable<Text>,
        data_path -> Nullable<Text>,
        #[max_length = 255]
        worker_type -> Varchar,
        triggers -> Nullable<Jsonb>,
        timers -> Nullable<Jsonb>,
        #[max_length = 255]
        status -> Varchar,
        results -> Nullable<Jsonb>,
        pipeline_id -> Uuid,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        started_at -> Nullable<Timestamptz>,
        completed_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    pipelines (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    secure_vault (id) {
        id -> Uuid,
        user_id -> Uuid,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    secure_vaults (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        encrypted_data -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    users (id) {
        id -> Uuid,
        #[max_length = 255]
        username -> Varchar,
        #[max_length = 255]
        email -> Varchar,
        #[max_length = 255]
        password_hash -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    workers (id) {
        id -> Uuid,
        user_id -> Uuid,
        name -> Varchar,
        worker_type -> Uuid,
        active -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::joinable!(active_workers -> users (user_id));
diesel::joinable!(amber_store -> users (user_id));
diesel::joinable!(api_keys -> users (user_id));
diesel::joinable!(configurations -> users (user_id));
diesel::joinable!(docker_files -> users (user_id));
diesel::joinable!(jobs -> amber_store (amber_id));
diesel::joinable!(jobs -> pipelines (pipeline_id));
diesel::joinable!(jobs -> users (user_id));
diesel::joinable!(pipelines -> users (user_id));
diesel::joinable!(secure_vault -> users (user_id));
diesel::joinable!(secure_vaults -> users (user_id));
diesel::joinable!(workers -> docker_files (worker_type));

diesel::allow_tables_to_appear_in_same_query!(
    active_workers,
    amber_store,
    api_keys,
    configurations,
    docker_files,
    jobs,
    pipelines,
    secure_vault,
    secure_vaults,
    users,
    workers,
);
==== END OF FILE: src//schema.rs ====

==== START OF FILE: src//db/db.rs ====
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool, PoolError};
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use dotenv::dotenv;
use std::env;
use crate::error::AppError;

pub type DbPool = Pool<ConnectionManager<PgConnection>>;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations");

pub fn create_db_pool() -> Result<DbPool, PoolError> {
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    Pool::builder().build(manager)
}

pub fn setup_database(pool: &DbPool) -> Result<(), AppError> {
    let mut conn = pool.get()?;
    conn.run_pending_migrations(MIGRATIONS)?;
    Ok(())
}==== END OF FILE: src//db/db.rs ====

==== START OF FILE: src//db/mod.rs ====
pub mod db;

pub use db::{create_db_pool, setup_database, DbPool};==== END OF FILE: src//db/mod.rs ====

==== START OF FILE: src//main.rs ====
mod db;
mod error;
mod models;
mod schema;
mod routes;
mod handlers;
mod services;
mod utils;
use dotenv::dotenv;

use actix_web::{App, HttpServer, http, middleware, web};
use actix_cors::Cors;

use db::{create_db_pool, setup_database};
use routes::configure_routes;


#[actix_web::main]
async fn main() -> std::io::Result<()> {
    std::env::set_var("RUST_LOG", "debug"); //remove at release
    dotenv().ok();
    env_logger::init();

    // Set up the database
    let pool = create_db_pool().expect("Failed to create database pool");
    setup_database(&pool).expect("Failed to set up database");
    println!("Database setup complete");


    HttpServer::new(move || {
        let cors = Cors::default()
            .allow_any_origin() // Be cautious with this in production environments
            .allowed_methods(vec!["GET", "POST", "PUT", "DELETE", "OPTIONS"])
            .allowed_headers(vec![http::header::AUTHORIZATION, http::header::ACCEPT])
            .allowed_headers(vec![
                http::header::AUTHORIZATION,
                http::header::ACCEPT,
                http::header::CONTENT_TYPE,
            ])
            .supports_credentials()
            .max_age(3600);

        App::new()
            .wrap(cors)
            .wrap(middleware::Logger::default())
            .app_data(web::Data::new(pool.clone()))
            .service(configure_routes())
    })



    .bind("0.0.0.0:8000")?
    .run()
    .await
}==== END OF FILE: src//main.rs ====

==== START OF FILE: src//handlers/docker_file.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::docker_file_service::DockerFileService;
use crate::models::docker_file::{NewDockerFile, UpdateDockerFile, NewDockerFilePayload};

pub async fn create_docker_file(
    pool: web::Data<DbPool>,
    new_docker_file_payload: web::Json<NewDockerFilePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating docker file for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_docker_file_payload);

    let new_docker_file = NewDockerFile {
        user_id,
        name: new_docker_file_payload.name.clone(),
        content: new_docker_file_payload.content.clone(),
    };
    match DockerFileService::create_docker_file(&pool, new_docker_file) {
        Ok(docker_file) => {
            log::info!("Docker file created successfully: {:?}", docker_file);
            HttpResponse::Created().json(docker_file)
        },
        Err(e) => {
            log::error!("Error creating docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create docker file")
        }
    }
}

pub async fn list_docker_files(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::list_docker_files(&pool, user_id) {
        Ok(docker_files) => HttpResponse::Ok().json(docker_files),
        Err(e) => {
            log::error!("Error listing docker files: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list docker files")
        }
    }
}

pub async fn get_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::get_docker_file(&pool, docker_file_id.into_inner(), user_id) {
        Ok(docker_file) => HttpResponse::Ok().json(docker_file),
        Err(e) => {
            log::error!("Error getting docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get docker file")
        }
    }
}

pub async fn update_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    update_data: web::Json<UpdateDockerFile>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::update_docker_file(&pool, docker_file_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(docker_file) => HttpResponse::Ok().json(docker_file),
        Err(e) => {
            log::error!("Error updating docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update docker file")
        }
    }
}

pub async fn delete_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::delete_docker_file(&pool, docker_file_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete docker file")
        }
    }
}==== END OF FILE: src//handlers/docker_file.rs ====

==== START OF FILE: src//handlers/job.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::job_service::JobService;
use crate::models::job::{NewJob, UpdateJob, NewJobPayload};

pub async fn create_job(
    pool: web::Data<DbPool>,
    new_job_payload: web::Json<NewJobPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    
    // Always generate a new UUID for uri
    let uri = Uuid::new_v4();

    // First, check if the pipeline exists
    match JobService::pipeline_exists(&pool, new_job_payload.pipeline_id, user_id) {
        Ok(true) => {
            let new_job = NewJob {
                user_id,
                uri,
                config: new_job_payload.config.clone(),
                amber_id: new_job_payload.amber_id,
                state_file_content: new_job_payload.state_file_content.clone(),
                data_path: new_job_payload.data_path.clone(),
                worker_type: new_job_payload.worker_type.clone(),
                triggers: new_job_payload.triggers.clone(),
                timers: new_job_payload.timers.clone(),
                status: new_job_payload.status.clone(),
                pipeline_id: new_job_payload.pipeline_id,
                results: new_job_payload.results.clone(),
            };

            match JobService::create_job(&pool, new_job) {
                Ok(job) => HttpResponse::Created().json(job),
                Err(e) => {
                    log::error!("Error creating job: {:?}", e);
                    HttpResponse::InternalServerError().json(format!("Failed to create job: {:?}", e))
                }
            }
        },
        Ok(false) => {
            log::error!("Pipeline not found: {:?}", new_job_payload.pipeline_id);
            HttpResponse::BadRequest().json("Invalid pipeline_id")
        },
        Err(e) => {
            log::error!("Error checking pipeline existence: {:?}", e);
            HttpResponse::InternalServerError().json(format!("Failed to check pipeline existence: {:?}", e))
        }
    }
}

pub async fn list_jobs(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::list_jobs(&pool, user_id) {
        Ok(jobs) => HttpResponse::Ok().json(jobs),
        Err(e) => {
            log::error!("Error listing jobs: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list jobs")
        }
    }
}

pub async fn get_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error getting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job")
        }
    }
}

pub async fn update_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    update_data: web::Json<UpdateJob>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::update_job(&pool, job_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error updating job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update job")
        }
    }
}

pub async fn delete_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::delete_job(&pool, job_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete job")
        }
    }
}

pub async fn start_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::start_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error starting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to start job")
        }
    }
}

pub async fn stop_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::stop_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error stopping job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to stop job")
        }
    }
}

pub async fn get_job_status(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_status(&pool, job_id.into_inner(), user_id) {
        Ok(status) => HttpResponse::Ok().json(status),
        Err(e) => {
            log::error!("Error getting job status: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job status")
        }
    }
}

pub async fn get_job_output(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_output(&pool, job_id.into_inner(), user_id) {
        Ok(output) => HttpResponse::Ok().json(output),
        Err(e) => {
            log::error!("Error getting job output: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job output")
        }
    }
}

pub async fn get_job_logs(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_logs(&pool, job_id.into_inner(), user_id) {
        Ok(logs) => HttpResponse::Ok().json(logs),
        Err(e) => {
            log::error!("Error getting job logs: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job logs")
        }
    }
}==== END OF FILE: src//handlers/job.rs ====

==== START OF FILE: src//handlers/configuration.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::configuration_service::ConfigurationService;
use crate::models::configuration::{NewConfiguration, UpdateConfiguration, NewConfigurationPayload};

pub async fn create_configuration(
    pool: web::Data<DbPool>,
    new_configuration_payload: web::Json<NewConfigurationPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating configuration for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_configuration_payload);

    let new_configuration = NewConfiguration {
        user_id,
        name: new_configuration_payload.name.clone(),
        data: new_configuration_payload.data.clone(),
    };
    match ConfigurationService::create_configuration(&pool, new_configuration) {
        Ok(configuration) => {
            log::info!("Configuration created successfully: {:?}", configuration);
            HttpResponse::Created().json(configuration)
        },
        Err(e) => {
            log::error!("Error creating configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create configuration")
        }
    }
}

pub async fn list_configurations(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::list_configurations(&pool, user_id) {
        Ok(configurations) => HttpResponse::Ok().json(configurations),
        Err(e) => {
            log::error!("Error listing configurations: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list configurations")
        }
    }
}

pub async fn get_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::get_configuration(&pool, configuration_id.into_inner(), user_id) {
        Ok(configuration) => HttpResponse::Ok().json(configuration),
        Err(e) => {
            log::error!("Error getting configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get configuration")
        }
    }
}

pub async fn update_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    update_data: web::Json<UpdateConfiguration>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::update_configuration(&pool, configuration_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(configuration) => HttpResponse::Ok().json(configuration),
        Err(e) => {
            log::error!("Error updating configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update configuration")
        }
    }
}

pub async fn delete_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::delete_configuration(&pool, configuration_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete configuration")
        }
    }
}==== END OF FILE: src//handlers/configuration.rs ====

==== START OF FILE: src//handlers/worker.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::worker_service::WorkerService;
use crate::models::worker::{NewWorker, UpdateWorker, NewWorkerPayload};


pub async fn create_worker(
    pool: web::Data<DbPool>,
    new_worker_payload: web::Json<NewWorkerPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating worker for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_worker_payload);

    let new_worker = NewWorker {
        user_id,
        name: new_worker_payload.name.clone(),
        worker_type: new_worker_payload.worker_type,
        active: false,
    };
    log::info!("New worker data: {:?}", new_worker);

    match WorkerService::create_worker(&pool, new_worker) {
        Ok(worker) => {
            log::info!("Worker created successfully: {:?}", worker);
            HttpResponse::Created().json(worker)
        },
        Err(e) => {
            log::error!("Error creating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create worker")
        }
    }
}

pub async fn list_workers(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::list_workers(&pool, user_id) {
        Ok(workers) => HttpResponse::Ok().json(workers),
        Err(e) => {
            log::error!("Error listing workers: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list workers")
        }
    }
}

pub async fn get_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::get_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error getting worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get worker")
        }
    }
}

pub async fn update_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    update_data: web::Json<UpdateWorker>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::update_worker(&pool, worker_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error updating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update worker")
        }
    }
}

pub async fn delete_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::delete_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete worker")
        }
    }
}

pub async fn activate_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::activate_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error activating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to activate worker")
        }
    }
}

pub async fn deactivate_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::deactivate_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error deactivating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to deactivate worker")
        }
    }
}==== END OF FILE: src//handlers/worker.rs ====

==== START OF FILE: src//handlers/user.rs ====
use crate::models::user::{NewUser, UpdateUser};
use crate::error::AppError;

use actix_web::{web, HttpResponse, Responder, Error};
use crate::db::DbPool;
use serde_json::json; 
use uuid::Uuid;





use crate::services::user_service::UserService;
use crate::utils::jwt::generate_token;
use serde::{Deserialize};

#[derive(Deserialize)]
pub struct LoginRequest {
    username: String,
    password: String,
}


pub async fn create_user(
    pool: web::Data<DbPool>,
    new_user: web::Json<NewUser>,
) -> Result<HttpResponse, AppError> {
    if UserService::email_exists(&pool, &new_user.email)? {
        return Err(AppError::BadRequest("Email already in use".into()));
    }

    let user = UserService::create_user(&pool, new_user.into_inner())?;
    Ok(HttpResponse::Created().json(user))
}

pub async fn login(
    pool: web::Data<DbPool>,
    login_req: web::Json<LoginRequest>,
) -> Result<HttpResponse, Error> {
    match UserService::login(&pool, &login_req.username, &login_req.password) {
        Ok(user) => {
            match generate_token(user.id) {
                Ok(token) => Ok(HttpResponse::Ok().json(json!({ "token": token, "user": user }))),
                Err(e) => {
                    log::error!("Token generation error: {:?}", e);
                    Err(actix_web::error::ErrorInternalServerError("Failed to generate token"))
                }
            }
        },
        Err(e) => {
            log::error!("Login error: {:?}", e);
            match e {
                AppError::AuthenticationError => Err(actix_web::error::ErrorUnauthorized("Invalid credentials")),
                _ => Err(actix_web::error::ErrorInternalServerError("Login failed"))
            }
        }
    }
}

pub async fn list_users(pool: web::Data<DbPool>) -> Result<HttpResponse, Error> {
    match UserService::list_users(&pool) {
        Ok(users) => Ok(HttpResponse::Ok().json(users)),
        Err(e) => {
            log::error!("Error listing users: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to list users"))
        }
    }
}

use actix_web::HttpRequest;

pub async fn get_user(
    req: HttpRequest,
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
) -> Result<HttpResponse, Error> {
    log::info!("Received GET user request. User ID: {:?}, Headers: {:?}", user_id, req.headers());
    match UserService::get_user(&pool, user_id.into_inner()) {
        Ok(user) => Ok(HttpResponse::Ok().json(user)),
        Err(e) => {
            log::error!("Error getting user: {:?}", e);
            match e {
                AppError::NotFound => Err(actix_web::error::ErrorNotFound("User not found")),
                _ => Err(actix_web::error::ErrorInternalServerError("Failed to get user"))
            }
        }
    }
}

pub async fn update_user(
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
    user_data: web::Json<UpdateUser>,
) -> Result<HttpResponse, Error> {
    match UserService::update_user(&pool, user_id.into_inner(), user_data.into_inner()) {
        Ok(user) => Ok(HttpResponse::Ok().json(user)),
        Err(e) => {
            log::error!("Error updating user: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to update user"))
        }
    }
}

pub async fn delete_user(
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
) -> Result<HttpResponse, Error> {
    match UserService::delete_user(&pool, user_id.into_inner()) {
        Ok(_) => Ok(HttpResponse::NoContent().finish()),
        Err(e) => {
            log::error!("Error deleting user: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to delete user"))
        }
    }
}

pub async fn refresh_token(pool: web::Data<DbPool>, token: web::Json<String>) -> impl Responder {
    match UserService::refresh_token(&pool, &token.into_inner()) {
        Ok(new_token) => HttpResponse::Ok().json(serde_json::json!({ "token": new_token })),
        Err(_) => HttpResponse::Unauthorized().json(serde_json::json!({ "error": "Invalid token" })),
    }
}

==== END OF FILE: src//handlers/user.rs ====

==== START OF FILE: src//handlers/amber_store.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::amber_store_service::AmberStoreService;
use crate::models::amber_store::{NewAmberStore, UpdateAmberStore, NewAmberStorePayload};
use crate::error::AppError;
use diesel::prelude::*;
use diesel::QueryDsl;
use diesel::ExpressionMethods;
use serde_yaml::Value;

pub async fn create_amber_store(
    pool: web::Data<DbPool>,
    new_amber_store_payload: web::Json<NewAmberStorePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    
    let new_amber_store = NewAmberStore {
        user_id,
        data: serde_yaml::to_string(&new_amber_store_payload.data).unwrap(),
    };

    match AmberStoreService::create_amber_store(&pool, new_amber_store) {
        Ok(amber_store) => HttpResponse::Created().json(amber_store),
        Err(e) => {
            log::error!("Error creating amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create amber store")
        }
    }
}

pub async fn list_amber_stores(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::list_amber_stores(&pool, user_id) {
        Ok(amber_stores) => HttpResponse::Ok().json(amber_stores),
        Err(e) => {
            log::error!("Error listing amber stores: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list amber stores")
        }
    }
}

pub async fn get_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::get_amber_store(&pool, amber_store_id.into_inner(), user_id) {
        Ok(amber_store) => HttpResponse::Ok().json(amber_store),
        Err(e) => {
            log::error!("Error getting amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get amber store")
        }
    }
}

pub async fn update_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    update_data: web::Json<UpdateAmberStore>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    
    let yaml_string = match &update_data.data {
        Some(data) => {
            match serde_yaml::from_str::<serde_yaml::Value>(data) {
                Ok(yaml_value) => serde_yaml::to_string(&yaml_value).unwrap_or_default(),
                Err(e) => {
                    log::error!("Error parsing YAML: {:?}", e);
                    return HttpResponse::BadRequest().body("Invalid YAML data");
                }
            }
        },
        None => String::new(),
    };

    let update_data = UpdateAmberStore {
        data: Some(yaml_string),
    };

    match AmberStoreService::update_amber_store(&pool, amber_store_id.into_inner(), update_data, user_id) {
        Ok(amber_store) => HttpResponse::Ok().json(amber_store),
        Err(e) => {
            log::error!("Error updating amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update amber store")
        }
    }
}

pub async fn delete_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::delete_amber_store(&pool, amber_store_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete amber store")
        }
    }
}==== END OF FILE: src//handlers/amber_store.rs ====

==== START OF FILE: src//handlers/mod.rs ====
pub mod user;
pub mod job;
pub mod api_key;
pub mod amber_store;
pub mod secure_vault;
pub mod configuration;
pub mod pipeline;
pub mod docker_file;
pub mod worker;==== END OF FILE: src//handlers/mod.rs ====

==== START OF FILE: src//handlers/pipeline.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::pipeline_service::PipelineService;
use crate::models::pipeline::{NewPipeline, UpdatePipeline, NewPipelinePayload};

pub async fn create_pipeline(
    pool: web::Data<DbPool>,
    new_pipeline_payload: web::Json<NewPipelinePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating pipeline for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_pipeline_payload);

    let new_pipeline = NewPipeline {
        user_id,
        name: new_pipeline_payload.name.clone(),
        data: new_pipeline_payload.data.clone(),
    };
    match PipelineService::create_pipeline(&pool, new_pipeline) {
        Ok(pipeline) => {
            log::info!("Pipeline created successfully: {:?}", pipeline);
            HttpResponse::Created().json(pipeline)
        },
        Err(e) => {
            log::error!("Error creating pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create pipeline")
        }
    }
}

pub async fn list_pipelines(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::list_pipelines(&pool, user_id) {
        Ok(pipelines) => HttpResponse::Ok().json(pipelines),
        Err(e) => {
            log::error!("Error listing pipelines: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list pipelines")
        }
    }
}

pub async fn get_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::get_pipeline(&pool, pipeline_id.into_inner(), user_id) {
        Ok(pipeline) => HttpResponse::Ok().json(pipeline),
        Err(e) => {
            log::error!("Error getting pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get pipeline")
        }
    }
}

pub async fn update_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    update_data: web::Json<UpdatePipeline>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::update_pipeline(&pool, pipeline_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(pipeline) => HttpResponse::Ok().json(pipeline),
        Err(e) => {
            log::error!("Error updating pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update pipeline")
        }
    }
}

pub async fn delete_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::delete_pipeline(&pool, pipeline_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete pipeline")
        }
    }
}==== END OF FILE: src//handlers/pipeline.rs ====

==== START OF FILE: src//handlers/secure_vault.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::secure_vault_service::SecureVaultService;
use crate::models::secure_vault::{NewSecureVault, UpdateSecureVault, NewSecureVaultPayload};
use crate::utils::encryption::encrypt_data;

pub async fn create_secure_vault(
    pool: web::Data<DbPool>,
    new_secure_vault_payload: web::Json<NewSecureVaultPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating secure vault for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_secure_vault_payload);

    let encrypted_data = encrypt_data(&new_secure_vault_payload.data);
    let new_secure_vault = NewSecureVault {
        user_id,
        name: new_secure_vault_payload.name.clone(),
        encrypted_data,
    };
    log::info!("New secure vault data: {:?}", new_secure_vault);

    match SecureVaultService::create_secure_vault(&pool, new_secure_vault) {
        Ok(secure_vault) => {
            log::info!("Secure vault created successfully: {:?}", secure_vault);
            HttpResponse::Created().json(secure_vault)
        },
        Err(e) => {
            log::error!("Error creating secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create secure vault")
        }
    }
}

pub async fn list_secure_vaults(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::list_secure_vaults(&pool, user_id) {
        Ok(secure_vaults) => HttpResponse::Ok().json(secure_vaults),
        Err(e) => {
            log::error!("Error listing secure vaults: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list secure vaults")
        }
    }
}

pub async fn get_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::get_secure_vault(&pool, secure_vault_id.into_inner(), user_id) {
        Ok(secure_vault) => HttpResponse::Ok().json(secure_vault),
        Err(e) => {
            log::error!("Error getting secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get secure vault")
        }
    }
}

pub async fn update_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    update_data: web::Json<UpdateSecureVault>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::update_secure_vault(&pool, secure_vault_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(secure_vault) => HttpResponse::Ok().json(secure_vault),
        Err(e) => {
            log::error!("Error updating secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update secure vault")
        }
    }
}

pub async fn delete_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::delete_secure_vault(&pool, secure_vault_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete secure vault")
        }
    }
}==== END OF FILE: src//handlers/secure_vault.rs ====

==== START OF FILE: src//handlers/api_key.rs ====
use actix_web::{web, HttpResponse, Responder};

pub async fn create_api_key() -> impl Responder {
    HttpResponse::Ok().body("Create API key")
}

pub async fn list_api_keys() -> impl Responder {
    HttpResponse::Ok().body("List API keys")
}

pub async fn delete_api_key() -> impl Responder {
    HttpResponse::Ok().body("Delete API key")
}
==== END OF FILE: src//handlers/api_key.rs ====

==== START OF FILE: src//services/fluentcli_service.rs ====
use crate::error::AppError;
use std::process::Command;

pub struct FluentCLIService;

impl FluentCLIService {
    pub fn execute_command(&self, command: &str) -> Result<String, AppError> {
        let output = Command::new("fluentcli")
            .args(command.split_whitespace())
            .output()
            .map_err(|e| AppError::FluentCLIError(e.to_string()))?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(AppError::FluentCLIError(String::from_utf8_lossy(&output.stderr).to_string()))
        }
    }
}==== END OF FILE: src//services/fluentcli_service.rs ====

==== START OF FILE: src//services/worker_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::worker::{Worker, NewWorker, UpdateWorker};
use diesel::prelude::*;
use uuid::Uuid;

pub struct WorkerService;

impl WorkerService {
    pub fn create_worker(pool: &DbPool, new_worker: NewWorker) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new worker into database: {:?}", new_worker);
        match diesel::insert_into(workers)
            .values(&new_worker)
            .get_result(conn) {
            Ok(worker) => {
                log::info!("Worker inserted into database: {:?}", worker);
                Ok(worker)
            },
            Err(e) => {
                log::error!("Error inserting worker into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_workers(pool: &DbPool, user_id: Uuid) -> Result<Vec<Worker>, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        workers.filter(user_id.eq(user_id)).load::<Worker>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        workers.filter(id.eq(worker_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_worker(pool: &DbPool, worker_id: Uuid, update_data: UpdateWorker, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }

    pub fn activate_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(active.eq(true))
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn deactivate_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(active.eq(false))
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
}==== END OF FILE: src//services/worker_service.rs ====

==== START OF FILE: src//services/configuration_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::configuration::{Configuration, NewConfiguration, UpdateConfiguration};
use diesel::prelude::*;
use uuid::Uuid;

pub struct ConfigurationService;

impl ConfigurationService {
    pub fn create_configuration(pool: &DbPool, new_configuration: NewConfiguration) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new configuration into database: {:?}", new_configuration);
        diesel::insert_into(configurations)
            .values(&new_configuration)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_configurations(pool: &DbPool, user_id: Uuid) -> Result<Vec<Configuration>, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        configurations.filter(user_id.eq(user_id)).load::<Configuration>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_configuration(pool: &DbPool, configuration_id: Uuid, user_id: Uuid) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_configuration(pool: &DbPool, configuration_id: Uuid, update_data: UpdateConfiguration, user_id: Uuid) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_configuration(pool: &DbPool, configuration_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/configuration_service.rs ====

==== START OF FILE: src//services/docker_file_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::docker_file::{DockerFile, NewDockerFile, UpdateDockerFile};
use diesel::prelude::*;
use uuid::Uuid;

pub struct DockerFileService;

impl DockerFileService {
    pub fn create_docker_file(pool: &DbPool, new_docker_file: NewDockerFile) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new docker file into database: {:?}", new_docker_file);
        diesel::insert_into(docker_files)
            .values(&new_docker_file)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_docker_files(pool: &DbPool, user_id: Uuid) -> Result<Vec<DockerFile>, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        docker_files.filter(user_id.eq(user_id)).load::<DockerFile>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_docker_file(pool: &DbPool, docker_file_id: Uuid, user_id: Uuid) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_docker_file(pool: &DbPool, docker_file_id: Uuid, update_data: UpdateDockerFile, user_id: Uuid) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_docker_file(pool: &DbPool, docker_file_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/docker_file_service.rs ====

==== START OF FILE: src//services/pipeline_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::pipeline::{Pipeline, NewPipeline, UpdatePipeline};
use diesel::prelude::*;
use uuid::Uuid;

pub struct PipelineService;

impl PipelineService {
    pub fn create_pipeline(pool: &DbPool, new_pipeline: NewPipeline) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new pipeline into database: {:?}", new_pipeline);
        diesel::insert_into(pipelines)
            .values(&new_pipeline)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_pipelines(pool: &DbPool, user_id: Uuid) -> Result<Vec<Pipeline>, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        pipelines.filter(user_id.eq(user_id)).load::<Pipeline>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_pipeline(pool: &DbPool, pipeline_id: Uuid, user_id: Uuid) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_pipeline(pool: &DbPool, pipeline_id: Uuid, update_data: UpdatePipeline, user_id: Uuid) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_pipeline(pool: &DbPool, pipeline_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/pipeline_service.rs ====

==== START OF FILE: src//services/mod.rs ====
pub mod job_service;
pub mod fluentcli_service;
pub mod user_service;
pub mod amber_store_service;
pub mod configuration_service;
pub mod docker_file_service;
pub mod pipeline_service;
pub mod worker_service;
pub mod secure_vault_service;==== END OF FILE: src//services/mod.rs ====

==== START OF FILE: src//services/secure_vault_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::secure_vault::{SecureVault, NewSecureVault, UpdateSecureVault};
use diesel::prelude::*;
use uuid::Uuid;

pub struct SecureVaultService;

impl SecureVaultService {
    pub fn create_secure_vault(pool: &DbPool, new_secure_vault: NewSecureVault) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new secure vault into database: {:?}", new_secure_vault);
        match diesel::insert_into(secure_vaults)
            .values(&new_secure_vault)
            .get_result(conn) {
            Ok(secure_vault) => {
                log::info!("Secure vault inserted into database: {:?}", secure_vault);
                Ok(secure_vault)
            },
            Err(e) => {
                log::error!("Error inserting secure vault into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_secure_vaults(pool: &DbPool, user_id: Uuid) -> Result<Vec<SecureVault>, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Listing secure vaults for user_id: {:?}", user_id);
        secure_vaults.filter(user_id.eq(user_id))
            .load::<SecureVault>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_secure_vault(pool: &DbPool, secure_vault_id: Uuid, user_id: Uuid) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Getting secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id)))
            .first::<SecureVault>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_secure_vault(pool: &DbPool, secure_vault_id: Uuid, update_data: UpdateSecureVault, user_id: Uuid) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Updating secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        diesel::update(secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_secure_vault(pool: &DbPool, secure_vault_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Deleting secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        diesel::delete(secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map(|_| ())
            .map_err(AppError::DatabaseError)
    }
}==== END OF FILE: src//services/secure_vault_service.rs ====

==== START OF FILE: src//services/amber_store_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::amber_store::{AmberStore, NewAmberStore, UpdateAmberStore};
use diesel::{prelude::*, update};
use uuid::Uuid;

pub struct AmberStoreService;

impl AmberStoreService {
    pub fn create_amber_store(pool: &DbPool, new_amber_store: NewAmberStore) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::insert_into(amber_store)
            .values(&new_amber_store)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_amber_stores(pool: &DbPool, user_id: Uuid) -> Result<Vec<AmberStore>, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        amber_store.filter(user_id.eq(user_id)).load::<AmberStore>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_amber_store(pool: &DbPool, amber_store_id: Uuid, user_id: Uuid) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_amber_store(pool: &DbPool, amber_store_id: Uuid, update_data: UpdateAmberStore, user_id: Uuid) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        log::error!("Update amber data: {:#?}", &update_data);
        diesel::update(amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_amber_store(pool: &DbPool, amber_store_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/amber_store_service.rs ====

==== START OF FILE: src//services/user_service.rs ====
use std::fmt::Debug;
use actix_web::HttpMessage;
use chrono::Utc;
use crate::db::DbPool;
use crate::error::AppError;
use crate::utils::auth::{hash_password, verify_password};
use crate::models::user::{NewUser, User, UpdateUser, NewUserDB};
use diesel::prelude::*;
use uuid::Uuid;
use crate::utils::jwt;

pub struct UserService;

impl UserService {
    pub fn create_user(pool: &DbPool, new_user: NewUser) -> Result<User, AppError> {
        use crate::schema::users;
        let conn = &mut pool.get()?;
    
        let hashed_password = hash_password(&new_user.password)?;
        let new_user_db = NewUserDB {
            username: new_user.username,
            email: new_user.email,
            password_hash: hashed_password, // Use password_hash field
        };
    
        diesel::insert_into(users::table)
            .values(&new_user_db) // Use new_user_db for insertion
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn login(pool: &DbPool, username: &str, password: &str) -> Result<User, AppError> {
        let user = Self::get_user_by_username(pool, username.to_string())?;
        match verify_password(password, &user.password_hash) {
            Ok(is_valid) => {
                if is_valid {
                    Ok(user)
                } else {
                    Err(AppError::AuthenticationError)
                }
            },
            Err(e) => {
                log::error!("Password verification error: {:?}", e);
                Err(AppError::InternalServerError)
            }
        }
    }

    pub fn get_user_by_username(pool: &DbPool, username_: String) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;

        let conn = &mut pool.get()?;
        
        users
            .filter(username.eq(username_))
            .first(conn)
            .map_err(|error| {
                if error == diesel::result::Error::NotFound {
                    AppError::NotFound
                } else {
                    AppError::DatabaseError(error)
                }
            })
    }


    pub fn get_user(pool: &DbPool, user_id: Uuid) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Received GET user request. User ID: {:?},", user_id);
        users.find(user_id)
            .first(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn update_user(pool: &DbPool, user_id: Uuid, update_data: UpdateUser) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(users.find(user_id))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn delete_user(pool: &DbPool, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(users.find(user_id))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }

    pub fn email_exists(pool: &DbPool, email: &str) -> Result<bool, AppError> {
        use crate::schema::users::dsl::*;
        
        let conn = &mut pool.get()?;
        let count = users.filter(email.eq(email))
                         .count()
                         .get_result::<i64>(conn)?;
        
        Ok(count > 0)
    }

    pub fn list_users(pool: &DbPool) -> Result<Vec<User>, AppError> {
        use crate::schema::users::dsl::*; // Add this line to import users
        let conn = &mut pool.get()?;
        users.load::<User>(conn).map_err(AppError::DatabaseError)
    }

    pub fn refresh_token(pool: &DbPool, token: &str) -> Result<String, AppError> {
        let user_id = jwt::validate_token(token)?;
        let user = Self::get_user(pool, user_id)?;
        jwt::generate_token(user.id)
    }

    
}
==== END OF FILE: src//services/user_service.rs ====

==== START OF FILE: src//services/job_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::job::{Job, NewJob, UpdateJob};
use diesel::prelude::*;
use uuid::Uuid;

pub struct JobService;

impl JobService {
    pub fn create_job(pool: &DbPool, new_job: NewJob) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new job into database: {:?}", new_job);
        match diesel::insert_into(jobs)
            .values(&new_job)
            .get_result(conn) {
            Ok(job) => {
                log::info!("Job inserted into database: {:?}", job);
                Ok(job)
            },
            Err(e) => {
                log::error!("Error inserting job into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_jobs(pool: &DbPool, user_id: Uuid) -> Result<Vec<Job>, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Listing jobs for user_id: {:?}", user_id);
        jobs.filter(user_id.eq(user_id))
            .load::<Job>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Getting job with id: {:?} for user_id: {:?}", job_id, user_id);
        jobs.filter(id.eq(job_id).and(user_id.eq(user_id)))
            .first::<Job>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_job(pool: &DbPool, job_id: Uuid, update_data: UpdateJob, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Updating job with id: {:?} for user_id: {:?}", job_id, user_id);
        diesel::update(jobs.filter(id.eq(job_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Deleting job with id: {:?} for user_id: {:?}", job_id, user_id);
        diesel::delete(jobs.filter(id.eq(job_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map(|_| ())
            .map_err(AppError::DatabaseError)
    }

    pub fn pipeline_exists(pool: &DbPool, pipeline_id: Uuid, user_id: Uuid) -> Result<bool, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        let exists = diesel::select(diesel::dsl::exists(
            pipelines
                .filter(id.eq(pipeline_id))
                .filter(user_id.eq(user_id))
        ))
        .get_result(conn)?;
        Ok(exists)
    }

    pub fn start_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        // Implement the logic to start a job
        unimplemented!()
    }

    pub fn stop_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        // Implement the logic to stop a job
        unimplemented!()
    }

    pub fn get_job_status(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the status of a job
        unimplemented!()
    }

    pub fn get_job_output(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the output of a job
        unimplemented!()
    }

    pub fn get_job_logs(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the logs of a job
        unimplemented!()
    }
}==== END OF FILE: src//services/job_service.rs ====

==== START OF FILE: frontend/src//App.vue ====
<template>
  <div id="app">
    <nav>
      <router-link to="/">Home</router-link> |
      <router-link to="/admin">Admin</router-link> |
      <router-link to="/studio">Studio</router-link> |
      <button @click="handleAuthAction">{{ authButtonText }}</button>
    </nav>
    <router-view></router-view>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue';
import { useStore } from 'vuex';
import { useRouter } from 'vue-router';
import AuthService from './services/AuthService';

export default defineComponent({
  name: 'App',
  setup() {
    const store = useStore();
    const router = useRouter();

    const isLoggedIn = computed(() => store.state.isLoggedIn);
    const authButtonText = computed(() => (isLoggedIn.value ? 'Logout' : 'Login'));

    const handleAuthAction = () => {
      if (isLoggedIn.value) {
        // Logout
        AuthService.logout();
        store.commit('setLoggedIn', false);
        store.commit('setUser', null);
        router.push('/');
      } else {
        // Navigate to Login page
        router.push('/login');
      }
    };

    return {
      authButtonText,
      handleAuthAction,
    };
  },
});
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: #2c3e50;
}

nav {
  padding: 30px;
}

nav a {
  font-weight: bold;
  color: #2c3e50;
}

nav a.router-link-exact-active {
  color: #42b983;
}
</style>==== END OF FILE: frontend/src//App.vue ====

==== START OF FILE: frontend/src//main.ts ====
// frontend/src/main.ts

import { createApp } from 'vue';
import App from './App.vue';
import router from './router';
import store from './store';
import AuthService from '@/services/AuthService';

const token = AuthService.getToken();
if (token) {
  AuthService.setToken(token);
  store.commit('setLoggedIn', true);
  // Optionally fetch user data here
}

createApp(App).use(router).use(store).mount('#app');==== END OF FILE: frontend/src//main.ts ====

==== START OF FILE: frontend/src//extensions/tiptap.d.ts ====
import '@tiptap/core';

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    /**
     * Insert a Data Pill with the given value
     */
    insertDataPill: (value: string) => ReturnType;
  }
}

export {};==== END OF FILE: frontend/src//extensions/tiptap.d.ts ====

==== START OF FILE: frontend/src//extensions/DataPill.ts ====
// src/extensions/DataPill.ts

import { Node, mergeAttributes } from '@tiptap/core'

export interface DataPillOptions {
  HTMLAttributes: Record<string, any>
}

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    dataPill: {
      insertDataPill: (value: string) => ReturnType
    }
  }
}

export const DataPill = Node.create<DataPillOptions>({
  name: 'dataPill',

  group: 'inline',

  inline: true,

  atom: true,

  addOptions() {
    return {
      HTMLAttributes: {},
    }
  },

  addAttributes() {
    return {
      value: {
        default: null,
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'span[data-type="data-pill"]',
      },
    ]
  },

  renderHTML({ node, HTMLAttributes }) {
    return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': 'data-pill' }), node.attrs.value]
  },

  addCommands() {
    return {
      insertDataPill: (value: string) => ({ chain }) => {
        return chain()
          .insertContent({
            type: this.name,
            attrs: { value },
          })
          .run()
      },
    }
  },
})==== END OF FILE: frontend/src//extensions/DataPill.ts ====

==== START OF FILE: frontend/src//components/studio/editors/AmberStoreEditor.vue ====
<template>
    <div class="amber-store-editor">
      <h3>{{ isNew ? 'Create' : 'Edit' }} Amber Store</h3>
      <form @submit.prevent="handleSubmit">
        <div>
          <label for="data">Data (JSON):</label>
          <textarea id="data" v-model="jsonData" rows="10" required></textarea>
        </div>
        <div>
          <button type="submit">Save</button>
          <button type="button" @click="$emit('cancel')">Cancel</button>
        </div>
      </form>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed, watch } from 'vue';
  
  interface AmberStore {
    id?: string;
    data: any;
  }
  
  const props = defineProps<{
    data: AmberStore;
  }>();
  
  const emit = defineEmits<{
    (e: 'save', amberStore: AmberStore): void;
    (e: 'cancel'): void;
  }>();
  
  const editedAmberStore = ref<AmberStore>({ ...props.data });
  const jsonData = ref(JSON.stringify(props.data.data, null, 2));
  
  const isNew = computed(() => !props.data.id);
  
  watch(() => props.data, (newData) => {
    editedAmberStore.value = { ...newData };
    jsonData.value = JSON.stringify(newData.data, null, 2);
  }, { deep: true });
  
  const handleSubmit = () => {
    try {
      editedAmberStore.value.data = JSON.parse(jsonData.value);
      emit('save', editedAmberStore.value);
    } catch (error) {
      alert('Invalid JSON data. Please check your input.');
    }
  };
  </script>
  
  <style scoped>
  .amber-store-editor {
    margin-top: 20px;
  }
  form > div {
    margin-bottom: 15px;
  }
  label {
    display: block;
    margin-bottom: 5px;
  }
  textarea {
    width: 100%;
    padding: 5px;
  }
  button {
    margin-right: 10px;
  }
  </style>==== END OF FILE: frontend/src//components/studio/editors/AmberStoreEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/PipelineEditor.vue ====
<template>
    <div class="pipeline-editor">
      <h2>Pipeline Editor</h2>
      <form @submit.prevent="savePipeline">
        <div class="form-group">
          <label for="name">Pipeline Name</label>
          <input
            type="text"
            id="name"
            v-model="pipeline.name"
            required
            class="form-control"
          />
        </div>
        <div class="form-group">
          <label for="editor">Pipeline Configuration</label>
          <EditorContent :editor="editor" />
        </div>
        <div class="button-group">
          <button type="submit" class="btn btn-primary">Save Pipeline</button>
          <button type="button" @click="cancel" class="btn btn-secondary">Cancel</button>
        </div>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref, watch } from 'vue';
  import { useEditor, EditorContent } from '@tiptap/vue-3';
  import StarterKit from '@tiptap/starter-kit';
  import { DataPill } from '@/extensions/DataPill';
  
  interface Pipeline {
    id?: string;
    name: string;
    data: any;
  }
  
  export default defineComponent({
    name: 'PipelineEditor',
    components: { EditorContent },
    props: {
      data: {
        type: Object as () => Pipeline,
        required: true,
      },
    },
    setup(props, { emit }) {
      const pipeline = ref<Pipeline>({ ...props.data });
      const isSaving = ref(false);
      const errorMessage = ref('');
  
      const editor = useEditor({
        extensions: [StarterKit, DataPill],
        content: pipeline.value.data || {
          type: 'doc',
          content: [],
        },
      });
  
      watch(
        () => props.data,
        (newValue) => {
          pipeline.value = { ...newValue };
          if (editor.value) {
            editor.value.commands.setContent(newValue.data || { type: 'doc', content: [] });
          }
        },
        { deep: true }
      );
  
      const savePipeline = () => {
        if (editor.value) {
          const updatedPipeline: Pipeline = {
            id: pipeline.value.id, // 'id' may be undefined for new pipelines
            name: pipeline.value.name,
            data: editor.value.getJSON(), // Use getJSON for structured data
          };
          emit('save', updatedPipeline);
        }
      };
  
      const cancel = () => {
        emit('cancel');
      };
  
      return {
        pipeline,
        isSaving,
        errorMessage,
        savePipeline,
        cancel,
        editor,
      };
    },
  });
  </script>
  
  <style scoped>
  .pipeline-editor {
    padding: 20px;
  }
  .form-group {
    margin-bottom: 15px;
  }
  .button-group {
    margin-top: 20px;
  }
  </style>==== END OF FILE: frontend/src//components/studio/editors/PipelineEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/DockerFileEditor.vue ====
<template>
    <div class="docker-file-editor">
      <h3>{{ isNew ? 'Create' : 'Edit' }} Docker File</h3>
      <form @submit.prevent="handleSubmit">
        <div>
          <label for="name">Name:</label>
          <input type="text" id="name" v-model="editedDockerFile.name" required>
        </div>
        <div>
          <label for="content">Content:</label>
          <textarea id="content" v-model="editedDockerFile.content" rows="10" required></textarea>
        </div>
        <div>
          <button type="submit">Save</button>
          <button type="button" @click="$emit('cancel')">Cancel</button>
        </div>
      </form>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed } from 'vue';
  
  interface DockerFile {
    id?: string;
    name: string;
    content: string;
  }
  
  const props = defineProps<{
    dockerFile: DockerFile | null;
  }>();
  
  const emit = defineEmits<{
    (e: 'save', dockerFile: DockerFile): void;
    (e: 'cancel'): void;
  }>();
  
  const editedDockerFile = ref<DockerFile>({
    id: props.dockerFile?.id,
    name: props.dockerFile?.name || '',
    content: props.dockerFile?.content || '',
  });
  
  const isNew = computed(() => !props.dockerFile?.id);
  
  const handleSubmit = () => {
    emit('save', editedDockerFile.value);
  };
  </script>
  
  <style scoped>
  .docker-file-editor {
    margin-top: 20px;
  }
  form > div {
    margin-bottom: 15px;
  }
  label {
    display: block;
    margin-bottom: 5px;
  }
  input[type="text"], textarea {
    width: 100%;
    padding: 5px;
  }
  button {
    margin-right: 10px;
  }
  </style>==== END OF FILE: frontend/src//components/studio/editors/DockerFileEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/JobEditor.vue ====
<template>
  <div class="job-editor">
    <h3>{{ isNew ? 'Create' : 'Edit' }} Job</h3>
    <form @submit.prevent="handleSubmit">
      <div>
        <label for="worker_type">Worker Type:</label>
        <select id="worker_type" v-model="editedJob.worker_type" required>
          <option v-for="dockerFile in dockerFiles" :key="dockerFile.id" :value="dockerFile.id">
            {{ dockerFile.name }}
          </option>
        </select>
        <router-link to="/studio/dockerfiles">Manage Docker Files</router-link>
      </div>
      <div>
        <label for="config">Configuration:</label>
        <select id="config" v-model="editedJob.config" required>
          <option v-for="config in configurations" :key="config.id" :value="config.id">
            {{ config.name }}
          </option>
        </select>
        <router-link to="/studio/configurations">Manage Configurations</router-link>
      </div>
      <div>
  <label for="pipeline">Pipeline:</label>
  <select id="pipeline" v-model="editedJob.pipeline_id" required>
    <option v-for="pipeline in pipelines" :key="pipeline.id" :value="pipeline.id">
      {{ pipeline.name }}
    </option>
  </select>
  <router-link to="/studio/pipelines">Manage Pipelines</router-link>
</div>
      <div>
        <label for="amber_store">Amber Store:</label>
        <select id="amber_store" v-model="editedJob.amber_id">
          <option :value="null">None</option>
          <option v-for="amberStore in amberStores" :key="amberStore.id" :value="amberStore.id">
            {{ amberStore.id }}
          </option>
        </select>
        <router-link to="/studio/amberstores">Manage Amber Stores</router-link>
      </div>
      <div>
        <button type="submit">Save</button>
        <button type="button" @click="$emit('cancel')">Cancel</button>
      </div>
    </form>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue';

interface Job {
  id?: string;
  config: any;
  amber_id?: string | null;
  state_file_content?: string | null;
  data_path?: string;
  worker_type: string;
  triggers?: any;
  timers?: any;
  status: string;
  pipeline_id: string;
  results?: any;
}

const props = defineProps<{
  data: Job;
  dockerFiles: any[];
  configurations: any[];
  pipelines: any[];
  amberStores: any[];
}>();

const emit = defineEmits<{
  (e: 'save', job: Job): void;
  (e: 'cancel'): void;
}>();

const editedJob = ref<Job>({ ...props.data });

const isNew = computed(() => !props.data.id);

watch(() => props.data, (newData) => {
  editedJob.value = { ...newData };
}, { deep: true });

const handleSubmit = () => {
  emit('save', editedJob.value);
};
</script>

<style scoped>
/* ... (keep existing styles) ... */
</style>==== END OF FILE: frontend/src//components/studio/editors/JobEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/ConfigurationEditor.vue ====
<template>
    <div class="configuration-editor">
      <h3>{{ isNew ? 'Create' : 'Edit' }} Configuration</h3>
      <form @submit.prevent="handleSubmit">
        <div>
          <label for="name">Name:</label>
          <input type="text" id="name" v-model="editedConfiguration.name" required>
        </div>
        <div>
          <label for="data">Data (JSON):</label>
          <textarea id="data" v-model="jsonData" rows="10" required></textarea>
        </div>
        <div>
          <button type="submit">Save</button>
          <button type="button" @click="$emit('cancel')">Cancel</button>
        </div>
      </form>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed, watch } from 'vue';
  
  interface Configuration {
    id?: string;
    name: string;
    data: any;
  }
  
  const props = defineProps<{
    data: Configuration;
  }>();
  
  const emit = defineEmits<{
    (e: 'save', configuration: Configuration): void;
    (e: 'cancel'): void;
  }>();
  
  const editedConfiguration = ref<Configuration>({ ...props.data });
  const jsonData = ref(JSON.stringify(props.data.data, null, 2));
  
  const isNew = computed(() => !props.data.id);
  
  watch(() => props.data, (newData) => {
    editedConfiguration.value = { ...newData };
    jsonData.value = JSON.stringify(newData.data, null, 2);
  }, { deep: true });
  
  const handleSubmit = () => {
    try {
      editedConfiguration.value.data = JSON.parse(jsonData.value);
      emit('save', editedConfiguration.value);
    } catch (error) {
      alert('Invalid JSON data. Please check your input.');
    }
  };
  </script>
  
  <style scoped>
  .configuration-editor {
    margin-top: 20px;
  }
  form > div {
    margin-bottom: 15px;
  }
  label {
    display: block;
    margin-bottom: 5px;
  }
  input[type="text"], textarea {
    width: 100%;
    padding: 5px;
  }
  button {
    margin-right: 10px;
  }
  </style>==== END OF FILE: frontend/src//components/studio/editors/ConfigurationEditor.vue ====

==== START OF FILE: frontend/src//components/studio/JobList.vue ====
<template>
  <div class="job-list">
    <h2>Job List</h2>
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>URI</th>
          <th>Worker Type</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="job in jobs" :key="job.id">
          <td>{{ job.id }}</td>
          <td>{{ job.uri }}</td>
          <td>{{ job.worker_type }}</td>
          <td>
            <router-link :to="`/admin/jobs/${job.id}`">View</router-link> |
            <router-link :to="`/admin/jobs/${job.id}/edit`">Edit</router-link> |
            <button @click="deleteJob(job.id)" class="delete-button">Delete</button>
          </td>
        </tr>
      </tbody>
    </table>
    <p v-if="jobs.length === 0">No jobs available.</p>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted } from 'vue';
import axios from 'axios';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

export default defineComponent({
  name: 'JobList',
  setup() {
    const jobs = ref<Job[]>([]);
    const isLoading = ref(true);
    const errorMessage = ref('');

    const fetchJobs = async () => {
      try {
        const response = await axios.get('/jobs'); // Adjust the endpoint as needed
        jobs.value = response.data;
      } catch (error) {
        console.error('Failed to fetch jobs:', error);
        errorMessage.value = 'Failed to load jobs.';
      } finally {
        isLoading.value = false;
      }
    };

    const deleteJob = async (id: number) => {
      if (!confirm('Are you sure you want to delete this job?')) return;
      try {
        await axios.delete(`/api/jobs/${id}`); // Adjust the endpoint as needed
        jobs.value = jobs.value.filter(job => job.id !== id);
      } catch (error) {
        console.error('Failed to delete job:', error);
        alert('Failed to delete the job. Please try again.');
      }
    };

    onMounted(() => {
      fetchJobs();
    });

    return {
      jobs,
      isLoading,
      errorMessage,
      deleteJob,
    };
  },
});
</script>

<style scoped>
.job-list {
  padding: 20px;
}

.job-list table {
  width: 100%;
  border-collapse: collapse;
}

.job-list th,
.job-list td {
  border: 1px solid #ddd;
  padding: 8px;
}

.job-list th {
  background-color: #f2f2f2;
  text-align: left;
}

.delete-button {
  background-color: #c0392b;
  color: #fff;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
}

.delete-button:hover {
  background-color: #e74c3c;
}

button {
  background: none;
  border: none;
  color: #2980b9;
  cursor: pointer;
}

button:hover {
  text-decoration: underline;
}

p {
  margin-top: 20px;
  color: #7f8c8d;
}
</style>==== END OF FILE: frontend/src//components/studio/JobList.vue ====

==== START OF FILE: frontend/src//components/studio/StudioWorkspace.vue ====
<template>
    <div class="studio-workspace">
      <component
        :is="activeComponent"
        v-if="activeComponent"
        :key="activeTabId"
        :data="activeTabData"
      />
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, computed } from 'vue';
  import { useStore } from 'vuex';
  import ConfigurationEditor from '@/components/studio/editors/ConfigurationEditor.vue';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  import DockerFileEditor from '@/components/studio/editors/DockerFileEditor.vue';
  
  export default defineComponent({
    name: 'StudioWorkspace',
    components: {
      ConfigurationEditor,
      PipelineEditor,
      DockerFileEditor,
    },
    setup() {
      const store = useStore();
  
      const activeTabId = computed(() => store.state.studio.activeTabId);
      const activeTab = computed(() => store.getters['studio/activeTab']);
  
      const activeComponent = computed(() => {
        if (!activeTab.value) return null;
        switch (activeTab.value.type) {
          case 'configuration':
            return 'ConfigurationEditor';
          case 'pipeline':
            return 'PipelineEditor';
          case 'dockerFile':
            return 'DockerFileEditor';
          default:
            return null;
        }
      });
  
      const activeTabData = computed(() => activeTab.value?.data || {});
  
      return {
        activeTabId,
        activeComponent,
        activeTabData,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio-workspace {
    flex-grow: 1;
    padding: 1rem;
    overflow-y: auto;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioWorkspace.vue ====

==== START OF FILE: frontend/src//components/studio/StudioSidebar.vue ====
<template>
    <div :class="['sidebar', { collapsed: isCollapsed }]">
      <div class="toggle-button" @click="$emit('toggle')">
        <span v-if="!isCollapsed">«</span>
        <span v-else>»</span>
      </div>
      <nav>
        <ul>
          <li>
            <router-link to="/studio/dashboard">Dashboard</router-link>
          </li>
          <li>
            <router-link to="/studio/jobs">Jobs</router-link>
          </li>
          <li>
            <router-link to="/studio/pipelines">Pipelines</router-link>
          </li>
          <li>
            <router-link to="/studio/dockerfiles">Docker Files</router-link>
          </li>
          <li>
            <router-link to="/studio/settings">Settings</router-link>
          </li>
        </ul>
      </nav>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'StudioSidebar',
    props: {
      isCollapsed: {
        type: Boolean,
        required: true,
      },
    },
  });
  </script>
  
  <style scoped>
  .sidebar {
    width: 250px;
    background-color: #2c3e50;
    color: #ecf0f1;
    transition: width 0.3s;
    position: relative;
  }
  
  .sidebar.collapsed {
    width: 80px;
  }
  
  .toggle-button {
    position: absolute;
    top: 10px;
    right: -15px;
    background-color: #34495e;
    border-radius: 50%;
    padding: 5px;
    cursor: pointer;
  }
  
  nav ul {
    list-style: none;
    padding: 0;
    margin-top: 50px;
  }
  
  nav ul li {
    padding: 15px 20px;
  }
  
  nav ul li a {
    color: #ecf0f1;
    text-decoration: none;
    display: block;
  }
  
  nav ul li a.router-link-exact-active {
    background-color: #1abc9c;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioSidebar.vue ====

==== START OF FILE: frontend/src//components/studio/StudioHeader.vue ====
<template>
    <header class="studio-header">
      <button class="menu-button" @click="$emit('toggleSidebar')">☰</button>
      <div class="user-info">
        <span>Welcome, {{ userName }}</span>
        <button @click="logout">Logout</button>
      </div>
    </header>
  </template>
  
  <script lang="ts">
  import { defineComponent, computed } from 'vue';
  import { useStore } from 'vuex';
  import AuthService from '@/services/AuthService';
  import { useRouter } from 'vue-router';
  
  export default defineComponent({
    name: 'StudioHeader',
    setup() {
      const store = useStore();
      const router = useRouter();
  
      const userName = computed(() => store.state.user?.name || 'User');
  
      const logout = () => {
        AuthService.logout();
        store.commit('setLoggedIn', false);
        store.commit('setUser', null);
        router.push('/');
      };
  
      return {
        userName,
        logout,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio-header {
    height: 60px;
    background-color: #ecf0f1;
    display: flex;
    align-items: center;
    padding: 0 20px;
    justify-content: space-between;
    border-bottom: 1px solid #bdc3c7;
  }
  
  .menu-button {
    font-size: 24px;
    background: none;
    border: none;
    cursor: pointer;
  }
  
  .user-info {
    display: flex;
    align-items: center;
  }
  
  .user-info span {
    margin-right: 15px;
  }
  
  .user-info button {
    padding: 5px 10px;
    cursor: pointer;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioHeader.vue ====

==== START OF FILE: frontend/src//components/studio/PipelineList.vue ====
<!-- frontend/src/components/studio/PipelineList.vue -->
<template>
    <div class="pipeline-list">
      <h2>Pipeline List</h2>
      <router-link to="/studio/pipelines/create" class="create-button">Create New Pipeline</router-link>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Description</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="pipeline in pipelines" :key="pipeline.id">
            <td>{{ pipeline.id }}</td>
            <td>{{ pipeline.name }}</td>
            <td>{{ pipeline.description }}</td>
            <td>
              <router-link :to="`/studio/pipelines/${pipeline.id}`">View</router-link> |
              <router-link :to="`/studio/pipelines/${pipeline.id}/edit`">Edit</router-link> |
              <button @click="deletePipeline(pipeline.id)" class="delete-button">Delete</button>
            </td>
          </tr>
        </tbody>
      </table>
      <p v-if="pipelines.length === 0">No pipelines available.</p>
      <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
      <p v-if="isLoading" class="loading">Loading pipelines...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    id: number;
    name: string;
    description: string;
    // ... other properties
  }
  
  const pipelines = ref<Pipeline[]>([]);
  const isLoading = ref(true);
  const errorMessage = ref('');
  
  const fetchPipelines = async () => {
    try {
      const response = await apiClient.get('/pipelines');
      pipelines.value = response.data;
    } catch (error: any) {
      errorMessage.value = error.response?.data?.message || 'Failed to load pipelines.';
    } finally {
      isLoading.value = false;
    }
  };
  
  const deletePipeline = async (id: number) => {
    if (!confirm('Are you sure you want to delete this pipeline?')) return;
    try {
      await apiClient.delete(`/pipelines/${id}`);
      pipelines.value = pipelines.value.filter(pipeline => pipeline.id !== id);
    } catch (error: any) {
      alert('Failed to delete the pipeline. Please try again.');
    }
  };
  
  onMounted(() => {
    fetchPipelines();
  });
  </script>
  
  <style scoped>
  .pipeline-list {
    padding: 20px;
  }
  .pipeline-list .create-button {
    display: inline-block;
    margin-bottom: 15px;
  }
  .pipeline-list table {
    width: 100%;
    border-collapse: collapse;
  }
  .pipeline-list th,
  .pipeline-list td {
    border: 1px solid #ddd;
    padding: 8px;
  }
  .pipeline-list th {
    background-color: #f2f2f2;
    text-align: left;
  }
  .delete-button {
    background-color: #c0392b;
    color: #fff;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
  }
  .delete-button:hover {
    background-color: #e74c3c;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//components/studio/PipelineList.vue ====

==== START OF FILE: frontend/src//components/LoginLogout.vue ====
<template>
    <button @click="toggleLogin">{{ buttonText }}</button>
  </template>
  
  <script lang="ts">
  import { computed, defineComponent } from 'vue'
  import { useStore } from 'vuex'
  
  export default defineComponent({
    setup() {
      const store = useStore()
  
      const isLoggedIn = computed(() => store.getters.isLoggedIn)
      const buttonText = computed(() => isLoggedIn.value ? 'Logout' : 'Login')
  
      const toggleLogin = async () => {
        if (isLoggedIn.value) {
          await store.dispatch('logout')
        } else {
          // For simplicity, we're not handling the login form here.
          // You might want to show a login modal or navigate to a login page.
          console.log('Show login form')
        }
      }
  
      return {
        buttonText,
        toggleLogin
      }
    }
  })
  </script>==== END OF FILE: frontend/src//components/LoginLogout.vue ====

==== START OF FILE: frontend/src//components/Greet.vue ====
<script setup lang="ts">
import { ref } from "vue";
import { invoke } from "@tauri-apps/api/tauri";

const greetMsg = ref("");
const name = ref("");

async function greet() {
  greetMsg.value = await invoke("greet", { name: name.value });
}
</script>

<template>
  <form class="row" @submit.prevent="greet">
    <input id="greet-input" v-model="name" placeholder="Enter a name..." />
    <button type="submit">Greet</button>
  </form>

  <p>{{ greetMsg }}</p>
</template>==== END OF FILE: frontend/src//components/Greet.vue ====

==== START OF FILE: frontend/src//components/common/TreeView.vue ====
<template>
    <ul class="tree-view">
      <li v-for="item in items" :key="item.name">
        <div @click="toggleItem(item)">
          <span v-if="item.children && item.children.length">
            {{ item.expanded ? '▼' : '▶' }}
          </span>
          <span @click="$emit('item-click', item)">{{ item.name }}</span>
        </div>
        <TreeView
          v-if="item.children && item.children.length && item.expanded"
          :items="item.children"
          @item-click="$emit('item-click', $event)"
        />
      </li>
    </ul>
  </template>
  
  <script lang="ts">
  import { defineComponent, PropType } from 'vue';
  
  interface TreeItem {
    name: string;
    children?: TreeItem[];
    expanded?: boolean;
  }
  
  export default defineComponent({
    name: 'TreeView',
    props: {
      items: {
        type: Array as PropType<TreeItem[]>,
        required: true,
      },
    },
    emits: ['item-click'],
    methods: {
      toggleItem(item: TreeItem) {
        if (item.children && item.children.length) {
          item.expanded = !item.expanded;
        }
      },
    },
  });
  </script>
  
  <style scoped>
  .tree-view {
    list-style-type: none;
    padding-left: 1rem;
  }
  .tree-view li {
    cursor: pointer;
  }
  </style>==== END OF FILE: frontend/src//components/common/TreeView.vue ====

==== START OF FILE: frontend/src//components/JsonEditorWithPills.vue ====
<!-- JsonEditorWithPills.vue -->
<template>
    <div class="json-editor-with-pills">
      <MonacoEditor
        v-model="code"
        language="json"
        :options="editorOptions"
        @editorMounted="onEditorMounted"
      />
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref, watch } from 'vue';

  import * as MonacoEditor from 'monaco-editor';



  export default defineComponent({
    name: 'JsonEditorWithPills',
    components: { MonacoEditor },
    props: {
      modelValue: {
        type: String,
        required: true,
      },
    },
    emits: ['update:modelValue'],
    setup(props, { emit }) {
      const code = ref(props.modelValue);
  
      const editorOptions = {
        automaticLayout: true,
        // Additional editor options
      };
  
      const onEditorMounted = () => {
        // Implement data pills functionality here
        // e.g., custom syntax highlighting, hover tips, or decorations
      };
  
      watch(code, (newValue) => {
        emit('update:modelValue', newValue);
      });
  
      return {
        code,
        editorOptions,
        onEditorMounted,
      };
    },
  });
  </script>
  
  <style scoped>
  .json-editor-with-pills {
    height: 400px; /* Adjust as needed */
  }
  </style>==== END OF FILE: frontend/src//components/JsonEditorWithPills.vue ====

==== START OF FILE: frontend/src//vite-env.d.ts ====
/// <reference types="vite/client" />

declare module "*.vue" {
  import type { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
==== END OF FILE: frontend/src//vite-env.d.ts ====

==== START OF FILE: frontend/src//config.ts ====
export const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';==== END OF FILE: frontend/src//config.ts ====

==== START OF FILE: frontend/src//views/studio/Settings.vue ====
<template>
    <div class="settings">
      <h1>Settings</h1>
      <p>Manage your Studio settings here.</p>
      <!-- Add settings forms and options here -->
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Settings',
  });
  </script>
  
  <style scoped>
  .settings {
    padding: 20px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Settings.vue ====

==== START OF FILE: frontend/src//views/studio/PipelineDetails.vue ====
<!-- frontend/src/views/studio/PipelineDetails.vue -->
<template>
    <div v-if="pipeline" class="pipeline-details">
      <h1>Pipeline Details</h1>
      <p><strong>ID:</strong> {{ pipeline.id }}</p>
      <p><strong>Name:</strong> {{ pipeline.name }}</p>
      <p><strong>Description:</strong> {{ pipeline.description }}</p>
      <!-- Display other pipeline properties as needed -->
      <router-link :to="`/studio/pipelines/${pipeline.id}/edit`">Edit Pipeline</router-link>
    </div>
    <div v-else>
      <p>Loading pipeline details...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import { useRoute } from 'vue-router';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    id: number;
    name: string;
    description: string;
    // ... other properties
  }
  
  const route = useRoute();
  const pipeline = ref<Pipeline | null>(null);
  const errorMessage = ref('');
  
  const fetchPipeline = async () => {
    try {
      const response = await apiClient.get(`/pipelines/${route.params.id}`);
      pipeline.value = response.data;
    } catch (error: any) {
      errorMessage.value = error.response?.data?.message || 'Failed to load pipeline details.';
    }
  };
  
  onMounted(() => {
    fetchPipeline();
  });
  </script>
  
  <style scoped>
  .pipeline-details {
    padding: 20px;
  }
  .pipeline-details p {
    margin-bottom: 10px;
  }
  .pipeline-details a {
    color: #42b983;
    text-decoration: none;
  }
  .pipeline-details a:hover {
    text-decoration: underline;
  }
  </style>==== END OF FILE: frontend/src//views/studio/PipelineDetails.vue ====

==== START OF FILE: frontend/src//views/studio/PipelineCreate.vue ====
<template>
    <div class="pipeline-create">
      <h1>Create Pipeline</h1>
      <PipelineEditor
        :data="pipeline"
        @save="createPipeline"
        @cancel="closeEditor"
      />
      <p v-if="isLoading" class="loading">Creating pipeline...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref } from 'vue';
  import { useRouter } from 'vue-router';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    name: string;
    data: any;
  }
  
  const router = useRouter();
  const pipeline = ref<Pipeline>({
    name: '',
    data: {
      type: 'doc',
      content: [],
    },
  });
  const isLoading = ref(false);
  
  const createPipeline = async (newPipeline: Pipeline) => {
    isLoading.value = true;
    try {
      await apiClient.post('/pipelines', newPipeline);
      router.push('/studio/pipelines');
    } catch (error: any) {
      console.error('Failed to create pipeline:', error);
    } finally {
      isLoading.value = false;
    }
  };
  
  const closeEditor = () => {
    // Implement modal close if necessary
  };
  </script>
  
  <style scoped>
  .pipeline-create {
    padding: 20px;
  }
  .pipeline-create form {
    display: flex;
    flex-direction: column;
  }
  .pipeline-create label {
    margin-bottom: 5px;
  }
  .pipeline-create input {
    margin-bottom: 15px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 3px;
  }
  .pipeline-create button {
    padding: 10px;
    background-color: #2c3e50;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  .pipeline-create button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/PipelineCreate.vue ====

==== START OF FILE: frontend/src//views/studio/Dashboard.vue ====
<template>
    <div class="dashboard">
      <h1>Studio Dashboard</h1>
      <p>Welcome to the Studio Dashboard!</p>
      <!-- Add more dashboard widgets and information here -->
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Dashboard',
  });
  </script>
  
  <style scoped>
  .dashboard {
    padding: 20px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Dashboard.vue ====

==== START OF FILE: frontend/src//views/studio/DockerFileEditor.vue ====
<!-- frontend/src/views/studio/DockerFileEdit.vue -->
<template>
    <div v-if="dockerFile" class="docker-file-edit">
      <h1>Edit Docker File</h1>
      <DockerFileEditor
        :dockerFile="dockerFile"
        @save="updateDockerFile"
        @cancel="cancelEdit"
      />
      <p v-if="isLoading" class="loading">Updating Docker file...</p>
    </div>
    <div v-else>
      <p>Loading Docker file details...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import { useRoute, useRouter } from 'vue-router';
  import DockerFileEditor from '@/components/studio/editors/DockerFileEditor.vue';
  import apiClient from '@/services/apiClient';
  
  interface DockerFile {
    id?: string;
    name: string;
    content: string;
  }
  
  const route = useRoute();
  const router = useRouter();
  const dockerFile = ref<DockerFile | null>(null);
  const isLoading = ref(false);
  
  const fetchDockerFile = async () => {
    try {
      const response = await apiClient.get(`/docker_files/${route.params.id}`);
      dockerFile.value = response.data;
    } catch (error: any) {
      console.error('Failed to load Docker file details:', error);
    }
  };
  
  const updateDockerFile = async (updatedDockerFile: DockerFile) => {
    if (!dockerFile.value) return;
    isLoading.value = true;
    try {
      await apiClient.put(`/docker_files/${dockerFile.value.id}`, updatedDockerFile);
      router.push(`/studio/dockerfiles/${dockerFile.value.id}`);
    } catch (error: any) {
      console.error('Failed to update Docker file:', error);
      alert('Failed to update the Docker file. Please try again.');
    } finally {
      isLoading.value = false;
    }
  };
  
  const cancelEdit = () => {
    if (dockerFile.value) {
      router.push(`/studio/dockerfiles/${dockerFile.value.id}`);
    } else {
      router.push('/studio/dockerfiles');
    }
  };
  
  onMounted(() => {
    fetchDockerFile();
  });
  </script>
  
  <style scoped>
  .docker-file-edit {
    padding: 20px;
  }
  
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/DockerFileEditor.vue ====

==== START OF FILE: frontend/src//views/studio/PipelineEdit.vue ====
<template>
    <div v-if="pipeline" class="pipeline-edit">
      <h1>Edit Pipeline</h1>
      <PipelineEditor
        :data="pipeline"
        @save="updatePipeline"
        @cancel="closeEditor"
      />
      <p v-if="isLoading" class="loading">Updating pipeline...</p>
    </div>
    <div v-else>
      <p>Loading pipeline details...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import { useRoute, useRouter } from 'vue-router';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    id: string;
    name: string;
    data: any;
  }
  
  const route = useRoute();
  const router = useRouter();
  const pipeline = ref<Pipeline | null>(null);
  const isLoading = ref(false);
  
  const fetchPipeline = async () => {
    try {
      const response = await apiClient.get(`/pipelines/${route.params.id}`);
      pipeline.value = response.data;
    } catch (error: any) {
      console.error('Failed to load pipeline details:', error);
    }
  };
  
  const updatePipeline = async (updatedPipeline: Pipeline) => {
    if (!pipeline.value) return;
    isLoading.value = true;
    try {
      await apiClient.put(`/pipelines/${pipeline.value.id}`, updatedPipeline);
      router.push('/studio/pipelines');
    } catch (error: any) {
      console.error('Failed to update pipeline:', error);
    } finally {
      isLoading.value = false;
    }
  };
  
  const closeEditor = () => {
    // Implement modal close if necessary
  };
  
  onMounted(() => {
    fetchPipeline();
  });
  </script>
  
  <style scoped>
  .pipeline-edit {
    padding: 20px;
  }
  .pipeline-edit form {
    display: flex;
    flex-direction: column;
  }
  .pipeline-edit label {
    margin-bottom: 5px;
  }
  .pipeline-edit input {
    margin-bottom: 15px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 3px;
  }
  .pipeline-edit button {
    padding: 10px;
    background-color: #2980b9;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  .pipeline-edit button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/PipelineEdit.vue ====

==== START OF FILE: frontend/src//views/studio/Jobs.vue ====
<template>
  <div class="jobs">
    <h2>Jobs</h2>
    <button @click="showEditor = true" class="create-button">Create New Job</button>
    <table v-if="jobs.length">
      <thead>
        <tr>
          <th>URI</th>
          <th>Worker Type</th>
          <th>Configuration</th>
          <th>Pipeline</th>
          <th>Amber Store</th>
          <th>Status</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="job in jobs" :key="job.id">
          <td>{{ job.id }}</td>
          <td>{{ getDockerFileName(job.worker_type) }}</td>
          <td>{{ getConfigurationName(job.config) }}</td>
          <td>{{ getPipelineName(job.pipeline_id) }}</td>
          <td>{{ job.amber_id || 'N/A' }}</td>
          <td>{{ job.status }}</td>
          <td>
            <button @click="editJob(job)" class="edit-button">Edit</button>
            <button @click="job.id && deleteJob(job.id)" class="delete-button">Delete</button>
            <button @click="job.id && startJob(job.id)" class="start-button">Start</button>
            <button @click="job.id && stopJob(job.id)" class="stop-button">Stop</button>
          </td>
        </tr>
      </tbody>
    </table>
    <p v-else>No jobs available.</p>
    <p v-if="error" class="error">{{ error }}</p>
    <p v-if="isLoading" class="loading">Loading...</p>

    <JobEditor
      v-if="showEditor"
      :data="selectedJob"
      :dockerFiles="dockerFiles"
      :configurations="configurations"
      :pipelines="pipelines"
      :amberStores="amberStores"
      @save="handleSave"
      @cancel="showEditor = false"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import JobEditor from '@/components/studio/editors/JobEditor.vue';
import apiClient from '@/services/apiClient';

interface Job {
  id?: string;
  config: any;
  amber_id?: string | null;
  state_file_content?: string | null;
  data_path?: string;
  worker_type: string;
  triggers?: any;
  timers?: any;
  status: string;
  pipeline_id: string;
  results?: any;
}

const jobs = ref<Job[]>([]);
const showEditor = ref(false);
const selectedJob = ref<Job>({
  worker_type: '',
  config: {},
  data_path: '',
  amber_id: null,
  status: '',
  pipeline_id: '',
  state_file_content: null,
  triggers: null,
  timers: null,
  results: null
});
const error = ref<string | null>(null);
const isLoading = ref(false);

const dockerFiles = ref<{ id: string; name: string }[]>([]);
const configurations = ref<{ id: string; name: string }[]>([]);
const pipelines = ref<{ id: string; name: string }[]>([]);
const amberStores = ref<{ id: string }[]>([]);

const fetchJobs = async () => {
  isLoading.value = true;
  error.value = null;
  try {
    const response = await apiClient.get('/jobs');
    jobs.value = response.data;
  } catch (err: any) {
    error.value = 'Failed to fetch jobs. Please try again.';
    console.error('Error fetching jobs:', err);
  } finally {
    isLoading.value = false;
  }
};

const fetchRelatedData = async () => {
  try {
    const [dockerFilesRes, configurationsRes, pipelinesRes, amberStoresRes] = await Promise.all([
      apiClient.get<{ id: string; name: string }[]>('/docker_files'),
      apiClient.get<{ id: string; name: string }[]>('/configurations'),
      apiClient.get<{ id: string; name: string }[]>('/pipelines'),
      apiClient.get<{ id: string }[]>('/amber_store')
    ]);
    dockerFiles.value = dockerFilesRes.data;
    configurations.value = configurationsRes.data;
    pipelines.value = pipelinesRes.data;
    amberStores.value = amberStoresRes.data;
  } catch (err: any) {
    console.error('Error fetching related data:', err);
  }
};

const getDockerFileName = (id: string) => {
  const dockerFile = dockerFiles.value.find(df => df.id === id);
  return dockerFile ? dockerFile.name : 'Unknown';
};

const getConfigurationName = (id: string) => {
  const configuration = configurations.value.find(c => c.id === id);
  return configuration ? configuration.name : 'Unknown';
};

const getPipelineName = (id: string) => {
  const pipeline = pipelines.value.find(p => p.id === id);
  return pipeline ? pipeline.name : 'Unknown';
};

const editJob = (job: Job) => {
  selectedJob.value = { ...job };
  showEditor.value = true;
};

const handleSave = async (job: Job) => {
  isLoading.value = true;
  error.value = null;
  try {
    if (job.id) {
      await apiClient.put(`/jobs/${job.id}`, job);
    } else {
      const newJob = {
        config: job.config,
        amber_id: job.amber_id,
        state_file_content: job.state_file_content,
        data_path: job.data_path,
        worker_type: job.worker_type,
        triggers: job.triggers,
        timers: job.timers,
        status: job.status,
        pipeline_id: job.pipeline_id,
        results: job.results
      };
      console.log('Job data being sent:', newJob);
      await apiClient.post('/jobs', newJob);
    }
    await fetchJobs();
    showEditor.value = false;
  } catch (err: any) {
    error.value = 'Failed to save job. Please try again.';
    console.error('Error saving job:', err);
  } finally {
    isLoading.value = false;
  }
};

const deleteJob = async (id: string) => {
  if (!confirm('Are you sure you want to delete this job?')) return;
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.delete(`/jobs/${id}`);
    await fetchJobs();
  } catch (err: any) {
    error.value = 'Failed to delete job. Please try again.';
    console.error('Error deleting job:', err);
  } finally {
    isLoading.value = false;
  }
};

const startJob = async (id: string) => {
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.post(`/jobs/${id}/start`);
    await fetchJobs();
  } catch (err: any) {
    error.value = 'Failed to start job. Please try again.';
    console.error('Error starting job:', err);
  } finally {
    isLoading.value = false;
  }
};

const stopJob = async (id: string) => {
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.post(`/jobs/${id}/stop`);
    await fetchJobs();
  } catch (err: any) {
    error.value = 'Failed to stop job. Please try again.';
    console.error('Error stopping job:', err);
  } finally {
    isLoading.value = false;
  }
};

onMounted(() => {
  fetchJobs();
  fetchRelatedData();
});
</script>

<style scoped>
/* ... (keep existing styles) ... */
</style>==== END OF FILE: frontend/src//views/studio/Jobs.vue ====

==== START OF FILE: frontend/src//views/studio/Configurations.vue ====
<template>
    <div class="configurations">
      <h2>Configurations</h2>
      <button @click="showEditor = true" class="create-button">Create New Configuration</button>
      <table v-if="configurations.length">
        <thead>
          <tr>
            <th>Name</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="configuration in configurations" :key="configuration.id">
            <td>{{ configuration.name }}</td>
            <td>
              <button @click="editConfiguration(configuration)" class="edit-button">Edit</button>
              <button @click="configuration.id && deleteConfiguration(configuration.id)" class="delete-button">Delete</button>
            </td>
          </tr>
        </tbody>
      </table>
      <p v-else>No configurations available.</p>
      <p v-if="error" class="error">{{ error }}</p>
      <p v-if="isLoading" class="loading">Loading...</p>
  
      <ConfigurationEditor
        v-if="showEditor"
        :data="selectedConfiguration"
        @save="handleSave"
        @cancel="showEditor = false"
      />
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import ConfigurationEditor from '@/components/studio/editors/ConfigurationEditor.vue';
  import apiClient from '@/services/apiClient';
  
  interface Configuration {
    id?: string;
    name: string;
    data: any;
  }
  
  const configurations = ref<Configuration[]>([]);
  const showEditor = ref(false);
  const selectedConfiguration = ref<Configuration>({ name: '', data: {} });
  const error = ref<string | null>(null);
  const isLoading = ref(false);
  
  const fetchConfigurations = async () => {
    isLoading.value = true;
    error.value = null;
    try {
      const response = await apiClient.get('/configurations');
      configurations.value = response.data;
    } catch (err: any) {
      error.value = 'Failed to fetch configurations. Please try again.';
      console.error('Error fetching configurations:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  const editConfiguration = (configuration: Configuration) => {
    selectedConfiguration.value = { ...configuration };
    showEditor.value = true;
  };
  
  const handleSave = async (configuration: Configuration) => {
    isLoading.value = true;
    error.value = null;
    try {
      if (configuration.id) {
        await apiClient.put(`/configurations/${configuration.id}`, configuration);
      } else {
        await apiClient.post('/configurations', configuration);
      }
      await fetchConfigurations();
      showEditor.value = false;
    } catch (err: any) {
      error.value = 'Failed to save configuration. Please try again.';
      console.error('Error saving configuration:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  const deleteConfiguration = async (id: string) => {
    if (!confirm('Are you sure you want to delete this configuration?')) return;
    isLoading.value = true;
    error.value = null;
    try {
      await apiClient.delete(`/configurations/${id}`);
      await fetchConfigurations();
    } catch (err: any) {
      error.value = 'Failed to delete configuration. Please try again.';
      console.error('Error deleting configuration:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  onMounted(fetchConfigurations);
  </script>
  
  <style scoped>
  .configurations {
    padding: 20px;
  }
  .create-button {
    margin-bottom: 15px;
  }
  table {
    width: 100%;
    border-collapse: collapse;
  }
  th, td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
  }
  th {
    background-color: #f2f2f2;
  }
  .edit-button, .delete-button {
    margin-right: 5px;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Configurations.vue ====

==== START OF FILE: frontend/src//views/studio/DockerFiles.vue ====
<template>
  <div class="docker-files">
    <h2>Docker Files</h2>
    <button @click="showEditor = true" class="create-button">Create New Docker File</button>
    <table v-if="dockerFiles.length">
      <thead>
        <tr>
          <th>Name</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="dockerFile in dockerFiles" :key="dockerFile.id">
          <td>{{ dockerFile.name }}</td>
          <td>
            <button @click="editDockerFile(dockerFile)" class="edit-button">Edit</button>
            <button @click="dockerFile.id && deleteDockerFile(dockerFile.id)" class="delete-button">Delete</button>
          </td>
        </tr>
      </tbody>
    </table>
    <p v-else>No Docker files available.</p>
    <p v-if="error" class="error">{{ error }}</p>
    <p v-if="isLoading" class="loading">Loading...</p>

    <DockerFileEditor
      v-if="showEditor"
      :dockerFile="selectedDockerFile"
      @save="handleSave"
      @cancel="showEditor = false"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import DockerFileEditor from '@/components/studio/editors/DockerFileEditor.vue';
import apiClient from '@/services/apiClient';

interface DockerFile {
  id?: string;
  name: string;
  content: string;
}

const dockerFiles = ref<DockerFile[]>([]);
const showEditor = ref(false);
const selectedDockerFile = ref<DockerFile | null>(null);
const error = ref<string | null>(null);
const isLoading = ref(false);

const fetchDockerFiles = async () => {
  isLoading.value = true;
  error.value = null;
  try {
    const response = await apiClient.get('/docker_files');
    dockerFiles.value = response.data;
  } catch (err: any) {
    error.value = 'Failed to fetch Docker files. Please try again.';
    console.error('Error fetching Docker files:', err);
  } finally {
    isLoading.value = false;
  }
};




const editDockerFile = (dockerFile: DockerFile) => {
  selectedDockerFile.value = { ...dockerFile };
  showEditor.value = true;
};

const handleSave = async (dockerFile: DockerFile) => {
  isLoading.value = true;
  error.value = null;
  try {
    if (dockerFile.id) {
      await apiClient.put(`/docker_files/${dockerFile.id}`, dockerFile);
    } else {
      await apiClient.post('/docker_files', dockerFile);
    }
    await fetchDockerFiles();
    showEditor.value = false;
  } catch (err: any) {
    error.value = 'Failed to save Docker file. Please try again.';
    console.error('Error saving Docker file:', err);
  } finally {
    isLoading.value = false;
  }
};

const deleteDockerFile = async (id: string) => {
  if (!confirm('Are you sure you want to delete this Docker file?')) return;
  isLoading.value = true;
  error.value = null;
  try {
    await apiClient.delete(`/docker_files/${id}`);
    await fetchDockerFiles();
  } catch (err: any) {
    error.value = 'Failed to delete Docker file. Please try again.';
    console.error('Error deleting Docker file:', err);
  } finally {
    isLoading.value = false;
  }
};

onMounted(fetchDockerFiles);
</script>

<style scoped>
.docker-files {
  padding: 20px;
}
.create-button {
  margin-bottom: 15px;
}
table {
  width: 100%;
  border-collapse: collapse;
}
th, td {
  border: 1px solid #ddd;
  padding: 8px;
  text-align: left;
}
th {
  background-color: #f2f2f2;
}
.edit-button, .delete-button {
  margin-right: 5px;
}
.error {
  color: red;
  margin-top: 10px;
}
.loading {
  color: #3498db;
  margin-top: 10px;
}
</style>==== END OF FILE: frontend/src//views/studio/DockerFiles.vue ====

==== START OF FILE: frontend/src//views/studio/Pipelines.vue ====
<template>
    <div class="pipelines">
      <h1>Pipelines</h1>
      <button @click="addPipeline" class="add-button">Add New Pipeline</button>
  
      <!-- Pipeline Editor Modal -->
      <div v-if="showEditor && selectedPipeline" class="modal">
        <div class="modal-content">
          <PipelineEditor
            :data="selectedPipeline"
            @save="handleSave"
            @cancel="closeEditor"
          />
        </div>
      </div>
  
      <!-- List of Pipelines -->
      <div v-if="pipelines.length">
        <ul class="pipeline-list">
          <li v-for="pipeline in pipelines" :key="pipeline.id" class="pipeline-item">
            <span>{{ pipeline.name }}</span>
            <div class="actions">
              <router-link :to="`/studio/pipelines/${pipeline.id}`">View</router-link> |
              <router-link :to="`/studio/pipelines/${pipeline.id}/edit`">Edit</router-link> |
              <button @click="deletePipeline(pipeline.id)" class="delete-button">Delete</button>
            </div>
          </li>
        </ul>
      </div>
      <div v-else>
        <p>No pipelines available.</p>
      </div>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref, onMounted } from 'vue';
  import apiClient from '@/services/apiClient';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  
  interface Pipeline {
    id: string;
    name: string;
    data: any;
  }
  
  interface NewPipeline {
    name: string;
    data: any;
  }
  
  export default defineComponent({
    name: 'Pipelines',
    components: {
      PipelineEditor,
    },
    setup() {
      const pipelines = ref<Pipeline[]>([]);
      const showEditor = ref(false);
      const selectedPipeline = ref<Pipeline | NewPipeline | null>(null);
  
      const fetchPipelines = async () => {
        try {
          const response = await apiClient.get('/pipelines');
          pipelines.value = response.data;
        } catch (error: any) {
          console.error('Failed to fetch pipelines:', error);
        }
      };
  
      const addPipeline = () => {
        selectedPipeline.value = {
          name: '',
          data: {
            type: 'doc',
            content: [],
          },
        };
        showEditor.value = true;
      };
  
      function isExistingPipeline(pipeline: Pipeline | NewPipeline): pipeline is Pipeline {
  return (pipeline as Pipeline).id !== undefined;
}

const handleSave = async (pipeline: Pipeline | NewPipeline) => {
  try {
    if (isExistingPipeline(pipeline)) {
      // Update existing pipeline
      await apiClient.put(`/pipelines/${pipeline.id}`, pipeline);
    } else {
      // Create new pipeline without `id`
      const response = await apiClient.post('/pipelines', pipeline);
      const createdPipeline: Pipeline = response.data;
      pipelines.value.push(createdPipeline);
    }
    await fetchPipelines();
    closeEditor();
  } catch (error: any) {
    console.error('Failed to save pipeline:', error);
  }
};
  
      const closeEditor = () => {
        showEditor.value = false;
        selectedPipeline.value = null;
      };
  
      const deletePipeline = async (id: string) => {
        if (!confirm('Are you sure you want to delete this pipeline?')) return;
        try {
          await apiClient.delete(`/pipelines/${id}`);
          pipelines.value = pipelines.value.filter((p) => p.id !== id);
        } catch (error: any) {
          alert('Failed to delete the pipeline. Please try again.');
        }
      };
  
      onMounted(() => {
        fetchPipelines();
      });
  
      return {
        pipelines,
        showEditor,
        selectedPipeline,
        addPipeline,
        handleSave,
        closeEditor,
        deletePipeline,
      };
    },
  });
  </script>
  
  <style scoped>
  .pipelines {
    padding: 20px;
  }
  
  .pipelines .add-button {
    margin-bottom: 15px;
    padding: 10px 20px;
    background-color: #2980b9;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  
  .pipelines .add-button:hover {
    background-color: #3498db;
  }
  
  .pipeline-list {
    list-style-type: none;
    padding: 0;
  }
  
  .pipeline-item {
    display: flex;
    justify-content: space-between;
    padding: 10px 0;
    border-bottom: 1px solid #ddd;
  }
  
  .pipeline-item .actions a,
  .pipeline-item .actions .delete-button {
    margin-left: 10px;
    color: #2980b9;
    text-decoration: none;
    cursor: pointer;
  }
  
  .pipeline-item .actions .delete-button {
    background-color: #c0392b;
    color: #fff;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
  }
  
  .pipeline-item .actions .delete-button:hover {
    background-color: #e74c3c;
  }
  
  .error {
    color: red;
    margin-top: 10px;
  }
  
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  
  .modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .modal-content {
    background-color: #fff;
    padding: 20px;
    border-radius: 5px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Pipelines.vue ====

==== START OF FILE: frontend/src//views/studio/AmberStores.vue ====
<template>
    <div class="amber-stores">
      <h2>Amber Stores</h2>
      <button @click="showEditor = true" class="create-button">Create New Amber Store</button>
      <table v-if="amberStores.length">
        <thead>
          <tr>
            <th>ID</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="amberStore in amberStores" :key="amberStore.id">
            <td>{{ amberStore.id }}</td>
            <td>
              <button @click="editAmberStore(amberStore)" class="edit-button">Edit</button>
              <button @click="amberStore.id && deleteAmberStore(amberStore.id)" class="delete-button">Delete</button>
            </td>
          </tr>
        </tbody>
      </table>
      <p v-else>No amber stores available.</p>
      <p v-if="error" class="error">{{ error }}</p>
      <p v-if="isLoading" class="loading">Loading...</p>
  
      <AmberStoreEditor
        v-if="showEditor"
        :data="selectedAmberStore"
        @save="handleSave"
        @cancel="showEditor = false"
      />
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import AmberStoreEditor from '@/components/studio/editors/AmberStoreEditor.vue';
  import apiClient from '@/services/apiClient';
  
  interface AmberStore {
    id?: string;
    data: any;
  }
  
  const amberStores = ref<AmberStore[]>([]);
  const showEditor = ref(false);
  const selectedAmberStore = ref<AmberStore>({ data: {} });
  const error = ref<string | null>(null);
  const isLoading = ref(false);
  
  const fetchAmberStores = async () => {
    isLoading.value = true;
    error.value = null;
    try {
      const response = await apiClient.get('/amber_store');
      amberStores.value = response.data;
    } catch (err: any) {
      error.value = 'Failed to fetch amber stores. Please try again.';
      console.error('Error fetching amber stores:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  const editAmberStore = (amberStore: AmberStore) => {
    selectedAmberStore.value = { ...amberStore };
    showEditor.value = true;
  };
  
  const handleSave = async (amberStore: AmberStore) => {
    isLoading.value = true;
    error.value = null;
    try {
      if (amberStore.id) {
        await apiClient.put(`/amber_store/${amberStore.id}`, amberStore);
      } else {
        await apiClient.post('/amber_store', amberStore);
      }
      await fetchAmberStores();
      showEditor.value = false;
    } catch (err: any) {
      error.value = 'Failed to save amber store. Please try again.';
      console.error('Error saving amber store:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  const deleteAmberStore = async (id: string) => {
    if (!confirm('Are you sure you want to delete this amber store?')) return;
    isLoading.value = true;
    error.value = null;
    try {
      await apiClient.delete(`/amber_store/${id}`);
      await fetchAmberStores();
    } catch (err: any) {
      error.value = 'Failed to delete amber store. Please try again.';
      console.error('Error deleting amber store:', err);
    } finally {
      isLoading.value = false;
    }
  };
  
  onMounted(fetchAmberStores);
  </script>
  
  <style scoped>
  .amber-stores {
    padding: 20px;
  }
  .create-button {
    margin-bottom: 15px;
  }
  table {
    width: 100%;
    border-collapse: collapse;
  }
  th, td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
  }
  th {
    background-color: #f2f2f2;
  }
  .edit-button, .delete-button {
    margin-right: 5px;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/AmberStores.vue ====

==== START OF FILE: frontend/src//views/Login.vue ====
<template>
    <div class="login">
      <h2>Login</h2>
      <form @submit.prevent="login">
        <input v-model="username" type="text" placeholder="Username" required />
        <input v-model="password" type="password" placeholder="Password" required />
        <button type="submit">Login</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  import { useRouter } from 'vue-router';
  import { useStore } from 'vuex';
  import AuthService from '../services/AuthService';
  
  export default defineComponent({
    name: 'Login',
    setup() {
      const username = ref('');
      const password = ref('');
      const router = useRouter();
      const store = useStore();
  
      const login = async () => {
        try {
          const { token, user } = await AuthService.login(username.value, password.value);
          AuthService.setToken(token);
          store.commit('setLoggedIn', true);
          store.commit('setUser', user);
          router.push('/');
        } catch (error) {
          console.error('Login failed:', error);
          // Handle login error (e.g., show error message)
        }
      };
  
      return { username, password, login };
    },
  });
  </script>
  
  <style scoped>
  .login {
    max-width: 300px;
    margin: 50px auto;
  }
  </style>==== END OF FILE: frontend/src//views/Login.vue ====

==== START OF FILE: frontend/src//views/Home.vue ====
<template>
    <div class="home">
      <h1>Welcome to FluentCLI Web Services</h1>
      <p>This is the home page.</p>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Home'
  });
  </script>==== END OF FILE: frontend/src//views/Home.vue ====

==== START OF FILE: frontend/src//views/Studio.vue ====
<template>
    <div class="studio">
      <nav class="studio-sidebar">
        <router-link to="/studio/dashboard">Dashboard</router-link>
        <router-link to="/studio/jobs">Jobs</router-link>
        <router-link to="/studio/pipelines">Pipelines</router-link>
        <router-link to="/studio/dockerfiles">Docker Files</router-link>
        <router-link to="/studio/configurations">Configurations</router-link>
        <router-link to="/studio/amberstores">Amber Stores</router-link>
        <!-- Include other navigation links as needed -->
      </nav>
      <main class="studio-main">
        <router-view />
      </main>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  import StudioSidebar from '@/components/studio/StudioSidebar.vue';
  import StudioHeader from '@/components/studio/StudioHeader.vue';
  
  export default defineComponent({
    name: 'Studio',
    components: {
      StudioSidebar,
      StudioHeader,
    },
    setup() {
      const isSidebarCollapsed = ref(false);
  
      const toggleSidebar = () => {
        isSidebarCollapsed.value = !isSidebarCollapsed.value;
      };
  
      return {
        isSidebarCollapsed,
        toggleSidebar,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio {
    display: flex;
    height: calc(100vh - 60px);
  }
  .studio-sidebar {
    width: 200px;
    background-color: #2c3e50;
    padding: 20px;
  }
  .studio-sidebar a {
    display: block;
    color: #ecf0f1;
    text-decoration: none;
    margin-bottom: 10px;
  }
  .studio-sidebar a.router-link-exact-active {
    font-weight: bold;
  }
  .studio-main {
    flex-grow: 1;
    padding: 20px;
  }
  </style>==== END OF FILE: frontend/src//views/Studio.vue ====

==== START OF FILE: frontend/src//views/admin/Login.vue ====
<template>
  <div class="login">
    <h2>Login</h2>
    <form @submit.prevent="login">
      <input v-model="username" type="text" placeholder="Username" required />
      <input v-model="password" type="password" placeholder="Password" required />
      <button type="submit" :disabled="isLoading">
        {{ isLoading ? 'Logging in...' : 'Login' }}
      </button>
    </form>
    <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue';
import { useRouter } from 'vue-router';
import { useStore } from 'vuex';
import AuthService from '@/services/AuthService';

export default defineComponent({
  name: 'Login',
  setup() {
    const username = ref('');
    const password = ref('');
    const errorMessage = ref('');
    const isLoading = ref(false);
    const router = useRouter();
    const store = useStore();

    const login = async () => {
      errorMessage.value = '';
      isLoading.value = true;
      try {
        const { token, user } = await AuthService.login(username.value, password.value);
        AuthService.setToken(token);
        store.commit('setLoggedIn', true);
        store.commit('setUser', user);
        router.push('/');
      } catch (error: any) {
        console.error('Login failed:', error);
        errorMessage.value = error.response?.data?.message || 'Login failed. Please try again.';
      } finally {
        isLoading.value = false;
      }
    };

    return { username, password, login, errorMessage, isLoading };
  },
});
</script>

<style scoped>
.login {
  max-width: 300px;
  margin: 50px auto;
  padding: 20px;
  border: 1px solid #bdc3c7;
  border-radius: 5px;
  background-color: #fff;
}

.login h2 {
  text-align: center;
  margin-bottom: 20px;
}

.login form {
  display: flex;
  flex-direction: column;
}

.login input {
  padding: 10px;
  margin-bottom: 15px;
  border: 1px solid #bdc3c7;
  border-radius: 3px;
}

.login button {
  padding: 10px;
  background-color: #2c3e50;
  color: #ecf0f1;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}

.login button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.error {
  color: red;
  text-align: center;
  margin-top: 10px;
}
</style>==== END OF FILE: frontend/src//views/admin/Login.vue ====

==== START OF FILE: frontend/src//views/Admin.vue ====
<template>
    <div>
      <h1>Admin</h1>
      <nav>
        <RouterLink to="/admin/jobs">Job List</RouterLink> |
        <RouterLink to="/admin/jobs/create">Create Job</RouterLink> 
      </nav>
      <RouterView />
    </div>
  </template>
  
  <script setup lang="ts">
    import { RouterLink, RouterView } from 'vue-router';

  </script>
  
  <style scoped>
    /* Add your styles here */
  </style>==== END OF FILE: frontend/src//views/Admin.vue ====

==== START OF FILE: frontend/src//services/AuthService.ts ====
import apiClient from './apiClient';

interface LoginResponse {
  token: string;
  user: any; // Define a proper type based on your user structure
}

const AuthService = {
  async login(username: string, password: string): Promise<LoginResponse> {
    const response = await apiClient.post('/users/login', { username, password });
    return response.data;
  },

  logout() {
    localStorage.removeItem('token');
    delete apiClient.defaults.headers.common['Authorization'];
    window.location.href = '/login';
  },

  setToken(token: string) {
    localStorage.setItem('token', token);
    apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;
  },

  getToken(): string | null {
    return localStorage.getItem('token');
  },
};

export default AuthService;==== END OF FILE: frontend/src//services/AuthService.ts ====

==== START OF FILE: frontend/src//services/apiClient.ts ====
import axios from 'axios';
import { API_URL } from '@/config';
import AuthService from './AuthService';

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  },
});

// Request interceptor to add the auth token to headers
apiClient.interceptors.request.use(
  (config) => {
    const token = AuthService.getToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor to handle global errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle unauthorized access globally
    if (error.response && error.response.status === 401) {
      AuthService.logout();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default apiClient;==== END OF FILE: frontend/src//services/apiClient.ts ====

==== START OF FILE: frontend/src//store/types.ts ====
export interface RootState {
    // Define your root state properties here
    // For example:
    // user: User | null;
    // isAuthenticated: boolean;
  }==== END OF FILE: frontend/src//store/types.ts ====

==== START OF FILE: frontend/src//store/index.ts ====
import { createStore } from 'vuex';

export default createStore({
  state: {
    isLoggedIn: false,
    user: null,
  },
  mutations: {
    setLoggedIn(state, value: boolean) {
      state.isLoggedIn = value;
    },
    setUser(state, user: any) {
      state.user = user;
    },
  },
  actions: {
    login({ commit }, { user }) { // Removed 'token' since it's unused
      commit('setLoggedIn', true);
      commit('setUser', user);
    },
    logout({ commit }) {
      commit('setLoggedIn', false);
      commit('setUser', null);
    },
  },
  getters: {
    isLoggedIn: (state) => state.isLoggedIn,
    user: (state) => state.user,
  },
});==== END OF FILE: frontend/src//store/index.ts ====

==== START OF FILE: frontend/src//store/modules/studio.ts ====
import { Module } from 'vuex';
import { RootState } from '../types';

interface StudioState {
  openTabs: Array<{ id: string; name: string; type: string; data: any }>;
  activeTabId: string | null;
}

const studioModule: Module<StudioState, RootState> = {
  namespaced: true,
  state: {
    openTabs: [],
    activeTabId: null,
  },
  mutations: {
    addTab(state, tab) {
      state.openTabs.push(tab);
      state.activeTabId = tab.id;
    },
    closeTab(state, tabId) {
      const index = state.openTabs.findIndex((tab) => tab.id === tabId);
      if (index !== -1) {
        state.openTabs.splice(index, 1);
        if (state.activeTabId === tabId) {
          state.activeTabId = state.openTabs.length > 0 ? state.openTabs[0].id : null;
        }
      }
    },
    setActiveTab(state, tabId) {
      state.activeTabId = tabId;
    },
    updateTabData(state, { tabId, data }) {
      const tab = state.openTabs.find((tab) => tab.id === tabId);
      if (tab) {
        tab.data = data;
      }
    },
  },
  actions: {
    openTab({ commit, state }, { id, name, type, data }) {
      const existingTab = state.openTabs.find((tab) => tab.id === id);
      if (existingTab) {
        commit('setActiveTab', id);
      } else {
        commit('addTab', { id, name, type, data });
      }
    },
  },
  getters: {
    activeTab: (state) => state.openTabs.find((tab) => tab.id === state.activeTabId),
  },
};

export default studioModule;==== END OF FILE: frontend/src//store/modules/studio.ts ====

==== START OF FILE: frontend/src//router/index.ts ====
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router';
import Home from '../views/Home.vue';
import Login from '../views/Login.vue';
import Admin from '../views/Admin.vue';
import Studio from '../views/Studio.vue';
import Dashboard from '../views/studio/Dashboard.vue';

import Pipelines from '../views/studio/Pipelines.vue';
import Settings from '../views/studio/Settings.vue';

import PipelineList from '../components/studio/PipelineList.vue';
import PipelineCreate from '../views/studio/PipelineCreate.vue';
import PipelineDetails from '../views/studio/PipelineDetails.vue';
import PipelineEdit from '../views/studio/PipelineEdit.vue';
import DockerFiles from '../views/studio/DockerFiles.vue';
import AmberStores from '../views/studio/AmberStores.vue';
import Jobs from '../views/studio/Jobs.vue';

import store from '@/store';

const routes: Array<RouteRecordRaw> = [
  { path: '/', name: 'Home', component: Home },
  { path: '/login', name: 'Login', component: Login },
  { path: '/admin', name: 'Admin', component: Admin },
  { 
    path: '/studio', 
    name: 'Studio', 
    component: Studio,
    meta: { requiresAuth: true },
    children: [
      { path: 'dashboard', name: 'Dashboard', component: Dashboard },
      {
        path: '/studio/jobs',
        name: 'Jobs',
        component: Jobs,
      },
      { path: 'pipelines', name: 'Pipelines', component: Pipelines },
      { path: 'settings', name: 'Settings', component: Settings },
      {
        path: 'pipelines',
        name: 'PipelineList',
        component: PipelineList,
      },
      {
        path: 'pipelines/create',
        name: 'PipelineCreate',
        component: PipelineCreate,
      },
      {
        path: 'pipelines/:id',
        name: 'PipelineDetails',
        component: PipelineDetails,
        props: true,
      },
      {
        path: 'pipelines/:id/edit',
        name: 'PipelineEdit',
        component: PipelineEdit,
        props: true,
      },
      {
        path: 'dockerfiles',
        name: 'DockerFiles',
        component: DockerFiles,
      },
      {
        path: '/studio/configurations',
        name: 'Configurations',
        component: () => import('@/views/studio/Configurations.vue')
      },
      {
        path: '/studio/amberstores',
        name: 'AmberStores',
        component: AmberStores,
      },
    ],
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// Navigation Guard
router.beforeEach((to, _, next) => {
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
  const isLoggedIn = store.getters.isLoggedIn;

  if (requiresAuth && !isLoggedIn) {
    next('/login');
  } else if (to.path === '/login' && isLoggedIn) {
    next('/');
  } else {
    next();
  }
});

export default router;==== END OF FILE: frontend/src//router/index.ts ====

