==== START OF FILE: src//error.rs ====
// src/error.rs

use thiserror::Error;
use std::error::Error as StdError;
use diesel::r2d2;
use actix_web;
use actix_web::ResponseError;
use actix_web::http::StatusCode;

#[derive(Error, Debug)]
pub enum AppError {
    #[error("Database error: {0}")]
    DatabaseError(#[from] diesel::result::Error),

    #[error("Environment variable not found: {0}")]
    EnvVarError(#[from] std::env::VarError),

    #[error("Not found")]
    NotFound,

    #[error("Bad request: {0}")]
    BadRequest(String),

    #[error("R2D2 error: {0}")]
    R2D2Error(#[from] r2d2::PoolError),

    #[error("Unauthorized")]
    Unauthorized,

    #[error("Internal server error")]
    InternalServerError,

    #[error("Generic error: {0}")]
    GenericError(Box<dyn StdError + Send + Sync>),

    #[error("Migration error: {0}")]
    MigrationError(#[from] diesel_migrations::MigrationError),

    #[error("Authentication error")]
    AuthenticationError,

    #[error("Fluent CLI error: {0}")]
    FluentCLIError(String),
}

impl From<Box<dyn StdError + Send + Sync>> for AppError {
    fn from(error: Box<dyn StdError + Send + Sync>) -> Self {
        AppError::GenericError(error)
    }
}

impl ResponseError for AppError {
    fn status_code(&self) -> StatusCode {
        match self {
            AppError::NotFound => StatusCode::NOT_FOUND,
            AppError::BadRequest(_) => StatusCode::BAD_REQUEST,
            AppError::Unauthorized => StatusCode::UNAUTHORIZED,
            AppError::AuthenticationError => StatusCode::UNAUTHORIZED,
            _ => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    fn error_response(&self) -> actix_web::HttpResponse {
        actix_web::HttpResponse::build(self.status_code())
            .json(serde_json::json!({ "error": self.to_string() }))
    }
}
==== END OF FILE: src//error.rs ====

==== START OF FILE: src//config.rs ====
==== END OF FILE: src//config.rs ====

==== START OF FILE: src//lib.rs ====
pub mod error;
mod db;
mod models;
pub mod schema;
pub mod handlers;
pub mod routes;
pub mod services;
pub mod utils;
==== END OF FILE: src//lib.rs ====

==== START OF FILE: src//utils/error.rs ====
==== END OF FILE: src//utils/error.rs ====

==== START OF FILE: src//utils/encryption.rs ====
use aes::Aes256;
use block_modes::{BlockMode, Cbc};
use block_modes::block_padding::Pkcs7;
use hex;
use rand::Rng;
use std::env;
use std::str;

type Aes256Cbc = Cbc<Aes256, Pkcs7>;

fn get_key() -> Vec<u8> {
    let key = env::var("ENCRYPTION_KEY").expect("ENCRYPTION_KEY must be set");
    hex::decode(key).expect("Invalid ENCRYPTION_KEY")
}

pub fn encrypt_data(data: &str) -> String {
    let key = get_key();
    let iv = rand::thread_rng().gen::<[u8; 16]>();
    let cipher = Aes256Cbc::new_from_slices(&key, &iv).unwrap();
    let ciphertext = cipher.encrypt_vec(data.as_bytes());
    format!("{}:{}", hex::encode(iv), hex::encode(ciphertext))
}

pub fn decrypt_data(encrypted_data: &str) -> String {
    let key = get_key();
    let parts: Vec<&str> = encrypted_data.split(':').collect();
    let iv = hex::decode(parts[0]).unwrap();
    let ciphertext = hex::decode(parts[1]).unwrap();
    let cipher = Aes256Cbc::new_from_slices(&key, &iv).unwrap();
    let decrypted_data = cipher.decrypt_vec(&ciphertext).unwrap();
    str::from_utf8(&decrypted_data).unwrap().to_string()
}==== END OF FILE: src//utils/encryption.rs ====

==== START OF FILE: src//utils/auth.rs ====
use actix_web::{dev::ServiceRequest, Error, HttpMessage};
use actix_web::dev::{Service, Transform};
use futures::future::{ok, Ready};
use futures::Future;
use std::pin::Pin;
use bcrypt::{DEFAULT_COST, hash, verify};
use crate::utils::jwt::validate_token;
use crate::error::AppError;

pub fn hash_password(password: &str) -> Result<String, AppError> {
    hash(password, DEFAULT_COST).map_err(|_| AppError::InternalServerError)
}

pub fn verify_password(password: &str, hash: &str) -> Result<bool, AppError> {
    verify(password, hash).map_err(|_| AppError::InternalServerError)
}

pub struct Auth;

impl<S, B> Transform<S, ServiceRequest> for Auth
where
    S: Service<ServiceRequest, Response = actix_web::dev::ServiceResponse<B>, Error = Error> + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Transform = AuthMiddleware<S>;
    type InitError = ();
    type Future = Ready<Result<Self::Transform, Self::InitError>>;

    fn new_transform(&self, service: S) -> Self::Future {
        ok(AuthMiddleware { service })
    }
}

pub struct AuthMiddleware<S> {
    service: S,
}

impl<S, B> Service<ServiceRequest> for AuthMiddleware<S>
where
    S: Service<ServiceRequest, Response = actix_web::dev::ServiceResponse<B>, Error = Error> + 'static,
    S::Future: 'static,
    B: 'static,
{
    type Response = S::Response;
    type Error = S::Error;
    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>>>>;

    fn poll_ready(&self, cx: &mut std::task::Context<'_>) -> std::task::Poll<Result<(), Self::Error>> {
        self.service.poll_ready(cx)
    }

    fn call(&self, req: ServiceRequest) -> Self::Future {
        let auth_header = req.headers().get("Authorization").and_then(|h| h.to_str().ok());

        if let Some(auth_header) = auth_header {
            if auth_header.starts_with("Bearer ") {
                let token = &auth_header[7..];
                match validate_token(token) {
                    Ok(user_id) => {
                        req.extensions_mut().insert(user_id);
                        let fut = self.service.call(req);
                        return Box::pin(async move {
                            let res = fut.await?;
                            Ok(res)
                        });
                    }
                    Err(_) => {
                        return Box::pin(async { Err(actix_web::error::ErrorUnauthorized("Invalid token")) });
                    }
                }
            }
        }

        Box::pin(async { Err(actix_web::error::ErrorUnauthorized("Authorization header missing or malformed")) })
    }
}==== END OF FILE: src//utils/auth.rs ====

==== START OF FILE: src//utils/mod.rs ====
pub mod auth;
pub mod jwt;
pub mod encryption;==== END OF FILE: src//utils/mod.rs ====

==== START OF FILE: src//utils/jwt.rs ====
use crate::error::AppError;
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::env;
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: Uuid,
    exp: usize,
}

pub fn generate_token(user_id: Uuid) -> Result<String, AppError> {
    let expiration = chrono::Utc::now()
        .checked_add_signed(chrono::Duration::hours(24))
        .expect("valid timestamp")
        .timestamp();

    let claims = Claims {
        sub: user_id,
        exp: expiration as usize,
    };

    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(secret.as_bytes()),
    )
    .map_err(|_| AppError::InternalServerError)
}

pub fn validate_token(token: &str) -> Result<Uuid, AppError> {
    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    let token_data = decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret.as_bytes()),
        &Validation::default(),
    )
    .map_err(|_| AppError::AuthenticationError)?;

    Ok(token_data.claims.sub)
}
==== END OF FILE: src//utils/jwt.rs ====

==== START OF FILE: src//models/docker_file.rs ====
use crate::schema::docker_files;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = docker_files)]
pub struct DockerFile {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub content: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "docker_files"]
pub struct NewDockerFile {
    pub user_id: Uuid,
    pub name: String,
    pub content: String,
}

#[derive(Deserialize, Debug)]
pub struct NewDockerFilePayload {
    pub name: String,
    pub content: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "docker_files"]
pub struct UpdateDockerFile {
    pub name: Option<String>,
    pub content: Option<String>,
}==== END OF FILE: src//models/docker_file.rs ====

==== START OF FILE: src//models/job.rs ====
use crate::schema::jobs;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = jobs)]
pub struct Job {
    pub id: Uuid,
    pub user_id: Uuid,
    pub uri: String,
    pub config: Value, // Reference to configuration ID
    pub amber_id: Option<Uuid>, // Reference to amber_store ID
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String, // Reference to docker_file ID
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
}

#[derive(Insertable, Debug)]
#[table_name = "jobs"]
pub struct NewJob {
    pub user_id: Uuid,
    pub uri: String,
    pub config: Value,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
}

#[derive(Deserialize, Debug)]
pub struct NewJobPayload {
    pub uri: String,
    pub config: Value,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: String,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "jobs"]
pub struct UpdateJob {
    pub uri: Option<String>,
    pub config: Option<Value>,
    pub amber_id: Option<Uuid>,
    pub state_file_content: Option<String>,
    pub data_path: Option<String>,
    pub worker_type: Option<String>,
    pub triggers: Option<Value>,
    pub timers: Option<Value>,
    pub status: Option<String>,
}==== END OF FILE: src//models/job.rs ====

==== START OF FILE: src//models/configuration.rs ====
use crate::schema::configurations;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = configurations)]
pub struct Configuration {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}


#[derive(Insertable, Debug)]
#[table_name = "configurations"]
pub struct NewConfiguration {
    pub user_id: Uuid,
    pub name: String,
    pub data: serde_json::Value,
}

#[derive(Deserialize, Debug)]
pub struct NewConfigurationPayload {
    pub name: String,
    pub data: serde_json::Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "configurations"]
pub struct UpdateConfiguration {
    pub name: Option<String>,
    pub data: Option<serde_json::Value>,
}==== END OF FILE: src//models/configuration.rs ====

==== START OF FILE: src//models/worker.rs ====
use crate::schema::workers;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = workers)]
pub struct Worker {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub worker_type: Uuid, // Reference to docker_file ID
    pub active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "workers"]
pub struct NewWorker {
    pub user_id: Uuid,
    pub name: String,
    pub worker_type: Uuid,
    pub active: bool,
}

#[derive(Deserialize, Debug)]
pub struct NewWorkerPayload {
    pub name: String,
    pub worker_type: Uuid,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "workers"]
pub struct UpdateWorker {
    pub name: Option<String>,
    pub worker_type: Option<Uuid>,
    pub active: Option<bool>,
}==== END OF FILE: src//models/worker.rs ====

==== START OF FILE: src//models/user.rs ====
use crate::schema::users;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Serialize, Deserialize)]
#[diesel(table_name = users)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Deserialize)]
pub struct NewUser {
    pub username: String,
    pub email: String,
    pub password: String, // This field is not in the database, but used for user creation
}

#[derive(Insertable)]
#[diesel(table_name = users)]
pub struct NewUserDB {
    pub username: String,
    pub email: String,
    pub password_hash: String,
}

#[derive(AsChangeset, Deserialize)]
#[diesel(table_name = users)]
pub struct UpdateUser {
    pub username: Option<String>,
    pub email: Option<String>,
}
==== END OF FILE: src//models/user.rs ====

==== START OF FILE: src//models/active_worker.rs ====
use crate::schema::active_workers;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = active_workers)]
pub struct ActiveWorker {
    pub id: Uuid,
    pub user_id: Uuid,
    pub worker_type: String,
    pub is_active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}==== END OF FILE: src//models/active_worker.rs ====

==== START OF FILE: src//models/amber_store.rs ====
use crate::schema::amber_store;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = amber_store)]
pub struct AmberStore {
    pub id: Uuid,
    pub user_id: Uuid,
    pub data: serde_json::Value,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}
#[derive(Insertable, Debug)]
#[table_name = "amber_store"]
pub struct NewAmberStore {
    pub user_id: Uuid,
    pub data: serde_json::Value,
}

#[derive(Deserialize, Debug)]
pub struct NewAmberStorePayload {
    pub data: serde_json::Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "amber_store"]
pub struct UpdateAmberStore {
    pub data: Option<serde_json::Value>,
}==== END OF FILE: src//models/amber_store.rs ====

==== START OF FILE: src//models/mod.rs ====

pub mod user;
pub mod api_key;
pub mod amber_store;
pub mod secure_vault;
pub mod configuration;
pub mod pipeline;
pub mod docker_file;
pub mod active_worker;
pub mod job;
pub mod worker;==== END OF FILE: src//models/mod.rs ====

==== START OF FILE: src//models/pipeline.rs ====
use crate::schema::pipelines;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = pipelines)]
pub struct Pipeline {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "pipelines"]
pub struct NewPipeline {
    pub user_id: Uuid,
    pub name: String,
    pub data: Value,
}

#[derive(Deserialize, Debug)]
pub struct NewPipelinePayload {
    pub name: String,
    pub data: Value,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "pipelines"]
pub struct UpdatePipeline {
    pub name: Option<String>,
    pub data: Option<Value>,
}==== END OF FILE: src//models/pipeline.rs ====

==== START OF FILE: src//models/secure_vault.rs ====
use crate::schema::secure_vaults;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = secure_vaults)]
pub struct SecureVault {
    pub id: Uuid,
    pub user_id: Uuid,
    pub name: String,
    pub encrypted_data: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Insertable, Debug)]
#[table_name = "secure_vaults"]
pub struct NewSecureVault {
    pub user_id: Uuid,
    pub name: String,
    pub encrypted_data: String,
}

#[derive(Deserialize, Debug)]
pub struct NewSecureVaultPayload {
    pub name: String,
    pub data: String,
}

#[derive(AsChangeset, Deserialize)]
#[table_name = "secure_vaults"]
pub struct UpdateSecureVault {
    pub name: Option<String>,
    pub encrypted_data: Option<String>,
}==== END OF FILE: src//models/secure_vault.rs ====

==== START OF FILE: src//models/api_key.rs ====
use crate::schema::api_keys;
use chrono::{DateTime, Utc};
use diesel::prelude::*;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Queryable, Identifiable, Insertable, AsChangeset, Debug, Serialize, Deserialize)]
#[diesel(table_name = api_keys)]
pub struct ApiKey {
    pub id: Uuid,
    pub user_id: Uuid,
    pub key_value: String,
    pub description: Option<String>,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
}
==== END OF FILE: src//models/api_key.rs ====

==== START OF FILE: src//routes.rs ====
use actix_web::{web, HttpResponse, Scope};
use crate::utils::auth::Auth;
use crate::handlers::{user, job, api_key, amber_store, secure_vault, configuration, pipeline, docker_file, worker};

pub fn configure_routes() -> Scope {
    web::scope("")
        // User routes
        .service(
            web::scope("/users")
                .route("", web::post().to(user::create_user))
                .route("", web::get().to(user::list_users))
                .route("/{id}", web::get().to(user::get_user))
                .route("/{id}", web::put().to(user::update_user))
                .route("/{id}", web::delete().to(user::delete_user))
                .route("/login", web::post().to(user::login))
                .route("/refresh", web::post().to(user::refresh_token))
                
        )
        // API Key routes
        .service(
            web::scope("/api_keys")
                .route("", web::post().to(api_key::create_api_key))
                .route("", web::get().to(api_key::list_api_keys))
                .route("/{id}", web::delete().to(api_key::delete_api_key))
        )
        // Job routes
        .service(
            web::scope("/jobs")
                .wrap(Auth)
                    .route("", web::post().to(job::create_job))
                    .route("", web::get().to(job::list_jobs))
                    .route("/{id}", web::get().to(job::get_job))
                    .route("/{id}", web::put().to(job::update_job))
                    .route("/{id}", web::delete().to(job::delete_job))
                    .route("/{id}/start", web::post().to(job::start_job))
                    .route("/{id}/stop", web::post().to(job::stop_job))
                    .route("/{id}/status", web::get().to(job::get_job_status))
                    .route("/{id}/output", web::get().to(job::get_job_output))
                    .route("/{id}/logs", web::get().to(job::get_job_logs))
        )
        // Amber Store routes
        .service(
            web::scope("/amber_store")
            .wrap(Auth)
                .route("", web::post().to(amber_store::create_amber_store))
                .route("", web::get().to(amber_store::list_amber_stores))
                .route("/{id}", web::get().to(amber_store::get_amber_store))
                .route("/{id}", web::put().to(amber_store::update_amber_store))
                .route("/{id}", web::delete().to(amber_store::delete_amber_store))
        )

        // Vault Store routes
        .service(
            web::scope("/secure_vaults")
            .wrap(Auth)
                .route("", web::post().to(secure_vault::create_secure_vault))
                .route("", web::get().to(secure_vault::list_secure_vaults))
                .route("/{id}", web::get().to(secure_vault::get_secure_vault))
                .route("/{id}", web::put().to(secure_vault::update_secure_vault))
                .route("/{id}", web::delete().to(secure_vault::delete_secure_vault))
        )
        // Configuration routes
        .service(
            web::scope("/configurations")
                .wrap(Auth)
                    .route("", web::post().to(configuration::create_configuration))
                    .route("", web::get().to(configuration::list_configurations))
                    .route("/{id}", web::get().to(configuration::get_configuration))
                    .route("/{id}", web::put().to(configuration::update_configuration))
                    .route("/{id}", web::delete().to(configuration::delete_configuration))
        )
        // Pipeline routes
        .service(
            web::scope("/pipelines")
                .wrap(Auth)
                    .route("", web::post().to(pipeline::create_pipeline))
                    .route("", web::get().to(pipeline::list_pipelines))
                    .route("/{id}", web::get().to(pipeline::get_pipeline))
                    .route("/{id}", web::put().to(pipeline::update_pipeline))
                    .route("/{id}", web::delete().to(pipeline::delete_pipeline))
        )
        // Docker File routes
        .service(
            web::scope("/docker_files")
            .wrap(Auth)
                .route("", web::post().to(docker_file::create_docker_file))
                .route("", web::get().to(docker_file::list_docker_files))
                .route("/{id}", web::get().to(docker_file::get_docker_file))
                .route("/{id}", web::put().to(docker_file::update_docker_file))
                .route("/{id}", web::delete().to(docker_file::delete_docker_file))
        )

        // Worker routes
        .service(
            web::scope("/workers")
            .wrap(Auth)
                .route("", web::post().to(worker::create_worker))
                .route("", web::get().to(worker::list_workers))
                .route("/{id}", web::get().to(worker::get_worker))
                .route("/{id}", web::put().to(worker::update_worker))
                .route("/{id}", web::delete().to(worker::delete_worker))
                .route("/{id}/activate", web::post().to(worker::activate_worker))
                .route("/{id}/deactivate", web::post().to(worker::deactivate_worker))
        )
}

==== END OF FILE: src//routes.rs ====

==== START OF FILE: src//schema.rs ====
// @generated automatically by Diesel CLI.

diesel::table! {
    active_workers (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        worker_type -> Varchar,
        is_active -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    amber_store (id) {
        id -> Uuid,
        user_id -> Uuid,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    api_keys (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        key_value -> Varchar,
        description -> Nullable<Text>,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        expires_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    configurations (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    docker_files (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        content -> Text,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    jobs (id) {
        id -> Uuid,
        user_id -> Uuid,
        uri -> Text,
        config -> Jsonb,
        amber_id -> Nullable<Uuid>,
        state_file_content -> Nullable<Text>,
        data_path -> Nullable<Text>,
        #[max_length = 255]
        worker_type -> Varchar,
        triggers -> Nullable<Jsonb>,
        timers -> Nullable<Jsonb>,
        #[max_length = 255]
        status -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
        started_at -> Nullable<Timestamptz>,
        completed_at -> Nullable<Timestamptz>,
    }
}

diesel::table! {
    pipelines (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    secure_vault (id) {
        id -> Uuid,
        user_id -> Uuid,
        data -> Jsonb,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    secure_vaults (id) {
        id -> Uuid,
        user_id -> Uuid,
        #[max_length = 255]
        name -> Varchar,
        encrypted_data -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    users (id) {
        id -> Uuid,
        #[max_length = 255]
        username -> Varchar,
        #[max_length = 255]
        email -> Varchar,
        #[max_length = 255]
        password_hash -> Varchar,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::table! {
    workers (id) {
        id -> Uuid,
        user_id -> Uuid,
        name -> Varchar,
        worker_type -> Uuid,
        active -> Bool,
        created_at -> Timestamptz,
        updated_at -> Timestamptz,
    }
}

diesel::joinable!(active_workers -> users (user_id));
diesel::joinable!(amber_store -> users (user_id));
diesel::joinable!(api_keys -> users (user_id));
diesel::joinable!(configurations -> users (user_id));
diesel::joinable!(docker_files -> users (user_id));
diesel::joinable!(jobs -> amber_store (amber_id));
diesel::joinable!(jobs -> users (user_id));
diesel::joinable!(pipelines -> users (user_id));
diesel::joinable!(secure_vault -> users (user_id));
diesel::joinable!(secure_vaults -> users (user_id));
diesel::joinable!(workers -> docker_files (worker_type));

diesel::allow_tables_to_appear_in_same_query!(
    active_workers,
    amber_store,
    api_keys,
    configurations,
    docker_files,
    jobs,
    pipelines,
    secure_vault,
    secure_vaults,
    users,
    workers,
);
==== END OF FILE: src//schema.rs ====

==== START OF FILE: src//db/db.rs ====
use diesel::pg::PgConnection;
use diesel::r2d2::{ConnectionManager, Pool, PoolError};
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use dotenv::dotenv;
use std::env;
use crate::error::AppError;

pub type DbPool = Pool<ConnectionManager<PgConnection>>;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("migrations");

pub fn create_db_pool() -> Result<DbPool, PoolError> {
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    Pool::builder().build(manager)
}

pub fn setup_database(pool: &DbPool) -> Result<(), AppError> {
    let mut conn = pool.get()?;
    conn.run_pending_migrations(MIGRATIONS)?;
    Ok(())
}==== END OF FILE: src//db/db.rs ====

==== START OF FILE: src//db/mod.rs ====
pub mod db;

pub use db::{create_db_pool, setup_database, DbPool};==== END OF FILE: src//db/mod.rs ====

==== START OF FILE: src//main.rs ====
mod db;
mod error;
mod models;
mod schema;
mod routes;
mod handlers;
mod services;
mod utils;
use dotenv::dotenv;

use actix_web::{App, HttpServer, http, middleware, web};
use actix_cors::Cors;

use db::{create_db_pool, setup_database};
use routes::configure_routes;


#[actix_web::main]
async fn main() -> std::io::Result<()> {
    std::env::set_var("RUST_LOG", "debug"); //remove at release
    dotenv().ok();
    env_logger::init();

    // Set up the database
    let pool = create_db_pool().expect("Failed to create database pool");
    setup_database(&pool).expect("Failed to set up database");
    println!("Database setup complete");


    HttpServer::new(move || {
        let cors = Cors::default()
            .allow_any_origin() // Be cautious with this in production environments
            .allowed_methods(vec!["GET", "POST", "PUT", "DELETE"])
            .allowed_headers(vec![http::header::AUTHORIZATION, http::header::ACCEPT])
            .allowed_header(http::header::CONTENT_TYPE)
            .max_age(3600);

        App::new()
            .wrap(cors)
            .wrap(middleware::Logger::default())
            .app_data(web::Data::new(pool.clone()))
            .service(configure_routes())
    })



    .bind("0.0.0.0:8000")?
    .run()
    .await
}==== END OF FILE: src//main.rs ====

==== START OF FILE: src//handlers/docker_file.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::docker_file_service::DockerFileService;
use crate::models::docker_file::{NewDockerFile, UpdateDockerFile, NewDockerFilePayload};

pub async fn create_docker_file(
    pool: web::Data<DbPool>,
    new_docker_file_payload: web::Json<NewDockerFilePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating docker file for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_docker_file_payload);

    let new_docker_file = NewDockerFile {
        user_id,
        name: new_docker_file_payload.name.clone(),
        content: new_docker_file_payload.content.clone(),
    };
    match DockerFileService::create_docker_file(&pool, new_docker_file) {
        Ok(docker_file) => {
            log::info!("Docker file created successfully: {:?}", docker_file);
            HttpResponse::Created().json(docker_file)
        },
        Err(e) => {
            log::error!("Error creating docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create docker file")
        }
    }
}

pub async fn list_docker_files(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::list_docker_files(&pool, user_id) {
        Ok(docker_files) => HttpResponse::Ok().json(docker_files),
        Err(e) => {
            log::error!("Error listing docker files: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list docker files")
        }
    }
}

pub async fn get_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::get_docker_file(&pool, docker_file_id.into_inner(), user_id) {
        Ok(docker_file) => HttpResponse::Ok().json(docker_file),
        Err(e) => {
            log::error!("Error getting docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get docker file")
        }
    }
}

pub async fn update_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    update_data: web::Json<UpdateDockerFile>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::update_docker_file(&pool, docker_file_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(docker_file) => HttpResponse::Ok().json(docker_file),
        Err(e) => {
            log::error!("Error updating docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update docker file")
        }
    }
}

pub async fn delete_docker_file(
    pool: web::Data<DbPool>,
    docker_file_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match DockerFileService::delete_docker_file(&pool, docker_file_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting docker file: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete docker file")
        }
    }
}==== END OF FILE: src//handlers/docker_file.rs ====

==== START OF FILE: src//handlers/job.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::job_service::JobService;
use crate::models::job::{NewJob, UpdateJob, NewJobPayload};

pub async fn create_job(
    pool: web::Data<DbPool>,
    new_job_payload: web::Json<NewJobPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating job for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_job_payload);

    let new_job = NewJob {
        user_id,
        uri: new_job_payload.uri.clone(),
        config: new_job_payload.config.clone(),
        amber_id: new_job_payload.amber_id,
        state_file_content: new_job_payload.state_file_content.clone(),
        data_path: new_job_payload.data_path.clone(),
        worker_type: new_job_payload.worker_type.clone(),
        triggers: new_job_payload.triggers.clone(),
        timers: new_job_payload.timers.clone(),
        status: new_job_payload.status.clone(),
    };
    log::info!("New job data: {:?}", new_job);

    match JobService::create_job(&pool, new_job) {
        Ok(job) => {
            log::info!("Job created successfully: {:?}", job);
            HttpResponse::Created().json(job)
        },
        Err(e) => {
            log::error!("Error creating job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create job")
        }
    }
}

pub async fn list_jobs(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::list_jobs(&pool, user_id) {
        Ok(jobs) => HttpResponse::Ok().json(jobs),
        Err(e) => {
            log::error!("Error listing jobs: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list jobs")
        }
    }
}

pub async fn get_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error getting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job")
        }
    }
}

pub async fn update_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    update_data: web::Json<UpdateJob>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::update_job(&pool, job_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error updating job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update job")
        }
    }
}

pub async fn delete_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::delete_job(&pool, job_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete job")
        }
    }
}

pub async fn start_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::start_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error starting job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to start job")
        }
    }
}

pub async fn stop_job(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::stop_job(&pool, job_id.into_inner(), user_id) {
        Ok(job) => HttpResponse::Ok().json(job),
        Err(e) => {
            log::error!("Error stopping job: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to stop job")
        }
    }
}

pub async fn get_job_status(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_status(&pool, job_id.into_inner(), user_id) {
        Ok(status) => HttpResponse::Ok().json(status),
        Err(e) => {
            log::error!("Error getting job status: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job status")
        }
    }
}

pub async fn get_job_output(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_output(&pool, job_id.into_inner(), user_id) {
        Ok(output) => HttpResponse::Ok().json(output),
        Err(e) => {
            log::error!("Error getting job output: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job output")
        }
    }
}

pub async fn get_job_logs(
    pool: web::Data<DbPool>,
    job_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match JobService::get_job_logs(&pool, job_id.into_inner(), user_id) {
        Ok(logs) => HttpResponse::Ok().json(logs),
        Err(e) => {
            log::error!("Error getting job logs: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get job logs")
        }
    }
}==== END OF FILE: src//handlers/job.rs ====

==== START OF FILE: src//handlers/configuration.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::configuration_service::ConfigurationService;
use crate::models::configuration::{NewConfiguration, UpdateConfiguration, NewConfigurationPayload};

pub async fn create_configuration(
    pool: web::Data<DbPool>,
    new_configuration_payload: web::Json<NewConfigurationPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating configuration for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_configuration_payload);

    let new_configuration = NewConfiguration {
        user_id,
        name: new_configuration_payload.name.clone(),
        data: new_configuration_payload.data.clone(),
    };
    match ConfigurationService::create_configuration(&pool, new_configuration) {
        Ok(configuration) => {
            log::info!("Configuration created successfully: {:?}", configuration);
            HttpResponse::Created().json(configuration)
        },
        Err(e) => {
            log::error!("Error creating configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create configuration")
        }
    }
}

pub async fn list_configurations(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::list_configurations(&pool, user_id) {
        Ok(configurations) => HttpResponse::Ok().json(configurations),
        Err(e) => {
            log::error!("Error listing configurations: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list configurations")
        }
    }
}

pub async fn get_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::get_configuration(&pool, configuration_id.into_inner(), user_id) {
        Ok(configuration) => HttpResponse::Ok().json(configuration),
        Err(e) => {
            log::error!("Error getting configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get configuration")
        }
    }
}

pub async fn update_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    update_data: web::Json<UpdateConfiguration>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::update_configuration(&pool, configuration_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(configuration) => HttpResponse::Ok().json(configuration),
        Err(e) => {
            log::error!("Error updating configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update configuration")
        }
    }
}

pub async fn delete_configuration(
    pool: web::Data<DbPool>,
    configuration_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match ConfigurationService::delete_configuration(&pool, configuration_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting configuration: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete configuration")
        }
    }
}==== END OF FILE: src//handlers/configuration.rs ====

==== START OF FILE: src//handlers/worker.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::worker_service::WorkerService;
use crate::models::worker::{NewWorker, UpdateWorker, NewWorkerPayload};


pub async fn create_worker(
    pool: web::Data<DbPool>,
    new_worker_payload: web::Json<NewWorkerPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating worker for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_worker_payload);

    let new_worker = NewWorker {
        user_id,
        name: new_worker_payload.name.clone(),
        worker_type: new_worker_payload.worker_type,
        active: false,
    };
    log::info!("New worker data: {:?}", new_worker);

    match WorkerService::create_worker(&pool, new_worker) {
        Ok(worker) => {
            log::info!("Worker created successfully: {:?}", worker);
            HttpResponse::Created().json(worker)
        },
        Err(e) => {
            log::error!("Error creating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create worker")
        }
    }
}

pub async fn list_workers(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::list_workers(&pool, user_id) {
        Ok(workers) => HttpResponse::Ok().json(workers),
        Err(e) => {
            log::error!("Error listing workers: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list workers")
        }
    }
}

pub async fn get_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::get_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error getting worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get worker")
        }
    }
}

pub async fn update_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    update_data: web::Json<UpdateWorker>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::update_worker(&pool, worker_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error updating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update worker")
        }
    }
}

pub async fn delete_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::delete_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete worker")
        }
    }
}

pub async fn activate_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::activate_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error activating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to activate worker")
        }
    }
}

pub async fn deactivate_worker(
    pool: web::Data<DbPool>,
    worker_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match WorkerService::deactivate_worker(&pool, worker_id.into_inner(), user_id) {
        Ok(worker) => HttpResponse::Ok().json(worker),
        Err(e) => {
            log::error!("Error deactivating worker: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to deactivate worker")
        }
    }
}==== END OF FILE: src//handlers/worker.rs ====

==== START OF FILE: src//handlers/user.rs ====
use crate::models::user::{NewUser, UpdateUser};
use crate::error::AppError;

use actix_web::{web, HttpResponse, Responder, Error};
use crate::db::DbPool;
use serde_json::json; 
use uuid::Uuid;





use crate::services::user_service::UserService;
use crate::utils::jwt::generate_token;
use serde::{Deserialize};

#[derive(Deserialize)]
pub struct LoginRequest {
    username: String,
    password: String,
}


pub async fn create_user(
    pool: web::Data<DbPool>,
    new_user: web::Json<NewUser>,
) -> Result<HttpResponse, AppError> {
    if UserService::email_exists(&pool, &new_user.email)? {
        return Err(AppError::BadRequest("Email already in use".into()));
    }

    let user = UserService::create_user(&pool, new_user.into_inner())?;
    Ok(HttpResponse::Created().json(user))
}

pub async fn login(
    pool: web::Data<DbPool>,
    login_req: web::Json<LoginRequest>,
) -> Result<HttpResponse, Error> {
    match UserService::login(&pool, &login_req.username, &login_req.password) {
        Ok(user) => {
            match generate_token(user.id) {
                Ok(token) => Ok(HttpResponse::Ok().json(json!({ "token": token, "user": user }))),
                Err(e) => {
                    log::error!("Token generation error: {:?}", e);
                    Err(actix_web::error::ErrorInternalServerError("Failed to generate token"))
                }
            }
        },
        Err(e) => {
            log::error!("Login error: {:?}", e);
            match e {
                AppError::AuthenticationError => Err(actix_web::error::ErrorUnauthorized("Invalid credentials")),
                _ => Err(actix_web::error::ErrorInternalServerError("Login failed"))
            }
        }
    }
}

pub async fn list_users(pool: web::Data<DbPool>) -> Result<HttpResponse, Error> {
    match UserService::list_users(&pool) {
        Ok(users) => Ok(HttpResponse::Ok().json(users)),
        Err(e) => {
            log::error!("Error listing users: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to list users"))
        }
    }
}

use actix_web::HttpRequest;

pub async fn get_user(
    req: HttpRequest,
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
) -> Result<HttpResponse, Error> {
    log::info!("Received GET user request. User ID: {:?}, Headers: {:?}", user_id, req.headers());
    match UserService::get_user(&pool, user_id.into_inner()) {
        Ok(user) => Ok(HttpResponse::Ok().json(user)),
        Err(e) => {
            log::error!("Error getting user: {:?}", e);
            match e {
                AppError::NotFound => Err(actix_web::error::ErrorNotFound("User not found")),
                _ => Err(actix_web::error::ErrorInternalServerError("Failed to get user"))
            }
        }
    }
}

pub async fn update_user(
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
    user_data: web::Json<UpdateUser>,
) -> Result<HttpResponse, Error> {
    match UserService::update_user(&pool, user_id.into_inner(), user_data.into_inner()) {
        Ok(user) => Ok(HttpResponse::Ok().json(user)),
        Err(e) => {
            log::error!("Error updating user: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to update user"))
        }
    }
}

pub async fn delete_user(
    pool: web::Data<DbPool>,
    user_id: web::Path<Uuid>,
) -> Result<HttpResponse, Error> {
    match UserService::delete_user(&pool, user_id.into_inner()) {
        Ok(_) => Ok(HttpResponse::NoContent().finish()),
        Err(e) => {
            log::error!("Error deleting user: {:?}", e);
            Err(actix_web::error::ErrorInternalServerError("Failed to delete user"))
        }
    }
}

pub async fn refresh_token(pool: web::Data<DbPool>, token: web::Json<String>) -> impl Responder {
    match UserService::refresh_token(&pool, &token.into_inner()) {
        Ok(new_token) => HttpResponse::Ok().json(serde_json::json!({ "token": new_token })),
        Err(_) => HttpResponse::Unauthorized().json(serde_json::json!({ "error": "Invalid token" })),
    }
}

==== END OF FILE: src//handlers/user.rs ====

==== START OF FILE: src//handlers/amber_store.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::amber_store_service::AmberStoreService;
use crate::models::amber_store::{NewAmberStore, UpdateAmberStore, NewAmberStorePayload};


pub async fn create_amber_store(
    pool: web::Data<DbPool>,
    new_amber_store_payload: web::Json<NewAmberStorePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating amber store for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_amber_store_payload);

    let new_amber_store = NewAmberStore {
        user_id,
        data: new_amber_store_payload.data.clone(),
    };
    match AmberStoreService::create_amber_store(&pool, new_amber_store) {
        Ok(amber_store) => {
            log::info!("Amber store created successfully: {:?}", amber_store);
            HttpResponse::Created().json(amber_store)
        },
        Err(e) => {
            log::error!("Error creating amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create amber store")
        }
    }
}

pub async fn list_amber_stores(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::list_amber_stores(&pool, user_id) {
        Ok(amber_stores) => HttpResponse::Ok().json(amber_stores),
        Err(e) => {
            log::error!("Error listing amber stores: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list amber stores")
        }
    }
}

pub async fn get_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::get_amber_store(&pool, amber_store_id.into_inner(), user_id) {
        Ok(amber_store) => HttpResponse::Ok().json(amber_store),
        Err(e) => {
            log::error!("Error getting amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get amber store")
        }
    }
}

pub async fn update_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    update_data: web::Json<UpdateAmberStore>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::update_amber_store(&pool, amber_store_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(amber_store) => HttpResponse::Ok().json(amber_store),
        Err(e) => {
            log::error!("Error updating amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update amber store")
        }
    }
}

pub async fn delete_amber_store(
    pool: web::Data<DbPool>,
    amber_store_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match AmberStoreService::delete_amber_store(&pool, amber_store_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting amber store: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete amber store")
        }
    }
}==== END OF FILE: src//handlers/amber_store.rs ====

==== START OF FILE: src//handlers/mod.rs ====
pub mod user;
pub mod job;
pub mod api_key;
pub mod amber_store;
pub mod secure_vault;
pub mod configuration;
pub mod pipeline;
pub mod docker_file;
pub mod worker;==== END OF FILE: src//handlers/mod.rs ====

==== START OF FILE: src//handlers/pipeline.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::pipeline_service::PipelineService;
use crate::models::pipeline::{NewPipeline, UpdatePipeline, NewPipelinePayload};

pub async fn create_pipeline(
    pool: web::Data<DbPool>,
    new_pipeline_payload: web::Json<NewPipelinePayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating pipeline for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_pipeline_payload);

    let new_pipeline = NewPipeline {
        user_id,
        name: new_pipeline_payload.name.clone(),
        data: new_pipeline_payload.data.clone(),
    };
    match PipelineService::create_pipeline(&pool, new_pipeline) {
        Ok(pipeline) => {
            log::info!("Pipeline created successfully: {:?}", pipeline);
            HttpResponse::Created().json(pipeline)
        },
        Err(e) => {
            log::error!("Error creating pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create pipeline")
        }
    }
}

pub async fn list_pipelines(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::list_pipelines(&pool, user_id) {
        Ok(pipelines) => HttpResponse::Ok().json(pipelines),
        Err(e) => {
            log::error!("Error listing pipelines: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list pipelines")
        }
    }
}

pub async fn get_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::get_pipeline(&pool, pipeline_id.into_inner(), user_id) {
        Ok(pipeline) => HttpResponse::Ok().json(pipeline),
        Err(e) => {
            log::error!("Error getting pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get pipeline")
        }
    }
}

pub async fn update_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    update_data: web::Json<UpdatePipeline>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::update_pipeline(&pool, pipeline_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(pipeline) => HttpResponse::Ok().json(pipeline),
        Err(e) => {
            log::error!("Error updating pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update pipeline")
        }
    }
}

pub async fn delete_pipeline(
    pool: web::Data<DbPool>,
    pipeline_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match PipelineService::delete_pipeline(&pool, pipeline_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting pipeline: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete pipeline")
        }
    }
}==== END OF FILE: src//handlers/pipeline.rs ====

==== START OF FILE: src//handlers/secure_vault.rs ====
use actix_web::{web, HttpResponse, Responder, HttpRequest, HttpMessage};
use uuid::Uuid;
use crate::db::DbPool;
use crate::services::secure_vault_service::SecureVaultService;
use crate::models::secure_vault::{NewSecureVault, UpdateSecureVault, NewSecureVaultPayload};
use crate::utils::encryption::encrypt_data;

pub async fn create_secure_vault(
    pool: web::Data<DbPool>,
    new_secure_vault_payload: web::Json<NewSecureVaultPayload>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    log::info!("Creating secure vault for user_id: {}", user_id);
    log::info!("Received data: {:?}", new_secure_vault_payload);

    let encrypted_data = encrypt_data(&new_secure_vault_payload.data);
    let new_secure_vault = NewSecureVault {
        user_id,
        name: new_secure_vault_payload.name.clone(),
        encrypted_data,
    };
    log::info!("New secure vault data: {:?}", new_secure_vault);

    match SecureVaultService::create_secure_vault(&pool, new_secure_vault) {
        Ok(secure_vault) => {
            log::info!("Secure vault created successfully: {:?}", secure_vault);
            HttpResponse::Created().json(secure_vault)
        },
        Err(e) => {
            log::error!("Error creating secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to create secure vault")
        }
    }
}

pub async fn list_secure_vaults(pool: web::Data<DbPool>, req: HttpRequest) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::list_secure_vaults(&pool, user_id) {
        Ok(secure_vaults) => HttpResponse::Ok().json(secure_vaults),
        Err(e) => {
            log::error!("Error listing secure vaults: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to list secure vaults")
        }
    }
}

pub async fn get_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::get_secure_vault(&pool, secure_vault_id.into_inner(), user_id) {
        Ok(secure_vault) => HttpResponse::Ok().json(secure_vault),
        Err(e) => {
            log::error!("Error getting secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to get secure vault")
        }
    }
}

pub async fn update_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    update_data: web::Json<UpdateSecureVault>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::update_secure_vault(&pool, secure_vault_id.into_inner(), update_data.into_inner(), user_id) {
        Ok(secure_vault) => HttpResponse::Ok().json(secure_vault),
        Err(e) => {
            log::error!("Error updating secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to update secure vault")
        }
    }
}

pub async fn delete_secure_vault(
    pool: web::Data<DbPool>,
    secure_vault_id: web::Path<Uuid>,
    req: HttpRequest,
) -> impl Responder {
    let user_id = req.extensions().get::<Uuid>().cloned().unwrap();
    match SecureVaultService::delete_secure_vault(&pool, secure_vault_id.into_inner(), user_id) {
        Ok(_) => HttpResponse::NoContent().finish(),
        Err(e) => {
            log::error!("Error deleting secure vault: {:?}", e);
            HttpResponse::InternalServerError().body("Failed to delete secure vault")
        }
    }
}==== END OF FILE: src//handlers/secure_vault.rs ====

==== START OF FILE: src//handlers/api_key.rs ====
use actix_web::{web, HttpResponse, Responder};

pub async fn create_api_key() -> impl Responder {
    HttpResponse::Ok().body("Create API key")
}

pub async fn list_api_keys() -> impl Responder {
    HttpResponse::Ok().body("List API keys")
}

pub async fn delete_api_key() -> impl Responder {
    HttpResponse::Ok().body("Delete API key")
}
==== END OF FILE: src//handlers/api_key.rs ====

==== START OF FILE: src//services/fluentcli_service.rs ====
use crate::error::AppError;
use std::process::Command;

pub struct FluentCLIService;

impl FluentCLIService {
    pub fn execute_command(&self, command: &str) -> Result<String, AppError> {
        let output = Command::new("fluentcli")
            .args(command.split_whitespace())
            .output()
            .map_err(|e| AppError::FluentCLIError(e.to_string()))?;

        if output.status.success() {
            Ok(String::from_utf8_lossy(&output.stdout).to_string())
        } else {
            Err(AppError::FluentCLIError(String::from_utf8_lossy(&output.stderr).to_string()))
        }
    }
}==== END OF FILE: src//services/fluentcli_service.rs ====

==== START OF FILE: src//services/worker_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::worker::{Worker, NewWorker, UpdateWorker};
use diesel::prelude::*;
use uuid::Uuid;

pub struct WorkerService;

impl WorkerService {
    pub fn create_worker(pool: &DbPool, new_worker: NewWorker) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new worker into database: {:?}", new_worker);
        match diesel::insert_into(workers)
            .values(&new_worker)
            .get_result(conn) {
            Ok(worker) => {
                log::info!("Worker inserted into database: {:?}", worker);
                Ok(worker)
            },
            Err(e) => {
                log::error!("Error inserting worker into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_workers(pool: &DbPool, user_id: Uuid) -> Result<Vec<Worker>, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        workers.filter(user_id.eq(user_id)).load::<Worker>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        workers.filter(id.eq(worker_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_worker(pool: &DbPool, worker_id: Uuid, update_data: UpdateWorker, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }

    pub fn activate_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(active.eq(true))
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn deactivate_worker(pool: &DbPool, worker_id: Uuid, user_id: Uuid) -> Result<Worker, AppError> {
        use crate::schema::workers::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(workers.filter(id.eq(worker_id).and(user_id.eq(user_id))))
            .set(active.eq(false))
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
}==== END OF FILE: src//services/worker_service.rs ====

==== START OF FILE: src//services/configuration_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::configuration::{Configuration, NewConfiguration, UpdateConfiguration};
use diesel::prelude::*;
use uuid::Uuid;

pub struct ConfigurationService;

impl ConfigurationService {
    pub fn create_configuration(pool: &DbPool, new_configuration: NewConfiguration) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new configuration into database: {:?}", new_configuration);
        diesel::insert_into(configurations)
            .values(&new_configuration)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_configurations(pool: &DbPool, user_id: Uuid) -> Result<Vec<Configuration>, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        configurations.filter(user_id.eq(user_id)).load::<Configuration>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_configuration(pool: &DbPool, configuration_id: Uuid, user_id: Uuid) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_configuration(pool: &DbPool, configuration_id: Uuid, update_data: UpdateConfiguration, user_id: Uuid) -> Result<Configuration, AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_configuration(pool: &DbPool, configuration_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::configurations::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(configurations.filter(id.eq(configuration_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/configuration_service.rs ====

==== START OF FILE: src//services/docker_file_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::docker_file::{DockerFile, NewDockerFile, UpdateDockerFile};
use diesel::prelude::*;
use uuid::Uuid;

pub struct DockerFileService;

impl DockerFileService {
    pub fn create_docker_file(pool: &DbPool, new_docker_file: NewDockerFile) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new docker file into database: {:?}", new_docker_file);
        diesel::insert_into(docker_files)
            .values(&new_docker_file)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_docker_files(pool: &DbPool, user_id: Uuid) -> Result<Vec<DockerFile>, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        docker_files.filter(user_id.eq(user_id)).load::<DockerFile>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_docker_file(pool: &DbPool, docker_file_id: Uuid, user_id: Uuid) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_docker_file(pool: &DbPool, docker_file_id: Uuid, update_data: UpdateDockerFile, user_id: Uuid) -> Result<DockerFile, AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_docker_file(pool: &DbPool, docker_file_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::docker_files::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(docker_files.filter(id.eq(docker_file_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/docker_file_service.rs ====

==== START OF FILE: src//services/pipeline_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::pipeline::{Pipeline, NewPipeline, UpdatePipeline};
use diesel::prelude::*;
use uuid::Uuid;

pub struct PipelineService;

impl PipelineService {
    pub fn create_pipeline(pool: &DbPool, new_pipeline: NewPipeline) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new pipeline into database: {:?}", new_pipeline);
        diesel::insert_into(pipelines)
            .values(&new_pipeline)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_pipelines(pool: &DbPool, user_id: Uuid) -> Result<Vec<Pipeline>, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        pipelines.filter(user_id.eq(user_id)).load::<Pipeline>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_pipeline(pool: &DbPool, pipeline_id: Uuid, user_id: Uuid) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_pipeline(pool: &DbPool, pipeline_id: Uuid, update_data: UpdatePipeline, user_id: Uuid) -> Result<Pipeline, AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_pipeline(pool: &DbPool, pipeline_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::pipelines::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(pipelines.filter(id.eq(pipeline_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/pipeline_service.rs ====

==== START OF FILE: src//services/mod.rs ====
pub mod job_service;
pub mod fluentcli_service;
pub mod user_service;
pub mod amber_store_service;
pub mod configuration_service;
pub mod docker_file_service;
pub mod pipeline_service;
pub mod worker_service;
pub mod secure_vault_service;==== END OF FILE: src//services/mod.rs ====

==== START OF FILE: src//services/secure_vault_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::secure_vault::{SecureVault, NewSecureVault, UpdateSecureVault};
use diesel::prelude::*;
use uuid::Uuid;

pub struct SecureVaultService;

impl SecureVaultService {
    pub fn create_secure_vault(pool: &DbPool, new_secure_vault: NewSecureVault) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new secure vault into database: {:?}", new_secure_vault);
        match diesel::insert_into(secure_vaults)
            .values(&new_secure_vault)
            .get_result(conn) {
            Ok(secure_vault) => {
                log::info!("Secure vault inserted into database: {:?}", secure_vault);
                Ok(secure_vault)
            },
            Err(e) => {
                log::error!("Error inserting secure vault into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_secure_vaults(pool: &DbPool, user_id: Uuid) -> Result<Vec<SecureVault>, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Listing secure vaults for user_id: {:?}", user_id);
        secure_vaults.filter(user_id.eq(user_id))
            .load::<SecureVault>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_secure_vault(pool: &DbPool, secure_vault_id: Uuid, user_id: Uuid) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Getting secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id)))
            .first::<SecureVault>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_secure_vault(pool: &DbPool, secure_vault_id: Uuid, update_data: UpdateSecureVault, user_id: Uuid) -> Result<SecureVault, AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Updating secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        diesel::update(secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_secure_vault(pool: &DbPool, secure_vault_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::secure_vaults::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Deleting secure vault with id: {:?} for user_id: {:?}", secure_vault_id, user_id);
        diesel::delete(secure_vaults.filter(id.eq(secure_vault_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map(|_| ())
            .map_err(AppError::DatabaseError)
    }
}==== END OF FILE: src//services/secure_vault_service.rs ====

==== START OF FILE: src//services/amber_store_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::amber_store::{AmberStore, NewAmberStore, UpdateAmberStore};
use diesel::prelude::*;
use uuid::Uuid;

pub struct AmberStoreService;

impl AmberStoreService {
    pub fn create_amber_store(pool: &DbPool, new_amber_store: NewAmberStore) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new amber store into database: {:?}", new_amber_store);
        diesel::insert_into(amber_store)
            .values(&new_amber_store)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn list_amber_stores(pool: &DbPool, user_id: Uuid) -> Result<Vec<AmberStore>, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        amber_store.filter(user_id.eq(user_id)).load::<AmberStore>(conn).map_err(AppError::DatabaseError)
    }

    pub fn get_amber_store(pool: &DbPool, amber_store_id: Uuid, user_id: Uuid) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))).first(conn).map_err(AppError::DatabaseError)
    }

    pub fn update_amber_store(pool: &DbPool, amber_store_id: Uuid, update_data: UpdateAmberStore, user_id: Uuid) -> Result<AmberStore, AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_amber_store(pool: &DbPool, amber_store_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::amber_store::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(amber_store.filter(id.eq(amber_store_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }
}==== END OF FILE: src//services/amber_store_service.rs ====

==== START OF FILE: src//services/user_service.rs ====
use std::fmt::Debug;
use actix_web::HttpMessage;
use chrono::Utc;
use crate::db::DbPool;
use crate::error::AppError;
use crate::utils::auth::{hash_password, verify_password};
use crate::models::user::{NewUser, User, UpdateUser, NewUserDB};
use diesel::prelude::*;
use uuid::Uuid;
use crate::utils::jwt;

pub struct UserService;

impl UserService {
    pub fn create_user(pool: &DbPool, new_user: NewUser) -> Result<User, AppError> {
        use crate::schema::users;
        let conn = &mut pool.get()?;
    
        let hashed_password = hash_password(&new_user.password)?;
        let new_user_db = NewUserDB {
            username: new_user.username,
            email: new_user.email,
            password_hash: hashed_password, // Use password_hash field
        };
    
        diesel::insert_into(users::table)
            .values(&new_user_db) // Use new_user_db for insertion
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn login(pool: &DbPool, username: &str, password: &str) -> Result<User, AppError> {
        let user = Self::get_user_by_username(pool, username.to_string())?;
        match verify_password(password, &user.password_hash) {
            Ok(is_valid) => {
                if is_valid {
                    Ok(user)
                } else {
                    Err(AppError::AuthenticationError)
                }
            },
            Err(e) => {
                log::error!("Password verification error: {:?}", e);
                Err(AppError::InternalServerError)
            }
        }
    }

    pub fn get_user_by_username(pool: &DbPool, username_: String) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;

        let conn = &mut pool.get()?;
        
        users
            .filter(username.eq(username_))
            .first(conn)
            .map_err(|error| {
                if error == diesel::result::Error::NotFound {
                    AppError::NotFound
                } else {
                    AppError::DatabaseError(error)
                }
            })
    }


    pub fn get_user(pool: &DbPool, user_id: Uuid) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Received GET user request. User ID: {:?},", user_id);
        users.find(user_id)
            .first(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn update_user(pool: &DbPool, user_id: Uuid, update_data: UpdateUser) -> Result<User, AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        diesel::update(users.find(user_id))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }
    
    pub fn delete_user(pool: &DbPool, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::users::dsl::*;
        let conn = &mut pool.get()?;
        diesel::delete(users.find(user_id))
            .execute(conn)
            .map_err(AppError::DatabaseError)?;
        Ok(())
    }

    pub fn email_exists(pool: &DbPool, email: &str) -> Result<bool, AppError> {
        use crate::schema::users::dsl::*;
        
        let conn = &mut pool.get()?;
        let count = users.filter(email.eq(email))
                         .count()
                         .get_result::<i64>(conn)?;
        
        Ok(count > 0)
    }

    pub fn list_users(pool: &DbPool) -> Result<Vec<User>, AppError> {
        use crate::schema::users::dsl::*; // Add this line to import users
        let conn = &mut pool.get()?;
        users.load::<User>(conn).map_err(AppError::DatabaseError)
    }

    pub fn refresh_token(pool: &DbPool, token: &str) -> Result<String, AppError> {
        let user_id = jwt::validate_token(token)?;
        let user = Self::get_user(pool, user_id)?;
        jwt::generate_token(user.id)
    }

    
}
==== END OF FILE: src//services/user_service.rs ====

==== START OF FILE: src//services/job_service.rs ====
use crate::db::DbPool;
use crate::error::AppError;
use crate::models::job::{Job, NewJob, UpdateJob};
use diesel::prelude::*;
use uuid::Uuid;

pub struct JobService;

impl JobService {
    pub fn create_job(pool: &DbPool, new_job: NewJob) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Inserting new job into database: {:?}", new_job);
        match diesel::insert_into(jobs)
            .values(&new_job)
            .get_result(conn) {
            Ok(job) => {
                log::info!("Job inserted into database: {:?}", job);
                Ok(job)
            },
            Err(e) => {
                log::error!("Error inserting job into database: {:?}", e);
                Err(AppError::DatabaseError(e))
            }
        }
    }

    pub fn list_jobs(pool: &DbPool, user_id: Uuid) -> Result<Vec<Job>, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Listing jobs for user_id: {:?}", user_id);
        jobs.filter(user_id.eq(user_id))
            .load::<Job>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn get_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Getting job with id: {:?} for user_id: {:?}", job_id, user_id);
        jobs.filter(id.eq(job_id).and(user_id.eq(user_id)))
            .first::<Job>(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn update_job(pool: &DbPool, job_id: Uuid, update_data: UpdateJob, user_id: Uuid) -> Result<Job, AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Updating job with id: {:?} for user_id: {:?}", job_id, user_id);
        diesel::update(jobs.filter(id.eq(job_id).and(user_id.eq(user_id))))
            .set(&update_data)
            .get_result(conn)
            .map_err(AppError::DatabaseError)
    }

    pub fn delete_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<(), AppError> {
        use crate::schema::jobs::dsl::*;
        let conn = &mut pool.get()?;
        log::info!("Deleting job with id: {:?} for user_id: {:?}", job_id, user_id);
        diesel::delete(jobs.filter(id.eq(job_id).and(user_id.eq(user_id))))
            .execute(conn)
            .map(|_| ())
            .map_err(AppError::DatabaseError)
    }

    pub fn start_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        // Implement the logic to start a job
        unimplemented!()
    }

    pub fn stop_job(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<Job, AppError> {
        // Implement the logic to stop a job
        unimplemented!()
    }

    pub fn get_job_status(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the status of a job
        unimplemented!()
    }

    pub fn get_job_output(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the output of a job
        unimplemented!()
    }

    pub fn get_job_logs(pool: &DbPool, job_id: Uuid, user_id: Uuid) -> Result<String, AppError> {
        // Implement the logic to get the logs of a job
        unimplemented!()
    }
}==== END OF FILE: src//services/job_service.rs ====

==== START OF FILE: frontend/src//App.vue ====
<template>
  <div id="app">
    <nav>
      <router-link to="/">Home</router-link> |
      <router-link to="/admin">Admin</router-link> |
      <router-link to="/studio">Studio</router-link> |
      <button @click="handleAuthAction">{{ authButtonText }}</button>
    </nav>
    <router-view></router-view>
  </div>
</template>

<script lang="ts">
import { defineComponent, computed } from 'vue';
import { useStore } from 'vuex';
import { useRouter } from 'vue-router';
import AuthService from './services/AuthService';

export default defineComponent({
  name: 'App',
  setup() {
    const store = useStore();
    const router = useRouter();

    const isLoggedIn = computed(() => store.state.isLoggedIn);
    const authButtonText = computed(() => (isLoggedIn.value ? 'Logout' : 'Login'));

    const handleAuthAction = () => {
      if (isLoggedIn.value) {
        // Logout
        AuthService.logout();
        store.commit('setLoggedIn', false);
        store.commit('setUser', null);
        router.push('/');
      } else {
        // Navigate to Login page
        router.push('/login');
      }
    };

    return {
      authButtonText,
      handleAuthAction,
    };
  },
});
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  color: #2c3e50;
}

nav {
  padding: 30px;
}

nav a {
  font-weight: bold;
  color: #2c3e50;
}

nav a.router-link-exact-active {
  color: #42b983;
}
</style>==== END OF FILE: frontend/src//App.vue ====

==== START OF FILE: frontend/src//main.ts ====
// frontend/src/main.ts

import { createApp } from 'vue';
import App from './App.vue';
import router from './router';
import store from './store';
import AuthService from '@/services/AuthService';

const token = AuthService.getToken();
if (token) {
  AuthService.setToken(token);
  store.commit('setLoggedIn', true);
  // Optionally fetch user data here
}

createApp(App).use(router).use(store).mount('#app');==== END OF FILE: frontend/src//main.ts ====

==== START OF FILE: frontend/src//extensions/tiptap.d.ts ====
import '@tiptap/core';

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    /**
     * Insert a Data Pill with the given value
     */
    insertDataPill: (value: string) => ReturnType;
  }
}

export {};==== END OF FILE: frontend/src//extensions/tiptap.d.ts ====

==== START OF FILE: frontend/src//extensions/DataPill.ts ====
// src/extensions/DataPill.ts

import { Node, mergeAttributes } from '@tiptap/core'

export interface DataPillOptions {
  HTMLAttributes: Record<string, any>
}

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    dataPill: {
      insertDataPill: (value: string) => ReturnType
    }
  }
}

export const DataPill = Node.create<DataPillOptions>({
  name: 'dataPill',

  group: 'inline',

  inline: true,

  atom: true,

  addOptions() {
    return {
      HTMLAttributes: {},
    }
  },

  addAttributes() {
    return {
      value: {
        default: null,
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'span[data-type="data-pill"]',
      },
    ]
  },

  renderHTML({ node, HTMLAttributes }) {
    return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { 'data-type': 'data-pill' }), node.attrs.value]
  },

  addCommands() {
    return {
      insertDataPill: (value: string) => ({ chain }) => {
        return chain()
          .insertContent({
            type: this.name,
            attrs: { value },
          })
          .run()
      },
    }
  },
})==== END OF FILE: frontend/src//extensions/DataPill.ts ====

==== START OF FILE: frontend/src//components/studio/editors/PipelineEditor.vue ====
<template>
    <div class="pipeline-editor">
      <h2>Pipeline Editor</h2>
      <form @submit.prevent="savePipeline">
        <div class="form-group">
          <label for="name">Pipeline Name</label>
          <input
            type="text"
            id="name"
            v-model="pipeline.name"
            required
            class="form-control"
          />
        </div>
        <div class="form-group">
          <label for="editor">Pipeline Configuration</label>
          <EditorContent :editor="editor" />
        </div>
        <div class="button-group">
          <button type="submit" class="btn btn-primary">Save Pipeline</button>
        </div>
      </form>
    </div>
  </template>

  <script lang="ts">
  import { defineComponent, ref, watch } from 'vue';
  import JsonEditorWithPills from '@/components/JsonEditorWithPills.vue';
  import { useEditor, EditorContent } from '@tiptap/vue-3';
  import StarterKit from '@tiptap/starter-kit';
  import { DataPill } from '@/extensions/DataPill';

  interface Pipeline {
    id?: string;
    name: string;
    data: any;
  }

  export default defineComponent({
    name: 'PipelineEditor',
    components: { JsonEditorWithPills, EditorContent },
    props: {
      data: {
        type: Object as () => Pipeline,
        required: true,
      },
    },
    setup(props, { emit }) {
      const pipeline = ref<Pipeline>({ ...props.data });
      const isSaving = ref(false);
      const errorMessage = ref('');

      const editor = useEditor({
        extensions: [StarterKit, DataPill],
        content: pipeline.value.data,
      });

      const insertDataPill = () => {
        if (editor.value) {
          editor.value.commands.insertDataPill('dynamic_value');
        }
      };

      watch(
        () => pipeline.value.data,
        (_) => {
          try {
            // Assuming you want to stringify or handle changes accordingly
            // For demonstration, not modifying pipeline.value.data
            errorMessage.value = '';
          } catch (e) {
            errorMessage.value = 'Invalid JSON format.';
          }
        }
      );

      const savePipeline = () => {
        if (errorMessage.value) return;
        isSaving.value = true;
        emit('save', pipeline.value);
      };

      return {
        pipeline,
        isSaving,
        errorMessage,
        savePipeline,
        editor,
        insertDataPill,
      };
    },
  });
  </script>

  <style scoped>
  .pipeline-editor {
    padding: 20px;
  }
  .form-group {
    margin-bottom: 15px;
  }
  .button-group {
    margin-top: 20px;
  }
  </style>==== END OF FILE: frontend/src//components/studio/editors/PipelineEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/DockerFileEditor.vue ====
<template>
    <div class="dockerfile-editor">
      <h2>Dockerfile Editor</h2>
      <form @submit.prevent="saveDockerfile">
        <div>
          <label for="name">Name:</label>
          <input type="text" id="name" v-model="dockerfile.name" required />
        </div>
        <div>
          <label for="content">Content:</label>
          <textarea id="content" v-model="dockerfile.content" rows="20" required></textarea>
        </div>
        <button type="submit">Save Dockerfile</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  
  export default defineComponent({
    name: 'DockerFileEditor',
    props: {
      data: {
        type: Object,
        required: true,
      },
    },
    setup(props) {
      const dockerfile = ref({ ...props.data });
  
      const saveDockerfile = () => {
        // Implement save logic
        console.log('Saving Dockerfile:', dockerfile.value);
      };
  
      return {
        dockerfile,
        saveDockerfile,
      };
    },
  });
  </script>==== END OF FILE: frontend/src//components/studio/editors/DockerFileEditor.vue ====

==== START OF FILE: frontend/src//components/studio/editors/ConfigurationEditor.vue ====
<template>
    <div class="configuration-editor">
      <h2>Configuration Editor</h2>
      <form @submit.prevent="saveConfiguration">
        <div>
          <label for="name">Name:</label>
          <input type="text" id="name" v-model="config.name" required />
        </div>
        <div>
          <label for="data">Data:</label>
          <textarea id="data" v-model="config.data" rows="10" required></textarea>
        </div>
        <button type="submit">Save Configuration</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  
  export default defineComponent({
    name: 'ConfigurationEditor',
    props: {
      data: {
        type: Object,
        required: true,
      },
    },
    setup(props) {
      const config = ref({ ...props.data });
  
      const saveConfiguration = () => {
        // Implement save logic
        console.log('Saving configuration:', config.value);
      };
  
      return {
        config,
        saveConfiguration,
      };
    },
  });
  </script>==== END OF FILE: frontend/src//components/studio/editors/ConfigurationEditor.vue ====

==== START OF FILE: frontend/src//components/studio/JobList.vue ====
<template>
  <div class="job-list">
    <h2>Job List</h2>
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>URI</th>
          <th>Worker Type</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="job in jobs" :key="job.id">
          <td>{{ job.id }}</td>
          <td>{{ job.uri }}</td>
          <td>{{ job.worker_type }}</td>
          <td>
            <router-link :to="`/admin/jobs/${job.id}`">View</router-link> |
            <router-link :to="`/admin/jobs/${job.id}/edit`">Edit</router-link> |
            <button @click="deleteJob(job.id)" class="delete-button">Delete</button>
          </td>
        </tr>
      </tbody>
    </table>
    <p v-if="jobs.length === 0">No jobs available.</p>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, onMounted } from 'vue';
import axios from 'axios';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

export default defineComponent({
  name: 'JobList',
  setup() {
    const jobs = ref<Job[]>([]);
    const isLoading = ref(true);
    const errorMessage = ref('');

    const fetchJobs = async () => {
      try {
        const response = await axios.get('/jobs'); // Adjust the endpoint as needed
        jobs.value = response.data;
      } catch (error) {
        console.error('Failed to fetch jobs:', error);
        errorMessage.value = 'Failed to load jobs.';
      } finally {
        isLoading.value = false;
      }
    };

    const deleteJob = async (id: number) => {
      if (!confirm('Are you sure you want to delete this job?')) return;
      try {
        await axios.delete(`/api/jobs/${id}`); // Adjust the endpoint as needed
        jobs.value = jobs.value.filter(job => job.id !== id);
      } catch (error) {
        console.error('Failed to delete job:', error);
        alert('Failed to delete the job. Please try again.');
      }
    };

    onMounted(() => {
      fetchJobs();
    });

    return {
      jobs,
      isLoading,
      errorMessage,
      deleteJob,
    };
  },
});
</script>

<style scoped>
.job-list {
  padding: 20px;
}

.job-list table {
  width: 100%;
  border-collapse: collapse;
}

.job-list th,
.job-list td {
  border: 1px solid #ddd;
  padding: 8px;
}

.job-list th {
  background-color: #f2f2f2;
  text-align: left;
}

.delete-button {
  background-color: #c0392b;
  color: #fff;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
}

.delete-button:hover {
  background-color: #e74c3c;
}

button {
  background: none;
  border: none;
  color: #2980b9;
  cursor: pointer;
}

button:hover {
  text-decoration: underline;
}

p {
  margin-top: 20px;
  color: #7f8c8d;
}
</style>==== END OF FILE: frontend/src//components/studio/JobList.vue ====

==== START OF FILE: frontend/src//components/studio/StudioWorkspace.vue ====
<template>
    <div class="studio-workspace">
      <component
        :is="activeComponent"
        v-if="activeComponent"
        :key="activeTabId"
        :data="activeTabData"
      />
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, computed } from 'vue';
  import { useStore } from 'vuex';
  import ConfigurationEditor from '@/components/studio/editors/ConfigurationEditor.vue';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  import DockerFileEditor from '@/components/studio/editors/DockerFileEditor.vue';
  
  export default defineComponent({
    name: 'StudioWorkspace',
    components: {
      ConfigurationEditor,
      PipelineEditor,
      DockerFileEditor,
    },
    setup() {
      const store = useStore();
  
      const activeTabId = computed(() => store.state.studio.activeTabId);
      const activeTab = computed(() => store.getters['studio/activeTab']);
  
      const activeComponent = computed(() => {
        if (!activeTab.value) return null;
        switch (activeTab.value.type) {
          case 'configuration':
            return 'ConfigurationEditor';
          case 'pipeline':
            return 'PipelineEditor';
          case 'dockerFile':
            return 'DockerFileEditor';
          default:
            return null;
        }
      });
  
      const activeTabData = computed(() => activeTab.value?.data || {});
  
      return {
        activeTabId,
        activeComponent,
        activeTabData,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio-workspace {
    flex-grow: 1;
    padding: 1rem;
    overflow-y: auto;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioWorkspace.vue ====

==== START OF FILE: frontend/src//components/studio/StudioSidebar.vue ====
<template>
    <div :class="['sidebar', { collapsed: isCollapsed }]">
      <div class="toggle-button" @click="$emit('toggle')">
        <span v-if="!isCollapsed">«</span>
        <span v-else>»</span>
      </div>
      <nav>
        <ul>
          <li>
            <router-link to="/studio/dashboard">Dashboard</router-link>
          </li>
          <li>
            <router-link to="/studio/jobs">Jobs</router-link>
          </li>
          <li>
            <router-link to="/studio/pipelines">Pipelines</router-link>
          </li>
          <li>
            <router-link to="/studio/settings">Settings</router-link>
          </li>
        </ul>
      </nav>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'StudioSidebar',
    props: {
      isCollapsed: {
        type: Boolean,
        required: true,
      },
    },
  });
  </script>
  
  <style scoped>
  .sidebar {
    width: 250px;
    background-color: #2c3e50;
    color: #ecf0f1;
    transition: width 0.3s;
    position: relative;
  }
  
  .sidebar.collapsed {
    width: 80px;
  }
  
  .toggle-button {
    position: absolute;
    top: 10px;
    right: -15px;
    background-color: #34495e;
    border-radius: 50%;
    padding: 5px;
    cursor: pointer;
  }
  
  nav ul {
    list-style: none;
    padding: 0;
    margin-top: 50px;
  }
  
  nav ul li {
    padding: 15px 20px;
  }
  
  nav ul li a {
    color: #ecf0f1;
    text-decoration: none;
    display: block;
  }
  
  nav ul li a.router-link-exact-active {
    background-color: #1abc9c;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioSidebar.vue ====

==== START OF FILE: frontend/src//components/studio/StudioHeader.vue ====
<template>
    <header class="studio-header">
      <button class="menu-button" @click="$emit('toggleSidebar')">☰</button>
      <div class="user-info">
        <span>Welcome, {{ userName }}</span>
        <button @click="logout">Logout</button>
      </div>
    </header>
  </template>
  
  <script lang="ts">
  import { defineComponent, computed } from 'vue';
  import { useStore } from 'vuex';
  import AuthService from '@/services/AuthService';
  import { useRouter } from 'vue-router';
  
  export default defineComponent({
    name: 'StudioHeader',
    setup() {
      const store = useStore();
      const router = useRouter();
  
      const userName = computed(() => store.state.user?.name || 'User');
  
      const logout = () => {
        AuthService.logout();
        store.commit('setLoggedIn', false);
        store.commit('setUser', null);
        router.push('/');
      };
  
      return {
        userName,
        logout,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio-header {
    height: 60px;
    background-color: #ecf0f1;
    display: flex;
    align-items: center;
    padding: 0 20px;
    justify-content: space-between;
    border-bottom: 1px solid #bdc3c7;
  }
  
  .menu-button {
    font-size: 24px;
    background: none;
    border: none;
    cursor: pointer;
  }
  
  .user-info {
    display: flex;
    align-items: center;
  }
  
  .user-info span {
    margin-right: 15px;
  }
  
  .user-info button {
    padding: 5px 10px;
    cursor: pointer;
  }
  </style>==== END OF FILE: frontend/src//components/studio/StudioHeader.vue ====

==== START OF FILE: frontend/src//components/studio/PipelineList.vue ====
<!-- frontend/src/components/studio/PipelineList.vue -->
<template>
    <div class="pipeline-list">
      <h2>Pipeline List</h2>
      <router-link to="/studio/pipelines/create" class="create-button">Create New Pipeline</router-link>
      <table>
        <thead>
          <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Description</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>
          <tr v-for="pipeline in pipelines" :key="pipeline.id">
            <td>{{ pipeline.id }}</td>
            <td>{{ pipeline.name }}</td>
            <td>{{ pipeline.description }}</td>
            <td>
              <router-link :to="`/studio/pipelines/${pipeline.id}`">View</router-link> |
              <router-link :to="`/studio/pipelines/${pipeline.id}/edit`">Edit</router-link> |
              <button @click="deletePipeline(pipeline.id)" class="delete-button">Delete</button>
            </td>
          </tr>
        </tbody>
      </table>
      <p v-if="pipelines.length === 0">No pipelines available.</p>
      <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
      <p v-if="isLoading" class="loading">Loading pipelines...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    id: number;
    name: string;
    description: string;
    // ... other properties
  }
  
  const pipelines = ref<Pipeline[]>([]);
  const isLoading = ref(true);
  const errorMessage = ref('');
  
  const fetchPipelines = async () => {
    try {
      const response = await apiClient.get('/pipelines');
      pipelines.value = response.data;
    } catch (error: any) {
      errorMessage.value = error.response?.data?.message || 'Failed to load pipelines.';
    } finally {
      isLoading.value = false;
    }
  };
  
  const deletePipeline = async (id: number) => {
    if (!confirm('Are you sure you want to delete this pipeline?')) return;
    try {
      await apiClient.delete(`/pipelines/${id}`);
      pipelines.value = pipelines.value.filter(pipeline => pipeline.id !== id);
    } catch (error: any) {
      alert('Failed to delete the pipeline. Please try again.');
    }
  };
  
  onMounted(() => {
    fetchPipelines();
  });
  </script>
  
  <style scoped>
  .pipeline-list {
    padding: 20px;
  }
  .pipeline-list .create-button {
    display: inline-block;
    margin-bottom: 15px;
  }
  .pipeline-list table {
    width: 100%;
    border-collapse: collapse;
  }
  .pipeline-list th,
  .pipeline-list td {
    border: 1px solid #ddd;
    padding: 8px;
  }
  .pipeline-list th {
    background-color: #f2f2f2;
    text-align: left;
  }
  .delete-button {
    background-color: #c0392b;
    color: #fff;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
    cursor: pointer;
  }
  .delete-button:hover {
    background-color: #e74c3c;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//components/studio/PipelineList.vue ====

==== START OF FILE: frontend/src//components/LoginLogout.vue ====
<template>
    <button @click="toggleLogin">{{ buttonText }}</button>
  </template>
  
  <script lang="ts">
  import { computed, defineComponent } from 'vue'
  import { useStore } from 'vuex'
  
  export default defineComponent({
    setup() {
      const store = useStore()
  
      const isLoggedIn = computed(() => store.getters.isLoggedIn)
      const buttonText = computed(() => isLoggedIn.value ? 'Logout' : 'Login')
  
      const toggleLogin = async () => {
        if (isLoggedIn.value) {
          await store.dispatch('logout')
        } else {
          // For simplicity, we're not handling the login form here.
          // You might want to show a login modal or navigate to a login page.
          console.log('Show login form')
        }
      }
  
      return {
        buttonText,
        toggleLogin
      }
    }
  })
  </script>==== END OF FILE: frontend/src//components/LoginLogout.vue ====

==== START OF FILE: frontend/src//components/Greet.vue ====
<script setup lang="ts">
import { ref } from "vue";
import { invoke } from "@tauri-apps/api/tauri";

const greetMsg = ref("");
const name = ref("");

async function greet() {
  greetMsg.value = await invoke("greet", { name: name.value });
}
</script>

<template>
  <form class="row" @submit.prevent="greet">
    <input id="greet-input" v-model="name" placeholder="Enter a name..." />
    <button type="submit">Greet</button>
  </form>

  <p>{{ greetMsg }}</p>
</template>==== END OF FILE: frontend/src//components/Greet.vue ====

==== START OF FILE: frontend/src//components/common/TreeView.vue ====
<template>
    <ul class="tree-view">
      <li v-for="item in items" :key="item.name">
        <div @click="toggleItem(item)">
          <span v-if="item.children && item.children.length">
            {{ item.expanded ? '▼' : '▶' }}
          </span>
          <span @click="$emit('item-click', item)">{{ item.name }}</span>
        </div>
        <TreeView
          v-if="item.children && item.children.length && item.expanded"
          :items="item.children"
          @item-click="$emit('item-click', $event)"
        />
      </li>
    </ul>
  </template>
  
  <script lang="ts">
  import { defineComponent, PropType } from 'vue';
  
  interface TreeItem {
    name: string;
    children?: TreeItem[];
    expanded?: boolean;
  }
  
  export default defineComponent({
    name: 'TreeView',
    props: {
      items: {
        type: Array as PropType<TreeItem[]>,
        required: true,
      },
    },
    emits: ['item-click'],
    methods: {
      toggleItem(item: TreeItem) {
        if (item.children && item.children.length) {
          item.expanded = !item.expanded;
        }
      },
    },
  });
  </script>
  
  <style scoped>
  .tree-view {
    list-style-type: none;
    padding-left: 1rem;
  }
  .tree-view li {
    cursor: pointer;
  }
  </style>==== END OF FILE: frontend/src//components/common/TreeView.vue ====

==== START OF FILE: frontend/src//components/JsonEditorWithPills.vue ====
<!-- JsonEditorWithPills.vue -->
<template>
    <div class="json-editor-with-pills">
      <MonacoEditor
        v-model="code"
        language="json"
        :options="editorOptions"
        @editorMounted="onEditorMounted"
      />
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref, watch } from 'vue';

  import * as MonacoEditor from 'monaco-editor';



  export default defineComponent({
    name: 'JsonEditorWithPills',
    components: { MonacoEditor },
    props: {
      modelValue: {
        type: String,
        required: true,
      },
    },
    emits: ['update:modelValue'],
    setup(props, { emit }) {
      const code = ref(props.modelValue);
  
      const editorOptions = {
        automaticLayout: true,
        // Additional editor options
      };
  
      const onEditorMounted = () => {
        // Implement data pills functionality here
        // e.g., custom syntax highlighting, hover tips, or decorations
      };
  
      watch(code, (newValue) => {
        emit('update:modelValue', newValue);
      });
  
      return {
        code,
        editorOptions,
        onEditorMounted,
      };
    },
  });
  </script>
  
  <style scoped>
  .json-editor-with-pills {
    height: 400px; /* Adjust as needed */
  }
  </style>==== END OF FILE: frontend/src//components/JsonEditorWithPills.vue ====

==== START OF FILE: frontend/src//vite-env.d.ts ====
/// <reference types="vite/client" />

declare module "*.vue" {
  import type { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
==== END OF FILE: frontend/src//vite-env.d.ts ====

==== START OF FILE: frontend/src//config.ts ====
export const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8000';==== END OF FILE: frontend/src//config.ts ====

==== START OF FILE: frontend/src//views/studio/Settings.vue ====
<template>
    <div class="settings">
      <h1>Settings</h1>
      <p>Manage your Studio settings here.</p>
      <!-- Add settings forms and options here -->
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Settings',
  });
  </script>
  
  <style scoped>
  .settings {
    padding: 20px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Settings.vue ====

==== START OF FILE: frontend/src//views/studio/PipelineDetails.vue ====
<!-- frontend/src/views/studio/PipelineDetails.vue -->
<template>
    <div v-if="pipeline" class="pipeline-details">
      <h1>Pipeline Details</h1>
      <p><strong>ID:</strong> {{ pipeline.id }}</p>
      <p><strong>Name:</strong> {{ pipeline.name }}</p>
      <p><strong>Description:</strong> {{ pipeline.description }}</p>
      <!-- Display other pipeline properties as needed -->
      <router-link :to="`/studio/pipelines/${pipeline.id}/edit`">Edit Pipeline</router-link>
    </div>
    <div v-else>
      <p>Loading pipeline details...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import { useRoute } from 'vue-router';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    id: number;
    name: string;
    description: string;
    // ... other properties
  }
  
  const route = useRoute();
  const pipeline = ref<Pipeline | null>(null);
  const errorMessage = ref('');
  
  const fetchPipeline = async () => {
    try {
      const response = await apiClient.get(`/pipelines/${route.params.id}`);
      pipeline.value = response.data;
    } catch (error: any) {
      errorMessage.value = error.response?.data?.message || 'Failed to load pipeline details.';
    }
  };
  
  onMounted(() => {
    fetchPipeline();
  });
  </script>
  
  <style scoped>
  .pipeline-details {
    padding: 20px;
  }
  .pipeline-details p {
    margin-bottom: 10px;
  }
  .pipeline-details a {
    color: #42b983;
    text-decoration: none;
  }
  .pipeline-details a:hover {
    text-decoration: underline;
  }
  </style>==== END OF FILE: frontend/src//views/studio/PipelineDetails.vue ====

==== START OF FILE: frontend/src//views/studio/PipelineCreate.vue ====
<!-- frontend/src/views/studio/PipelineCreate.vue -->
<template>
    <div class="pipeline-create">
      <h1>Create Pipeline</h1>
      <PipelineEditor
        :data="pipeline"
        @save="createPipeline"
      />
      <p v-if="isLoading" class="loading">Creating pipeline...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref } from 'vue';
  import { useRouter } from 'vue-router';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    name: string;
    data: any;
  }
  
  const router = useRouter();
  const pipeline = ref<Pipeline>({
    name: '',
    data: {},
  });
  const isLoading = ref(false);
  
  const createPipeline = async (newPipeline: Pipeline) => {
    isLoading.value = true;
    try {
      await apiClient.post('/pipelines', newPipeline);
      router.push('/studio/pipelines');
    } catch (error: any) {
      console.error('Failed to create pipeline:', error);
    } finally {
      isLoading.value = false;
    }
  };
  </script>
  
  <style scoped>
  .pipeline-create {
    padding: 20px;
  }
  .pipeline-create form {
    display: flex;
    flex-direction: column;
  }
  .pipeline-create label {
    margin-bottom: 5px;
  }
  .pipeline-create input {
    margin-bottom: 15px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 3px;
  }
  .pipeline-create button {
    padding: 10px;
    background-color: #2c3e50;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  .pipeline-create button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/PipelineCreate.vue ====

==== START OF FILE: frontend/src//views/studio/Dashboard.vue ====
<template>
    <div class="dashboard">
      <h1>Studio Dashboard</h1>
      <p>Welcome to the Studio Dashboard!</p>
      <!-- Add more dashboard widgets and information here -->
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Dashboard',
  });
  </script>
  
  <style scoped>
  .dashboard {
    padding: 20px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Dashboard.vue ====

==== START OF FILE: frontend/src//views/studio/PipelineEdit.vue ====
<!-- frontend/src/views/studio/PipelineEdit.vue -->
<template>
    <div v-if="pipeline" class="pipeline-edit">
      <h1>Edit Pipeline</h1>
      <PipelineEditor
        :data="pipeline"
        @save="updatePipeline"
      />
      <p v-if="isLoading" class="loading">Updating pipeline...</p>
    </div>
    <div v-else>
      <p>Loading pipeline details...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, onMounted } from 'vue';
  import { useRoute, useRouter } from 'vue-router';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  import apiClient from '@/services/apiClient';
  
  interface Pipeline {
    id: string;
    name: string;
    data: any;
  }
  
  const route = useRoute();
  const router = useRouter();
  const pipeline = ref<Pipeline | null>(null);
  const isLoading = ref(false);
  
  const fetchPipeline = async () => {
    try {
      const response = await apiClient.get(`/pipelines/${route.params.id}`);
      pipeline.value = response.data;
    } catch (error: any) {
      console.error('Failed to load pipeline details:', error);
    }
  };
  
  const updatePipeline = async (updatedPipeline: Pipeline) => {
    if (!pipeline.value) return;
    isLoading.value = true;
    try {
      await apiClient.put(`/pipelines/${pipeline.value.id}`, updatedPipeline);
      router.push('/studio/pipelines');
    } catch (error: any) {
      console.error('Failed to update pipeline:', error);
    } finally {
      isLoading.value = false;
    }
  };
  
  onMounted(() => {
    fetchPipeline();
  });
  </script>
  
  <style scoped>
  .pipeline-edit {
    padding: 20px;
  }
  .pipeline-edit form {
    display: flex;
    flex-direction: column;
  }
  .pipeline-edit label {
    margin-bottom: 5px;
  }
  .pipeline-edit input {
    margin-bottom: 15px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 3px;
  }
  .pipeline-edit button {
    padding: 10px;
    background-color: #2980b9;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  .pipeline-edit button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
  }
  .error {
    color: red;
    margin-top: 10px;
  }
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/PipelineEdit.vue ====

==== START OF FILE: frontend/src//views/studio/JobCreate.vue ====
<template>
    <div class="job-create">
      <h2>Create New Job</h2>
      <form @submit.prevent="createJob">
        <div>
          <label for="uri">URI:</label>
          <input type="text" id="uri" v-model="job.uri" required />
        </div>
        <div>
          <label for="worker_type">Worker Type:</label>
          <input type="text" id="worker_type" v-model="job.worker_type" required />
        </div>
        <!-- Add more fields as necessary -->
        <button type="submit">Create</button>
      </form>
      <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
      <p v-if="isLoading">Creating job...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref } from 'vue';
  import { useRouter } from 'vue-router';
  import apiClient from '@/services/apiClient';
  
  interface Job {
    uri: string;
    worker_type: string;
    // ... other properties
  }
  
  const job = ref<Job>({
    uri: '',
    worker_type: '',
    // ... initialize other properties
  });
  
  const router = useRouter();
  const errorMessage = ref('');
  const isLoading = ref(false);
  
  const createJob = async () => {
    isLoading.value = true;
    errorMessage.value = '';
    try {
      await apiClient.post('/jobs', job.value); // Adjust endpoint if needed
      router.push('/studio/jobs');
    } catch (error: any) {
      console.error('Failed to create job:', error);
      errorMessage.value = error.response?.data?.message || 'Failed to create job.';
    } finally {
      isLoading.value = false;
    }
  };
  </script>
  
  <style scoped>
  .job-create {
    padding: 20px;
  }
  
  .job-create form {
    display: flex;
    flex-direction: column;
  }
  
  .job-create label {
    margin-bottom: 5px;
  }
  
  .job-create input {
    margin-bottom: 15px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 3px;
  }
  
  .job-create button {
    padding: 10px;
    background-color: #2c3e50;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  
  .job-create button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
  }
  
  .error {
    color: red;
    margin-top: 10px;
  }
  
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/JobCreate.vue ====

==== START OF FILE: frontend/src//views/studio/JobDetails.vue ====
<template>
    <div class="job-create">
      <h2>Create New Job</h2>
      <form @submit.prevent="createJob">
        <div>
          <label for="uri">URI:</label>
          <input type="text" id="uri" v-model="job.uri" required />
        </div>
        <div>
          <label for="worker_type">Worker Type:</label>
          <input type="text" id="worker_type" v-model="job.worker_type" required />
        </div>
        <!-- Add more fields as necessary -->
        <button type="submit">Create</button>
      </form>
      <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
      <p v-if="isLoading">Creating job...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref } from 'vue';
  import { useRouter } from 'vue-router';
  import apiClient from '@/services/apiClient';
  
  interface Job {
    uri: string;
    worker_type: string;
    // ... other properties
  }
  
  const job = ref<Job>({
    uri: '',
    worker_type: '',
    // ... initialize other properties
  });
  
  const router = useRouter();
  const errorMessage = ref('');
  const isLoading = ref(false);
  
  const createJob = async () => {
    isLoading.value = true;
    errorMessage.value = '';
    try {
      await apiClient.post('/jobs', job.value); // Adjust endpoint if needed
      router.push('/studio/jobs');
    } catch (error: any) {
      console.error('Failed to create job:', error);
      errorMessage.value = error.response?.data?.message || 'Failed to create job.';
    } finally {
      isLoading.value = false;
    }
  };
  </script>
  
  <style scoped>
  .job-create {
    padding: 20px;
  }
  
  .job-create form {
    display: flex;
    flex-direction: column;
  }
  
  .job-create label {
    margin-bottom: 5px;
  }
  
  .job-create input {
    margin-bottom: 15px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 3px;
  }
  
  .job-create button {
    padding: 10px;
    background-color: #2c3e50;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  
  .job-create button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
  }
  
  .error {
    color: red;
    margin-top: 10px;
  }
  
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/JobDetails.vue ====

==== START OF FILE: frontend/src//views/studio/JobsList.vue ====
<template>
  <div class="job-list">
    <h2>Job List</h2>
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>URI</th>
          <th>Worker Type</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="job in jobs" :key="job.id">
          <td>{{ job.id }}</td>
          <td>{{ job.uri }}</td>
          <td>{{ job.worker_type }}</td>
          <td>
            <router-link :to="`/admin/jobs/${job.id}`">View</router-link> |
            <router-link :to="`/admin/jobs/${job.id}/edit`">Edit</router-link> |
            <button @click="deleteJob(job.id)" class="delete-button">Delete</button>
          </td>
        </tr>
      </tbody>
    </table>
    <p v-if="jobs.length === 0">No jobs available.</p>
    <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
    <p v-if="isLoading">Loading jobs...</p>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import apiClient from '@/services/apiClient';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const jobs = ref<Job[]>([]);
const isLoading = ref(true);
const errorMessage = ref('');

const fetchJobs = async () => {
  try {
    const response = await apiClient.get('/jobs'); // Adjust endpoint if needed
    jobs.value = response.data;
  } catch (error: any) {
    console.error('Failed to fetch jobs:', error);
    errorMessage.value = error.response?.data?.message || 'Failed to load jobs.';
  } finally {
    isLoading.value = false;
  }
};

const deleteJob = async (id: number) => {
  if (!confirm('Are you sure you want to delete this job?')) return;
  try {
    await apiClient.delete(`/jobs/${id}`); // Adjust endpoint if needed
    jobs.value = jobs.value.filter(job => job.id !== id);
  } catch (error) {
    console.error('Failed to delete job:', error);
    alert('Failed to delete the job. Please try again.');
  }
};

onMounted(() => {
  fetchJobs();
});
</script>

<style scoped>
.job-list {
  padding: 20px;
}

.job-list table {
  width: 100%;
  border-collapse: collapse;
}

.job-list th,
.job-list td {
  border: 1px solid #ddd;
  padding: 8px;
}

.job-list th {
  background-color: #f2f2f2;
  text-align: left;
}

.delete-button {
  background-color: #c0392b;
  color: #fff;
  border: none;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
}

.delete-button:hover {
  background-color: #e74c3c;
}

.error {
  color: red;
}

p {
  margin-top: 20px;
}

.loading {
  color: #3498db;
}
</style>==== END OF FILE: frontend/src//views/studio/JobsList.vue ====

==== START OF FILE: frontend/src//views/studio/Jobs.vue ====
<template>
  <div class="jobs">
    <h1>Manage Jobs</h1>
    <router-link to="/studio/jobs/create" class="create-button">Create New Job</router-link>
    <JobList />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue';
import JobList from '@/components/studio/JobList.vue';

export default defineComponent({
  name: 'Jobs',
  components: {
    JobList,
  },
});
</script>

<style scoped>
.jobs {
  padding: 20px;
}

.create-button {
  background-color: #27ae60;
  color: #fff;
  padding: 8px 12px;
  border-radius: 5px;
  text-decoration: none;
  margin-bottom: 15px;
  display: inline-block;
}
</style>==== END OF FILE: frontend/src//views/studio/Jobs.vue ====

==== START OF FILE: frontend/src//views/studio/Pipelines.vue ====
<template>
    <div class="pipelines">
      <h1>Pipelines</h1>
      <button @click="addPipeline" class="add-button">Add New Pipeline</button>
  
      <!-- Pipeline Editor Modal -->
      <div v-if="showEditor && selectedPipeline" class="modal">
        <div class="modal-content">
          <PipelineEditor
            :data="selectedPipeline"
            @save="handleSave"
            @cancel="closeEditor"
          />
        </div>
      </div>
  
      <!-- List of Pipelines -->
      <div v-if="pipelines.length">
        <ul class="pipeline-list">
          <li v-for="pipeline in pipelines" :key="pipeline.id" class="pipeline-item">
            <span>{{ pipeline.name }}</span>
            <div class="actions">
              <router-link :to="`/studio/pipelines/${pipeline.id}`">View</router-link> |
              <router-link :to="`/studio/pipelines/${pipeline.id}/edit`">Edit</router-link> |
              <button @click="deletePipeline(pipeline.id)" class="delete-button">Delete</button>
            </div>
          </li>
        </ul>
      </div>
      <div v-else>
        <p>No pipelines available.</p>
      </div>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref, onMounted } from 'vue';
  import apiClient from '@/services/apiClient';
  import PipelineEditor from '@/components/studio/editors/PipelineEditor.vue';
  
  interface Pipeline {
    id: string;
    name: string;
    data: any;
  }
  
  export default defineComponent({
    name: 'Pipelines',
    components: {
      PipelineEditor,
    },
    setup() {
      const pipelines = ref<Pipeline[]>([]);
      const showEditor = ref(false);
      const selectedPipeline = ref<Pipeline | null>(null);
  
      const fetchPipelines = async () => {
        try {
          const response = await apiClient.get('/pipelines');
          pipelines.value = response.data;
        } catch (error: any) {
          console.error('Failed to fetch pipelines:', error);
        }
      };
  
      const addPipeline = () => {
        selectedPipeline.value = { id: '', name: '', data: {} };
        showEditor.value = true;
      };
  
      const handleSave = async (pipeline: Pipeline) => {
        try {
          if (pipeline.id) {
            // Update existing pipeline
            await apiClient.put(`/pipelines/${pipeline.id}`, pipeline);
          } else {
            // Create new pipeline
            const response = await apiClient.post('/pipelines', pipeline);
            pipeline.id = response.data.id;
            pipelines.value.push(pipeline);
          }
          await fetchPipelines();
          closeEditor();
        } catch (error: any) {
          console.error('Failed to save pipeline:', error);
        }
      };
  
      const closeEditor = () => {
        showEditor.value = false;
        selectedPipeline.value = null;
      };
  
      const deletePipeline = async (id: string) => {
        if (!confirm('Are you sure you want to delete this pipeline?')) return;
        try {
          await apiClient.delete(`/pipelines/${id}`);
          pipelines.value = pipelines.value.filter((p) => p.id !== id);
        } catch (error: any) {
          alert('Failed to delete the pipeline. Please try again.');
        }
      };
  
      onMounted(() => {
        fetchPipelines();
      });
  
      return {
        pipelines,
        showEditor,
        selectedPipeline,
        addPipeline,
        handleSave,
        closeEditor,
        deletePipeline,
      };
    },
  });
  </script>
  
  <style scoped>
  .pipelines {
    padding: 20px;
  }
  
  .pipelines .add-button {
    margin-bottom: 15px;
    padding: 10px 20px;
    background-color: #2980b9;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  
  .pipelines .add-button:hover {
    background-color: #3498db;
  }
  
  .pipeline-list {
    list-style-type: none;
    padding: 0;
  }
  
  .pipeline-item {
    display: flex;
    justify-content: space-between;
    padding: 10px 0;
    border-bottom: 1px solid #ddd;
  }
  
  .pipeline-item .actions a,
  .pipeline-item .actions .delete-button {
    margin-left: 10px;
    color: #2980b9;
    text-decoration: none;
    cursor: pointer;
  }
  
  .pipeline-item .actions .delete-button {
    background-color: #c0392b;
    color: #fff;
    border: none;
    padding: 5px 10px;
    border-radius: 3px;
  }
  
  .pipeline-item .actions .delete-button:hover {
    background-color: #e74c3c;
  }
  
  .error {
    color: red;
    margin-top: 10px;
  }
  
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  
  .modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .modal-content {
    background-color: #fff;
    padding: 20px;
    border-radius: 5px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/Pipelines.vue ====

==== START OF FILE: frontend/src//views/studio/JobEdit.vue ====
<template>
    <div class="job-create">
      <h2>Create New Job</h2>
      <form @submit.prevent="createJob">
        <div>
          <label for="uri">URI:</label>
          <input type="text" id="uri" v-model="job.uri" required />
        </div>
        <div>
          <label for="worker_type">Worker Type:</label>
          <input type="text" id="worker_type" v-model="job.worker_type" required />
        </div>
        <!-- Add more fields as necessary -->
        <button type="submit">Create</button>
      </form>
      <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
      <p v-if="isLoading">Creating job...</p>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref } from 'vue';
  import { useRouter } from 'vue-router';
  import apiClient from '@/services/apiClient';
  
  interface Job {
    uri: string;
    worker_type: string;
    // ... other properties
  }
  
  const job = ref<Job>({
    uri: '',
    worker_type: '',
    // ... initialize other properties
  });
  
  const router = useRouter();
  const errorMessage = ref('');
  const isLoading = ref(false);
  
  const createJob = async () => {
    isLoading.value = true;
    errorMessage.value = '';
    try {
      await apiClient.post('/jobs', job.value); // Adjust endpoint if needed
      router.push('/studio/jobs');
    } catch (error: any) {
      console.error('Failed to create job:', error);
      errorMessage.value = error.response?.data?.message || 'Failed to create job.';
    } finally {
      isLoading.value = false;
    }
  };
  </script>
  
  <style scoped>
  .job-create {
    padding: 20px;
  }
  
  .job-create form {
    display: flex;
    flex-direction: column;
  }
  
  .job-create label {
    margin-bottom: 5px;
  }
  
  .job-create input {
    margin-bottom: 15px;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 3px;
  }
  
  .job-create button {
    padding: 10px;
    background-color: #2c3e50;
    color: #ecf0f1;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }
  
  .job-create button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
  }
  
  .error {
    color: red;
    margin-top: 10px;
  }
  
  .loading {
    color: #3498db;
    margin-top: 10px;
  }
  </style>==== END OF FILE: frontend/src//views/studio/JobEdit.vue ====

==== START OF FILE: frontend/src//views/Login.vue ====
<template>
    <div class="login">
      <h2>Login</h2>
      <form @submit.prevent="login">
        <input v-model="username" type="text" placeholder="Username" required />
        <input v-model="password" type="password" placeholder="Password" required />
        <button type="submit">Login</button>
      </form>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  import { useRouter } from 'vue-router';
  import { useStore } from 'vuex';
  import AuthService from '../services/AuthService';
  
  export default defineComponent({
    name: 'Login',
    setup() {
      const username = ref('');
      const password = ref('');
      const router = useRouter();
      const store = useStore();
  
      const login = async () => {
        try {
          const { token, user } = await AuthService.login(username.value, password.value);
          AuthService.setToken(token);
          store.commit('setLoggedIn', true);
          store.commit('setUser', user);
          router.push('/');
        } catch (error) {
          console.error('Login failed:', error);
          // Handle login error (e.g., show error message)
        }
      };
  
      return { username, password, login };
    },
  });
  </script>
  
  <style scoped>
  .login {
    max-width: 300px;
    margin: 50px auto;
  }
  </style>==== END OF FILE: frontend/src//views/Login.vue ====

==== START OF FILE: frontend/src//views/Home.vue ====
<template>
    <div class="home">
      <h1>Welcome to FluentCLI Web Services</h1>
      <p>This is the home page.</p>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent } from 'vue';
  
  export default defineComponent({
    name: 'Home'
  });
  </script>==== END OF FILE: frontend/src//views/Home.vue ====

==== START OF FILE: frontend/src//views/Studio.vue ====
<template>
    <div class="studio">
      <nav class="studio-sidebar">
        <router-link to="/studio/dashboard">Dashboard</router-link>
        <router-link to="/studio/jobs">Jobs</router-link>
        <router-link to="/studio/pipelines">Pipelines</router-link>
        <!-- Include other navigation links as needed -->
      </nav>
      <main class="studio-main">
        <router-view />
      </main>
    </div>
  </template>
  
  <script lang="ts">
  import { defineComponent, ref } from 'vue';
  import StudioSidebar from '@/components/studio/StudioSidebar.vue';
  import StudioHeader from '@/components/studio/StudioHeader.vue';
  
  export default defineComponent({
    name: 'Studio',
    components: {
      StudioSidebar,
      StudioHeader,
    },
    setup() {
      const isSidebarCollapsed = ref(false);
  
      const toggleSidebar = () => {
        isSidebarCollapsed.value = !isSidebarCollapsed.value;
      };
  
      return {
        isSidebarCollapsed,
        toggleSidebar,
      };
    },
  });
  </script>
  
  <style scoped>
  .studio {
    display: flex;
    height: calc(100vh - 60px);
  }
  .studio-sidebar {
    width: 200px;
    background-color: #2c3e50;
    padding: 20px;
  }
  .studio-sidebar a {
    display: block;
    color: #ecf0f1;
    text-decoration: none;
    margin-bottom: 10px;
  }
  .studio-sidebar a.router-link-exact-active {
    font-weight: bold;
  }
  .studio-main {
    flex-grow: 1;
    padding: 20px;
  }
  </style>==== END OF FILE: frontend/src//views/Studio.vue ====

==== START OF FILE: frontend/src//views/admin/Login.vue ====
<template>
  <div class="login">
    <h2>Login</h2>
    <form @submit.prevent="login">
      <input v-model="username" type="text" placeholder="Username" required />
      <input v-model="password" type="password" placeholder="Password" required />
      <button type="submit" :disabled="isLoading">
        {{ isLoading ? 'Logging in...' : 'Login' }}
      </button>
    </form>
    <p v-if="errorMessage" class="error">{{ errorMessage }}</p>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref } from 'vue';
import { useRouter } from 'vue-router';
import { useStore } from 'vuex';
import AuthService from '@/services/AuthService';

export default defineComponent({
  name: 'Login',
  setup() {
    const username = ref('');
    const password = ref('');
    const errorMessage = ref('');
    const isLoading = ref(false);
    const router = useRouter();
    const store = useStore();

    const login = async () => {
      errorMessage.value = '';
      isLoading.value = true;
      try {
        const { token, user } = await AuthService.login(username.value, password.value);
        AuthService.setToken(token);
        store.commit('setLoggedIn', true);
        store.commit('setUser', user);
        router.push('/');
      } catch (error: any) {
        console.error('Login failed:', error);
        errorMessage.value = error.response?.data?.message || 'Login failed. Please try again.';
      } finally {
        isLoading.value = false;
      }
    };

    return { username, password, login, errorMessage, isLoading };
  },
});
</script>

<style scoped>
.login {
  max-width: 300px;
  margin: 50px auto;
  padding: 20px;
  border: 1px solid #bdc3c7;
  border-radius: 5px;
  background-color: #fff;
}

.login h2 {
  text-align: center;
  margin-bottom: 20px;
}

.login form {
  display: flex;
  flex-direction: column;
}

.login input {
  padding: 10px;
  margin-bottom: 15px;
  border: 1px solid #bdc3c7;
  border-radius: 3px;
}

.login button {
  padding: 10px;
  background-color: #2c3e50;
  color: #ecf0f1;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}

.login button:disabled {
  background-color: #95a5a6;
  cursor: not-allowed;
}

.error {
  color: red;
  text-align: center;
  margin-top: 10px;
}
</style>==== END OF FILE: frontend/src//views/admin/Login.vue ====

==== START OF FILE: frontend/src//views/admin/JobCreate.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref } from 'vue';
import { useRouter } from 'vue-router';

interface Job {
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const router = useRouter();
const newJob = ref<Job>({
  uri: '',
  config: {},
  worker_type: '',
  // ... initialize other properties
});

const createJob = async () => {
  try {
    await axios.post('/jobs', newJob.value);
    router.push('/admin/jobs'); // Redirect to job list after successful creation
  } catch (error) {
    console.error(error);
    // Handle error, e.g., display an error message to the user
  }
};
</script>

<template>
  <div>
    <h1>Create Job</h1>
    <form @submit.prevent="createJob">
      <label for="uri">URI:</label>
      <input type="text" id="uri" v-model="newJob.uri" />

      <!-- ... input fields for other job properties ... -->

      <button type="submit">Create</button>
    </form>
  </div>
</template>==== END OF FILE: frontend/src//views/admin/JobCreate.vue ====

==== START OF FILE: frontend/src//views/admin/JobList.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref, onMounted } from 'vue';
import { API_URL } from '@/config';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const jobs = ref<Job[]>([]);

onMounted(async () => {
  try {
    const response = await axios.get(`${API_URL}/jobs`);
    jobs.value = response.data;
  } catch (error) {
    console.error('Failed to fetch jobs:', error);
    // Optionally, set an error message to display to the user
  }
});
</script>

<template>
  <div>
    <h1>Jobs</h1>
    <ul>
      <li v-for="job in jobs" :key="job.id">
        <router-link :to="`/admin/jobs/${job.id}`">{{ job.uri }}</router-link>
      </li>
    </ul>
    <p v-if="jobs.length === 0">No jobs available.</p>
  </div>
</template>==== END OF FILE: frontend/src//views/admin/JobList.vue ====

==== START OF FILE: frontend/src//views/admin/JobDetails.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref, onMounted } from 'vue';
import { useRoute } from 'vue-router';
import { API_URL } from '@/config';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const route = useRoute();
const job = ref<Job | null>(null);

onMounted(async () => {
  try {
    const response = await axios.get(`${API_URL}/jobs/${route.params.id}`);
    job.value = response.data;
  } catch (error) {
    console.error('Failed to fetch job details:', error);
    // Optionally, set an error message to display to the user
  }
});
</script>

<template>
  <div v-if="job">
    <h1>Job Details</h1>
    <p>URI: {{ job.uri }}</p>
    <p>Config: {{ job.config }}</p>
    <p>Worker Type: {{ job.worker_type }}</p>
    <!-- ... display other job details ... -->
  </div>
  <div v-else>
    <p>Loading job details...</p>
  </div>
</template>==== END OF FILE: frontend/src//views/admin/JobDetails.vue ====

==== START OF FILE: frontend/src//views/admin/JobEdit.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref, onMounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { API_URL } from '@/config';

interface Job {
  id: number;
  uri: string;
  config: any; // Replace with the actual type of your job config
  worker_type: string;
  // ... other properties
}

const route = useRoute();
const router = useRouter();
const job = ref<Job | null>(null);

onMounted(async () => {
  try {
    const response = await axios.get(`${API_URL}/jobs/${route.params.id}`);
    job.value = response.data;
  } catch (error) {
    console.error('Failed to fetch job details:', error);
    // Optionally, set an error message to display to the user
  }
});

const updateJob = async () => {
  if (!job.value) return;
  try {
    await axios.put(`${API_URL}/jobs/${route.params.id}`, job.value);
    router.push('/admin/jobs'); // Redirect to job list after successful update
  } catch (error) {
    console.error('Failed to update job:', error);
    // Optionally, set an error message to display to the user
  }
};
</script>

<template>
  <div v-if="job">
    <h1>Edit Job</h1>
    <form @submit.prevent="updateJob">
      <label for="uri">URI:</label>
      <input type="text" id="uri" v-model="job.uri" />

      <!-- ... input fields for other job properties ... -->

      <button type="submit">Update Job</button>
    </form>
  </div>
  <div v-else>
    <p>Loading job details...</p>
  </div>
</template>==== END OF FILE: frontend/src//views/admin/JobEdit.vue ====

==== START OF FILE: frontend/src//views/WorkerTypeList.vue ====
<script setup lang="ts">
import axios from 'axios';
import { ref, onMounted } from 'vue';

interface WorkerType {
  id: number;
  name: string;
  // ... other properties
}

const workerTypes = ref<WorkerType[]>([]);

onMounted(async () => {
  try {
    const response = await axios.get('/worker-types'); // Replace with your actual API endpoint
    workerTypes.value = response.data;
  } catch (error) {
    console.error(error);
    // Handle error, e.g., display an error message to the user
  }
});
</script>

<template>
  <div>
    <h1>Worker Types</h1>
    <ul>
      <li v-for="workerType in workerTypes" :key="workerType.id">
        {{ workerType.name }}
      </li>
    </ul>
  </div>
</template>==== END OF FILE: frontend/src//views/WorkerTypeList.vue ====

==== START OF FILE: frontend/src//views/Admin.vue ====
<template>
    <div>
      <h1>Admin</h1>
      <nav>
        <RouterLink to="/admin/jobs">Job List</RouterLink> |
        <RouterLink to="/admin/jobs/create">Create Job</RouterLink> 
      </nav>
      <RouterView />
    </div>
  </template>
  
  <script setup lang="ts">
    import { RouterLink, RouterView } from 'vue-router';

  </script>
  
  <style scoped>
    /* Add your styles here */
  </style>==== END OF FILE: frontend/src//views/Admin.vue ====

==== START OF FILE: frontend/src//services/AuthService.ts ====
import apiClient from './apiClient';

interface LoginResponse {
  token: string;
  user: any; // Define a proper type based on your user structure
}

const AuthService = {
  async login(username: string, password: string): Promise<LoginResponse> {
    const response = await apiClient.post('/users/login', { username, password });
    return response.data;
  },

  logout() {
    localStorage.removeItem('token');
    delete apiClient.defaults.headers.common['Authorization'];
    window.location.href = '/login';
  },

  setToken(token: string) {
    localStorage.setItem('token', token);
    apiClient.defaults.headers.common['Authorization'] = `Bearer ${token}`;
  },

  getToken(): string | null {
    return localStorage.getItem('token');
  },
};

export default AuthService;==== END OF FILE: frontend/src//services/AuthService.ts ====

==== START OF FILE: frontend/src//services/apiClient.ts ====
import axios from 'axios';
import { API_URL } from '@/config';
import AuthService from './AuthService';

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
    Accept: 'application/json',
  },
});

// Request interceptor to add the auth token to headers
apiClient.interceptors.request.use(
  (config) => {
    const token = AuthService.getToken();
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor to handle global errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle unauthorized access globally
    if (error.response && error.response.status === 401) {
      AuthService.logout();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default apiClient;==== END OF FILE: frontend/src//services/apiClient.ts ====

==== START OF FILE: frontend/src//store/types.ts ====
export interface RootState {
    // Define your root state properties here
    // For example:
    // user: User | null;
    // isAuthenticated: boolean;
  }==== END OF FILE: frontend/src//store/types.ts ====

==== START OF FILE: frontend/src//store/index.ts ====
import { createStore } from 'vuex';

export default createStore({
  state: {
    isLoggedIn: false,
    user: null,
  },
  mutations: {
    setLoggedIn(state, value: boolean) {
      state.isLoggedIn = value;
    },
    setUser(state, user: any) {
      state.user = user;
    },
  },
  actions: {
    login({ commit }, { user }) { // Removed 'token' since it's unused
      commit('setLoggedIn', true);
      commit('setUser', user);
    },
    logout({ commit }) {
      commit('setLoggedIn', false);
      commit('setUser', null);
    },
  },
  getters: {
    isLoggedIn: (state) => state.isLoggedIn,
    user: (state) => state.user,
  },
});==== END OF FILE: frontend/src//store/index.ts ====

==== START OF FILE: frontend/src//store/modules/studio.ts ====
import { Module } from 'vuex';
import { RootState } from '../types';

interface StudioState {
  openTabs: Array<{ id: string; name: string; type: string; data: any }>;
  activeTabId: string | null;
}

const studioModule: Module<StudioState, RootState> = {
  namespaced: true,
  state: {
    openTabs: [],
    activeTabId: null,
  },
  mutations: {
    addTab(state, tab) {
      state.openTabs.push(tab);
      state.activeTabId = tab.id;
    },
    closeTab(state, tabId) {
      const index = state.openTabs.findIndex((tab) => tab.id === tabId);
      if (index !== -1) {
        state.openTabs.splice(index, 1);
        if (state.activeTabId === tabId) {
          state.activeTabId = state.openTabs.length > 0 ? state.openTabs[0].id : null;
        }
      }
    },
    setActiveTab(state, tabId) {
      state.activeTabId = tabId;
    },
    updateTabData(state, { tabId, data }) {
      const tab = state.openTabs.find((tab) => tab.id === tabId);
      if (tab) {
        tab.data = data;
      }
    },
  },
  actions: {
    openTab({ commit, state }, { id, name, type, data }) {
      const existingTab = state.openTabs.find((tab) => tab.id === id);
      if (existingTab) {
        commit('setActiveTab', id);
      } else {
        commit('addTab', { id, name, type, data });
      }
    },
  },
  getters: {
    activeTab: (state) => state.openTabs.find((tab) => tab.id === state.activeTabId),
  },
};

export default studioModule;==== END OF FILE: frontend/src//store/modules/studio.ts ====

==== START OF FILE: frontend/src//router/index.ts ====
import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router';
import Home from '../views/Home.vue';
import Login from '../views/Login.vue';
import Admin from '../views/Admin.vue';
import Studio from '../views/Studio.vue';
import Dashboard from '../views/studio/Dashboard.vue';
import Jobs from '@/views/studio/Jobs.vue';
import JobCreate from '@/views/studio/JobCreate.vue';
import JobDetails from '@/views/studio/JobDetails.vue';
import JobEdit from '@/views/studio/JobEdit.vue';
import Pipelines from '../views/studio/Pipelines.vue';
import Settings from '../views/studio/Settings.vue';
import JobList from '../views/admin/JobList.vue';
import PipelineList from '../components/studio/PipelineList.vue';
import PipelineCreate from '../views/studio/PipelineCreate.vue';
import PipelineDetails from '../views/studio/PipelineDetails.vue';
import PipelineEdit from '../views/studio/PipelineEdit.vue';

import WorkerTypeList from '../views/WorkerTypeList.vue'; // This one remains in the root views folder
import store from '@/store';

const routes: Array<RouteRecordRaw> = [
  { path: '/', name: 'Home', component: Home },
  { path: '/login', name: 'Login', component: Login },
  { path: '/admin', name: 'Admin', component: Admin },
  { 
    path: '/studio', 
    name: 'Studio', 
    component: Studio,
    meta: { requiresAuth: true },
    children: [
      { path: 'dashboard', name: 'Dashboard', component: Dashboard },
      { path: 'jobs', name: 'Jobs', component: Jobs },
      { path: 'pipelines', name: 'Pipelines', component: Pipelines },
      { path: 'settings', name: 'Settings', component: Settings },
      {
        path: 'pipelines',
        name: 'PipelineList',
        component: PipelineList,
      },
      {
        path: 'pipelines/create',
        name: 'PipelineCreate',
        component: PipelineCreate,
      },
      {
        path: 'pipelines/:id',
        name: 'PipelineDetails',
        component: PipelineDetails,
        props: true,
      },
      {
        path: 'pipelines/:id/edit',
        name: 'PipelineEdit',
        component: PipelineEdit,
        props: true,
      }
    ],
  },
  { path: '/admin/jobs', name: 'JobList', component: JobList },
  { path: '/admin/jobs/create', name: 'JobCreate', component: JobCreate },
  { path: '/admin/jobs/:id', name: 'JobDetails', component: JobDetails },
  { path: '/admin/jobs/:id/edit', name: 'JobEdit', component: JobEdit },
  { path: '/worker-types', name: 'WorkerTypeList', component: WorkerTypeList },
];

const router = createRouter({
  history: createWebHistory(),
  routes,
});

// Navigation Guard
router.beforeEach((to, _, next) => {
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
  const isLoggedIn = store.getters.isLoggedIn;

  if (requiresAuth && !isLoggedIn) {
    next('/login');
  } else if (to.path === '/login' && isLoggedIn) {
    next('/');
  } else {
    next();
  }
});

export default router;==== END OF FILE: frontend/src//router/index.ts ====

